import { __extends } from "tslib";
import { registerElementLabels } from '@antv/g2';
import * as _ from '@antv/util';
import { getEndPoint } from './utils';
import BasePieLabel from './base-label';
import { DEFAULT_OFFSET, CROOK_DISTANCE } from './outer-label';
var OuterCenterPieLabel = /** @class */ (function (_super) {
    __extends(OuterCenterPieLabel, _super);
    function OuterCenterPieLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterCenterPieLabel.prototype.adjustPosition = function (labels, items, coord, panel) {
        this._adjustLabelPosition(labels, items, coord, panel);
    };
    /** @override */
    OuterCenterPieLabel.prototype.adjustLines = function (labels, labelItems, labelLines, coord, panel) {
        var _this = this;
        _.each(labels, function (label, idx) {
            var labelLine = labelLines[idx];
            var path = _this._getLinePath(label, coord, panel);
            labelLine.attr('path', path);
            labelLine.set('visible', label.get('visible'));
        });
    };
    /** @override */
    OuterCenterPieLabel.prototype.getOffsetOfLabel = function () {
        var labelOptions = this.get('labelOptions');
        var offset = labelOptions.offset;
        return offset === undefined ? DEFAULT_OFFSET : offset <= CROOK_DISTANCE ? 1 : offset - CROOK_DISTANCE;
    };
    // label shape position
    OuterCenterPieLabel.prototype._adjustLabelPosition = function (labels, items, coord, panel) {
        var _this = this;
        var center = coord.getCenter();
        var r = coord.getRadius();
        var distance = this.getCrookDistance();
        labels.forEach(function (l, idx) {
            var item = items[idx];
            var offset = _this.getOffsetOfLabel();
            var pos = getEndPoint(center, item.angle, r + offset);
            var isRight = item.textAlign === 'left';
            l.attr('x', pos.x + (isRight ? distance * 2 : -distance * 2));
            l.attr('y', pos.y);
        });
    };
    // 获取label leader-line
    OuterCenterPieLabel.prototype._getLinePath = function (label, coord, panel) {
        var labelOptions = this.getLabelOptions();
        var smooth = labelOptions.line ? labelOptions.line.smooth : false;
        var anchor = this.anchors.find(function (a) { return a.id === label.id; });
        var angle = anchor.angle;
        var center = coord.getCenter();
        var r = coord.getRadius();
        var start = getEndPoint(center, angle, r);
        // because shape is adjusted, so we should getAttrbutes by shape
        var offset = this.getOffsetOfLabel();
        var isRight = anchor.textAlign === 'left';
        var breakAt = getEndPoint(center, angle, r + offset);
        var distance = this.getCrookDistance() * (isRight ? 1 : -1);
        var end = { x: label.attr('x') - distance, y: label.attr('y') };
        var path = '';
        path = ["M " + start.x, start.y + " Q" + breakAt.x, breakAt.y + " " + end.x, end.y].join(',');
        if (smooth === false) {
            // normal path rule, draw path is "M -> L -> H"
            path = ["M " + start.x, start.y + " L" + breakAt.x, breakAt.y + " H" + end.x].join(',');
        }
        return path;
    };
    /** @override */
    // tslint:disable
    OuterCenterPieLabel.prototype.getDefaultOffset = function (point) {
        var offset = _super.prototype.getDefaultOffset.call(this, point);
        return offset === undefined ? DEFAULT_OFFSET : offset <= CROOK_DISTANCE ? 1 : offset - CROOK_DISTANCE;
    };
    OuterCenterPieLabel.prototype.getCrookDistance = function () {
        var labelOptions = this.get('labelOptions');
        var offset = labelOptions.offset;
        return offset < CROOK_DISTANCE * 2 ? offset / 2 : CROOK_DISTANCE;
    };
    return OuterCenterPieLabel;
}(BasePieLabel));
registerElementLabels('outer-center', OuterCenterPieLabel);
//# sourceMappingURL=outer-center-label.js.map