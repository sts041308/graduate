import { __extends } from "tslib";
import { registerElementLabels, getElementLabels } from '@antv/g2';
import * as _ from '@antv/util';
import { getEndPoint } from '../../../pie/component/label/utils';
import { distBetweenPoints } from '../../../../util/math';
import { autoAdjustColor } from './utils';
var PolarElementLabels = getElementLabels('polar');
var RoseLabels = /** @class */ (function (_super) {
    __extends(RoseLabels, _super);
    function RoseLabels() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RoseLabels.prototype.showLabels = function (points, shapes) {
        var _this = this;
        _super.prototype.showLabels.call(this, points, shapes);
        var renderer = this.get('labelsRenderer');
        var labels = renderer.get('group').get('children');
        var view = this.get('element').get('view');
        var _a = this.get('labelOptions'), fields = _a.fields, offset = _a.offset, adjustColor = _a.adjustColor, type = _a.type;
        var _b = view.get('coord'), center = _b.center, startAngle = _b.startAngle;
        var categoryField = fields[0];
        var adjustField = fields[2];
        var scale = view.get('scales')[categoryField];
        if (!adjustField) {
            labels.forEach(function (label) {
                var origin = label.get('origin');
                var shapeId = _this.get('element').getShapeId(origin);
                var shape = _this._getShape(shapeId, shapes);
                var angleValue = scale.scale(origin[categoryField]);
                var angle = startAngle + Math.PI * 2 * angleValue;
                var anchor = shape.get('origin');
                var r = distBetweenPoints(center, anchor) + offset;
                var labelAnchor = getEndPoint(center, angle, r);
                label.attr('x', labelAnchor.x);
                label.attr('y', labelAnchor.y);
                label.attr('textBaseline', 'middle');
                _this.adjustTextAlign(label, shape);
                if (adjustColor && type === 'inner') {
                    autoAdjustColor(label, shape);
                }
            });
        }
        view.get('canvas').draw();
    };
    RoseLabels.prototype._getShape = function (shapeId, shapes) {
        var target;
        _.each(shapes, function (shape) {
            var s = shape;
            var id = s.id;
            if (id === shapeId) {
                target = s;
            }
        });
        return target;
    };
    RoseLabels.prototype.adjustTextAlign = function (label, shape) {
        var box = label.getBBox();
        var labelAnchor = { x: box.x + box.width / 2, y: box.y + box.height / 2 };
        var anchor = shape.get('origin');
        var autoRotate = this.get('labelOptions').autoRotate;
        label.attr('textAlign', 'center');
        if (!autoRotate) {
            if (labelAnchor.x > anchor.x) {
                label.attr('textAlign', 'left');
            }
            else if (labelAnchor.x < anchor.x) {
                label.attr('textAlign', 'right');
            }
        }
    };
    return RoseLabels;
}(PolarElementLabels));
export { RoseLabels };
registerElementLabels('roseLabel', RoseLabels);
//# sourceMappingURL=rose-label.js.map