import { __extends } from "tslib";
import { Text } from '@antv/g';
import { ElementLabels, registerElementLabels } from '@antv/g2';
import * as _ from '@antv/util';
import { breakText } from '../../../util/common';
var LEAF_LABEL_OFFSET = 4;
var MIN_FONTSIZE = 8;
function isLeaf(data, maxLevel) {
    return !data.children || data.depth >= maxLevel;
}
function textWrapper(label, width) {
    var fontSize = label.attr('fontSize');
    var textContent = label.attr('text');
    var tShape = new Text({
        attrs: {
            text: '',
            x: 0,
            y: 0,
            fontSize: fontSize,
        },
    });
    var textArr = textContent.split('\n');
    var wrappedTextArr = textArr.map(function (wrappedText) {
        var text = '';
        var chars = wrappedText.split('');
        var breakIndex = [];
        for (var i = 0; i < chars.length; i++) {
            var item = chars[i];
            tShape.attr('text', (text += item));
            var currentWidth = tShape.getBBox().width - 1;
            if (currentWidth > width) {
                // 如果是第一个字符就大于宽度不做任何换行处理
                if (i === 0) {
                    break;
                }
                breakIndex.push(i);
                text = '';
            }
        }
        return breakText(chars, breakIndex);
    });
    tShape.remove();
    return wrappedTextArr.join('\n');
}
function textAbbreviate(text, fontSize, width) {
    var tailShape = new Text({
        attrs: {
            text: '...',
            x: 0,
            y: 0,
            fontSize: fontSize,
        },
    });
    var tailWidth = tailShape.getBBox().width;
    var tShape = new Text({
        attrs: {
            text: '',
            x: 0,
            y: 0,
            fontSize: fontSize,
        },
    });
    var t = '';
    var abbreviateWidth = width - tailWidth;
    for (var i = 0; i < text.length; i++) {
        var item = text[i];
        tShape.attr('text', (t += item));
        var currentWidth = tShape.getBBox().width;
        if (currentWidth >= abbreviateWidth) {
            var string = t.substr(0, t.length - 1);
            if (string.length > 0) {
                return string + '...';
            }
        }
    }
    return t;
}
var TreemapLabels = /** @class */ (function (_super) {
    __extends(TreemapLabels, _super);
    function TreemapLabels() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TreemapLabels.prototype.showLabels = function (points, shapes) {
        var _this = this;
        _super.prototype.showLabels.call(this, points, shapes);
        var renderer = this.get('labelsRenderer');
        var labels = renderer.get('group').get('children');
        var view = this.get('element').get('view');
        var maxLevel = this.get('labelOptions').maxLevel;
        _.each(labels, function (label, index) {
            var l = label;
            var data = label.get('origin');
            var origin = l.get('origin');
            var isLeafNode = isLeaf(data, maxLevel);
            var shapeId = _this.get('element').getShapeId(origin);
            var shape = _this.getShape(shapeId, shapes);
            var shapeBbox = shape.getBBox();
            if (!isLeafNode && data.showLabel) {
                var x = shapeBbox.x + shapeBbox.width / 2;
                var y = shapeBbox.y + 4;
                label.attr('x', x);
                label.attr('y', y);
                label.attr('textBaseline', 'top');
                label.attr('fontWeight', 600);
                var wrapperWidth = shapeBbox.width - LEAF_LABEL_OFFSET * 2;
                if (label.getBBox().width > wrapperWidth) {
                    var text = textAbbreviate(label.attr('text'), label.attr('fontSize'), wrapperWidth);
                    label.attr('text', text);
                }
            }
            else {
                _this.leafText(shapeBbox, label);
            }
        });
        view.get('canvas').draw();
    };
    TreemapLabels.prototype.getShape = function (shapeId, shapes) {
        var target;
        _.each(shapes, function (shape) {
            var s = shape;
            var id = s.id;
            if (id === shapeId) {
                target = s;
            }
        });
        return target;
    };
    TreemapLabels.prototype.leafText = function (bbox, label) {
        var labelBBox = label.getBBox();
        var labelText = _.clone(label.attr('text'));
        var sizeOffset = label.get('origin').depth === 1 ? 0 : 2;
        var fontSize = Math.max(label.attr('fontSize') - sizeOffset, MIN_FONTSIZE);
        var centerX = bbox.x + bbox.width / 2;
        var centerY = bbox.y + bbox.height / 2;
        label.attr({
            x: centerX,
            y: centerY,
            textAlign: 'center',
            textBaseline: 'middle',
            lineHeight: fontSize,
            fontSize: fontSize,
        });
        var wrapperWidth = bbox.width - LEAF_LABEL_OFFSET * 2;
        if (labelBBox.width > bbox.width && labelBBox.height > bbox.height) {
            label.attr('text', '');
            return;
        }
        else if (wrapperWidth < fontSize) {
            label.attr('text', '');
            return;
        }
        if (labelBBox.width > bbox.width) {
            var wrappedText = textWrapper(label, wrapperWidth);
            label.attr({
                lineHeight: label.attr('fontSize'),
                text: wrappedText,
            });
            var tem_bbox = label.getBBox();
            if (tem_bbox.height > bbox.height) {
                var text = textAbbreviate(labelText, fontSize, wrapperWidth);
                label.attr('text', text);
            }
        }
    };
    return TreemapLabels;
}(ElementLabels));
export { TreemapLabels };
registerElementLabels('treemapLabel', TreemapLabels);
//# sourceMappingURL=label.js.map