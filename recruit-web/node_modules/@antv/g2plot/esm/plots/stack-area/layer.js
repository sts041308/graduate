import { __assign, __extends } from "tslib";
import * as _ from '@antv/util';
import { registerPlotType } from '../../base/global';
import { getComponent } from '../../components/factory';
import BaseArea from '../area/layer';
import './component/label/area-label';
import './component/label/line-label';
var StackAreaLayer = /** @class */ (function (_super) {
    __extends(StackAreaLayer, _super);
    function StackAreaLayer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'stackArea';
        return _this;
    }
    StackAreaLayer.getDefaultOptions = function () {
        return _.deepMix({}, _super.getDefaultOptions.call(this), {
            label: {
                visible: false,
                type: 'area',
            },
        });
    };
    StackAreaLayer.prototype.label = function () {
        var props = this.options;
        var label = props.label;
        if (label && label.visible === false) {
            this.area.label = false;
            return;
        }
        var labelType = this.getLabelType(label);
        /** label类型为line，即跟随在折线尾部时，设置offset为0 */
        if (labelType === 'areaLine' || labelType === 'area') {
            label.offset = 0;
        }
        if (labelType === 'area') {
            label.style = _.deepMix({}, label.style, {
                lineWidth: 0,
                stroke: 'rgba(0,0,0,0)',
            });
        }
        this.area.label = getComponent('label', __assign({ fields: [this.getLabelField(labelType, props)], labelType: labelType, plot: this }, label));
    };
    StackAreaLayer.prototype.adjustArea = function (ele) {
        ele.adjust = [
            {
                type: 'stack',
            },
        ];
    };
    StackAreaLayer.prototype.adjustLine = function (ele) {
        ele.adjust = [
            {
                type: 'stack',
            },
        ];
    };
    StackAreaLayer.prototype.adjustPoint = function (ele) {
        ele.adjust = [
            {
                type: 'stack',
            },
        ];
    };
    StackAreaLayer.prototype.getLabelField = function (type, props) {
        var mapper = {
            point: props.yField,
            areaLine: props.stackField,
            area: props.stackField,
        };
        return mapper[type];
    };
    StackAreaLayer.prototype.getLabelType = function (labelProps) {
        if (labelProps.type === 'line') {
            return 'areaLine';
        }
        return labelProps.type;
    };
    return StackAreaLayer;
}(BaseArea));
export default StackAreaLayer;
registerPlotType('stackArea', StackAreaLayer);
//# sourceMappingURL=layer.js.map