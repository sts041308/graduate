import { __assign, __extends } from "tslib";
import { Text } from '@antv/g';
import { ElementLabels, registerElementLabels } from '@antv/g2';
import { each, mix, has, clone } from '@antv/util';
var DEFAULT_SIZE = 12;
var TOLERANCE = 0.01;
var MAX_ITERATION = 100;
var MIN_HEIGHT = 12;
function getRange(points) {
    var maxHeight = -Infinity;
    var min = Infinity;
    var max = -Infinity;
    each(points, function (p) {
        min = Math.min(p.x, min);
        max = Math.max(p.x, max);
        var height = Math.abs(p.y[0] - p.y[1]);
        maxHeight = Math.max(maxHeight, height);
    });
    return {
        xRange: [min, max],
        maxHeight: maxHeight,
    };
}
function interpolateY(x, points, index) {
    var leftPoint = points[0];
    var rightPoint = points[points.length - 1];
    each(points, function (p) {
        if (p.x === x) {
            return p.y[index];
        }
        if (p.x < x && p.x > leftPoint.x) {
            leftPoint = p;
        }
        if (p.x > x && p.x < rightPoint.x) {
            rightPoint = p;
        }
    });
    var t = (x - leftPoint.x) / (rightPoint.x - leftPoint.x);
    return leftPoint.y[index] * (1 - t) + rightPoint.y[index] * t;
}
function getXIndex(data, x) {
    // tslint:disable-next-line: prefer-for-of
    var i;
    for (i = 0; i < data.length; i++) {
        var d = data[i];
        if (d.x === x || d.x > x) {
            break;
        }
    }
    return i;
}
var AreaLabel = /** @class */ (function (_super) {
    __extends(AreaLabel, _super);
    function AreaLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scaleFactor = [];
        return _this;
    }
    AreaLabel.prototype.showLabels = function (points, shapes) {
        var _this = this;
        // 获取堆叠字段
        var plot = this.get('labelOptions').plot;
        var stackField = plot.options.stackField;
        if (stackField) {
            // 根据stackField将point分组
            var groupedPoints = this._groupPoints(points, stackField);
            var labelPoints_1 = [];
            each(groupedPoints, function (pointArray, name) {
                var labelPoint = _this._drawLabel(pointArray, name);
                if (labelPoint) {
                    labelPoints_1.push(mix({}, pointArray[0], labelPoint));
                    _this.scaleFactor.push(labelPoint.scaleFactor);
                }
            });
            _super.prototype.showLabels.call(this, labelPoints_1, shapes);
            var labelOptions = this.get('labelOptions');
            if (labelOptions.autoScale) {
                this._adjuestLabelSize();
            }
        }
        else {
            _super.prototype.showLabels.call(this, points, shapes);
        }
    };
    AreaLabel.prototype._groupPoints = function (points, field) {
        var groupedPoints = {};
        each(points, function (p) {
            var value = p._origin[field];
            if (!has(groupedPoints, value)) {
                groupedPoints[value] = [];
            }
            groupedPoints[value].push(p);
        });
        return groupedPoints;
    };
    AreaLabel.prototype._drawLabel = function (points, name) {
        var _a = getRange(points), xRange = _a.xRange, maxHeight = _a.maxHeight;
        // 根据area宽度在x方向各点间做插值
        var resolution = xRange[1] - xRange[0];
        var interpolatedPoints = this._getInterpolatedPoints(xRange[0], resolution, points);
        // 获取label的bbox
        var bbox = this._getLabelBbox(name);
        var fitOption = {
            xRange: xRange,
            aspect: bbox.width / bbox.height,
            data: interpolatedPoints,
            justTest: true,
        };
        var height = this._bisection(MIN_HEIGHT, maxHeight, this._testFit, fitOption, TOLERANCE, MAX_ITERATION);
        if (height === null) {
            return;
        }
        fitOption.justTest = false;
        var fit = this._testFit(fitOption);
        fit.x = fit.x;
        fit.y = fit.y0 + (fit.y1 - fit.y0) / 2;
        fit.scaleFactor = (height / bbox.height) * 0.4;
        return fit;
    };
    AreaLabel.prototype._getInterpolatedPoints = function (minX, resolution, points) {
        var interpolatedPoints = [];
        var step = 2;
        for (var i = minX; i < resolution; i += step) {
            var y0 = interpolateY(i, points, 0);
            var y1 = interpolateY(i, points, 1);
            interpolatedPoints.push({
                x: i,
                y: [y0, y1],
            });
        }
        return interpolatedPoints;
    };
    AreaLabel.prototype._bisection = function (min, max, test, testOption, tolerance, maxIteration) {
        for (var i = 0; i < maxIteration; i++) {
            var middle = (min + max) / 2;
            var options = testOption;
            options.height = middle;
            options.width = middle * options.aspect;
            var passesTest = test(options);
            var withinTolerance = (max - min) / 2 < tolerance;
            if (passesTest && withinTolerance) {
                return middle;
            }
            if (passesTest) {
                min = middle;
            }
            else {
                max = middle;
            }
        }
        return null;
    };
    AreaLabel.prototype._testFit = function (option) {
        var xRange = option.xRange, width = option.width, height = option.height, data = option.data, justTest = option.justTest;
        for (var i = 0; i < data.length; i++) {
            var d = data[i];
            var x0 = d.x;
            var x1 = x0 + width;
            if (x1 > xRange[1]) {
                break;
            }
            var x1_index = getXIndex(data, x1);
            var ceiling = -Infinity;
            var ceilingFloor = null; // 保存ceiling时对应的bottom位置，ceil和floor不一定是一对坐标
            var floor = Infinity;
            for (var j = i; j < x1_index; j++) {
                var top_1 = data[j].y[1];
                var bottom = data[j].y[0];
                if (bottom < floor) {
                    floor = bottom;
                }
                if (top_1 > ceiling) {
                    ceiling = top_1;
                    ceilingFloor = bottom;
                }
                if (floor - ceiling < height) {
                    break;
                }
            }
            if (floor - ceiling >= height) {
                if (justTest) {
                    return true;
                }
                return {
                    x: x0,
                    y0: ceiling,
                    y1: ceilingFloor,
                    width: width,
                    height: height,
                };
            }
        }
        return false;
    };
    AreaLabel.prototype._getLabelBbox = function (text) {
        var plot = this.get('labelOptions').plot;
        var labelStyle = clone(plot.theme.label.textStyle);
        labelStyle.fontSize = DEFAULT_SIZE;
        var tShape = new Text({
            attrs: __assign({ text: text, x: 0, y: 0 }, labelStyle),
        });
        return tShape.getBBox();
    };
    AreaLabel.prototype._adjuestLabelSize = function () {
        var _this = this;
        var renderer = this.get('labelsRenderer');
        var labels = renderer.get('group').get('children');
        var view = this.get('element').get('view');
        each(labels, function (label, index) {
            var scaleFactor = _this.scaleFactor[index];
            label.attr('fontSize', DEFAULT_SIZE);
            label.transform([
                ['t', -label.attr('x'), -label.attr('y')],
                ['s', scaleFactor, scaleFactor],
                ['t', label.attr('x'), label.attr('y')],
            ]);
        });
        view.get('canvas').draw();
    };
    return AreaLabel;
}(ElementLabels));
registerElementLabels('area', AreaLabel);
//# sourceMappingURL=area-label.js.map