import { getScale } from '@antv/scale';
import * as _ from '@antv/util';
import { getMean, getMedian } from '../util/math';
var GuideLine = /** @class */ (function () {
    function GuideLine(cfg) {
        _.assign(this, cfg);
        this._init();
    }
    GuideLine.prototype._init = function () {
        var props = this.plot.options;
        var defaultStyle = this.getDefaultStyle();
        var baseConfig = {
            type: 'line',
            top: true,
            start: this.cfg.start,
            end: this.cfg.end,
        };
        baseConfig.line = _.deepMix({}, defaultStyle.line, { style: this.cfg.lineStyle });
        baseConfig.text = _.deepMix({}, defaultStyle.text, this.cfg.text);
        if (this.cfg.type) {
            var stateValue = this._getState(this.cfg.type);
            var minValue = this._getState('min');
            var maxValue = this._getState('max');
            var Scale = getScale('linear');
            // 重新组织scale并使用scale的min和max来计算guide point的百分比位置，以避免受nice的影响
            var scale = new Scale(_.mix({}, {
                min: this.plot.type === 'column' ? 0 : minValue,
                max: maxValue,
                nice: true,
                values: this.values,
            }, this.plot.config.scales[props.yField]));
            var percent = (1.0 - scale.scale(stateValue)) * 100 + "%";
            var start = ['0%', percent];
            var end = ['100%', percent];
            this.config = _.mix({
                start: start,
                end: end,
            }, baseConfig);
        }
        else {
            this.config = baseConfig;
        }
    };
    GuideLine.prototype._getState = function (type) {
        this.values = this._extractValues();
        if (type === 'median') {
            return getMedian(this.values);
        }
        if (type === 'mean') {
            return getMean(this.values);
        }
        if (type === 'max') {
            return Math.max.apply(Math, this.values);
        }
        if (type === 'min') {
            return Math.min.apply(Math, this.values);
        }
    };
    GuideLine.prototype._extractValues = function () {
        var props = this.plot.options;
        var field = props.yField;
        var values = [];
        _.each(props.data, function (d) {
            values.push(d[field]);
        });
        return values;
    };
    GuideLine.prototype.getDefaultStyle = function () {
        this.getDefaultTextAlign();
        return {
            line: {
                style: {
                    lineWidth: 2,
                    stroke: '#333333',
                    opacity: 0.7,
                    lineDash: [0, 0],
                },
            },
            text: {
                offsetY: -5,
                style: {
                    fontSize: 14,
                    stroke: 'white',
                    lineWidth: 2,
                    textAlign: this.getDefaultTextAlign(),
                },
            },
        };
    };
    GuideLine.prototype.getDefaultTextAlign = function () {
        var textConfig = this.cfg.text;
        if (textConfig) {
            if (!textConfig.position || textConfig.position === 'start') {
                return 'left';
            }
            if (textConfig.position === 'center') {
                return 'center';
            }
            if (textConfig.position === 'end') {
                return 'right';
            }
        }
    };
    return GuideLine;
}());
export default GuideLine;
//# sourceMappingURL=guide-line.js.map