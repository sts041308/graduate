"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var g2_1 = require("@antv/g2");
var _ = tslib_1.__importStar(require("@antv/util"));
var color_1 = require("../../../util/color");
var MatrixLabels = /** @class */ (function (_super) {
    tslib_1.__extends(MatrixLabels, _super);
    function MatrixLabels() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MatrixLabels.prototype.showLabels = function (points, shapes) {
        var _this = this;
        _super.prototype.showLabels.call(this, points, shapes);
        var renderer = this.get('labelsRenderer');
        var labels = renderer.get('group').get('children');
        var items = renderer.get('items');
        var view = this.get('element').get('view');
        _.each(labels, function (label, index) {
            var l = label;
            var item = items[index];
            var origin = l.get('origin');
            var shapeId = _this.get('element').getShapeId(origin);
            var shape = _this._getShape(shapeId, shapes);
            var _a = _this.get('labelOptions'), adjustColor = _a.adjustColor, adjustPosition = _a.adjustPosition;
            if (adjustColor) {
                _this.adjustColor(l, shape);
            }
            if (adjustPosition) {
                _this.adjustPosition(l, shape);
            }
        });
        view.get('canvas').draw();
    };
    MatrixLabels.prototype._getShape = function (shapeId, shapes) {
        var target;
        _.each(shapes, function (shape) {
            var s = shape;
            var id = s.id;
            if (id === shapeId) {
                target = s;
            }
        });
        return target;
    };
    MatrixLabels.prototype.adjustColor = function (label, shape) {
        var labelRange = label.getBBox();
        var shapeRange = shape.getBBox();
        if (labelRange.minY >= shapeRange.minY && labelRange.maxY <= shapeRange.maxY) {
            var shapeColor = shape.attr('fill');
            var shapeOpacity = shape.attr('opacity') ? shape.attr('opacity') : 1;
            var rgb = color_1.rgb2arr(shapeColor);
            var gray = Math.round(rgb[0] * 0.299 + rgb[1] * 0.587 + rgb[2] * 0.114) / shapeOpacity;
            var colorBand = [
                { from: 0, to: 85, color: 'white' },
                { from: 85, to: 170, color: '#F6F6F6' },
                { from: 170, to: 255, color: 'black' },
            ];
            var reflect = this.mappingColor(colorBand, gray);
            label.attr('fill', reflect);
        }
    };
    MatrixLabels.prototype.mappingColor = function (band, gray) {
        var reflect;
        _.each(band, function (b) {
            var map = b;
            if (gray >= map.from && gray < map.to) {
                reflect = map.color;
            }
        });
        return reflect;
    };
    MatrixLabels.prototype.adjustPosition = function (label, shape) {
        var labelRange = label.getBBox();
        var shapeRange = shape.getBBox();
        if (labelRange.width > shapeRange.width || labelRange.height > shapeRange.height) {
            label.attr('opacity', 0);
            label.attr('fillOpacity', 0);
            label.attr('strokeOpacity', 0);
            label.set('capture', false);
        }
    };
    return MatrixLabels;
}(g2_1.ElementLabels));
exports.MatrixLabels = MatrixLabels;
g2_1.registerElementLabels('matrixLabel', MatrixLabels);
//# sourceMappingURL=label.js.map