"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var g2_1 = require("@antv/g2");
var _ = tslib_1.__importStar(require("@antv/util"));
var utils_1 = require("../../../pie/component/label/utils");
var math_1 = require("../../../../util/math");
var utils_2 = require("./utils");
var PolarElementLabels = g2_1.getElementLabels('polar');
var RoseLabels = /** @class */ (function (_super) {
    tslib_1.__extends(RoseLabels, _super);
    function RoseLabels() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RoseLabels.prototype.showLabels = function (points, shapes) {
        var _this = this;
        _super.prototype.showLabels.call(this, points, shapes);
        var renderer = this.get('labelsRenderer');
        var labels = renderer.get('group').get('children');
        var view = this.get('element').get('view');
        var _a = this.get('labelOptions'), fields = _a.fields, offset = _a.offset, adjustColor = _a.adjustColor, type = _a.type;
        var _b = view.get('coord'), center = _b.center, startAngle = _b.startAngle;
        var categoryField = fields[0];
        var adjustField = fields[2];
        var scale = view.get('scales')[categoryField];
        if (!adjustField) {
            labels.forEach(function (label) {
                var origin = label.get('origin');
                var shapeId = _this.get('element').getShapeId(origin);
                var shape = _this._getShape(shapeId, shapes);
                var angleValue = scale.scale(origin[categoryField]);
                var angle = startAngle + Math.PI * 2 * angleValue;
                var anchor = shape.get('origin');
                var r = math_1.distBetweenPoints(center, anchor) + offset;
                var labelAnchor = utils_1.getEndPoint(center, angle, r);
                label.attr('x', labelAnchor.x);
                label.attr('y', labelAnchor.y);
                label.attr('textBaseline', 'middle');
                _this.adjustTextAlign(label, shape);
                if (adjustColor && type === 'inner') {
                    utils_2.autoAdjustColor(label, shape);
                }
            });
        }
        view.get('canvas').draw();
    };
    RoseLabels.prototype._getShape = function (shapeId, shapes) {
        var target;
        _.each(shapes, function (shape) {
            var s = shape;
            var id = s.id;
            if (id === shapeId) {
                target = s;
            }
        });
        return target;
    };
    RoseLabels.prototype.adjustTextAlign = function (label, shape) {
        var box = label.getBBox();
        var labelAnchor = { x: box.x + box.width / 2, y: box.y + box.height / 2 };
        var anchor = shape.get('origin');
        var autoRotate = this.get('labelOptions').autoRotate;
        label.attr('textAlign', 'center');
        if (!autoRotate) {
            if (labelAnchor.x > anchor.x) {
                label.attr('textAlign', 'left');
            }
            else if (labelAnchor.x < anchor.x) {
                label.attr('textAlign', 'right');
            }
        }
    };
    return RoseLabels;
}(PolarElementLabels));
exports.RoseLabels = RoseLabels;
g2_1.registerElementLabels('roseLabel', RoseLabels);
//# sourceMappingURL=rose-label.js.map