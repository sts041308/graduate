"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = tslib_1.__importStar(require("@antv/util"));
var shape_nodes_1 = tslib_1.__importDefault(require("../node/shape-nodes"));
var responsive_1 = tslib_1.__importDefault(require("../responsive"));
var base_1 = tslib_1.__importDefault(require("./base"));
var SCALE_MAPPER = {
    cat: 'category',
    timeCat: 'category',
    time: 'dateTime',
    linear: 'linear',
};
function updateTicks(nodes, axis) {
    var tickShape = null;
    axis
        .get('group')
        .get('children')
        .forEach(function (shape) {
        if (shape.name === 'axis-ticks') {
            tickShape = shape;
            return false;
        }
    });
    var ticks = axis.get('ticks');
    var tickItems = axis.get('tickItems');
    var tickTexts = [];
    _.each(ticks, function (tick) {
        var t = tick;
        tickTexts.push(t.text);
    });
    var pathes = [];
    _.each(nodes.nodes, function (node) {
        var n = node;
        if (n.width > 0 && n.height > 0) {
            var text = n.shape.get('origin').text;
            var index = tickTexts.indexOf(text);
            var tickItem = tickItems[index];
            pathes.push(['M', tickItem.x1, tickItem.y1], ['L', tickItem.x2, tickItem.y2]);
        }
    });
    if (pathes.length === 0) {
        pathes = [['M', 0, 0]];
    }
    tickShape.attr('path', pathes);
}
var ApplyResponsiveAxis = /** @class */ (function (_super) {
    tslib_1.__extends(ApplyResponsiveAxis, _super);
    function ApplyResponsiveAxis() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ApplyResponsiveAxis.prototype.init = function () {
        this.axisInstance = this.getAxisInstance();
        _super.prototype.init.call(this);
    };
    ApplyResponsiveAxis.prototype.shouldApply = function () {
        if (!this.responsiveTheme.axis) {
            return false;
        }
        if (this.responsiveTheme.axis[this.dim] &&
            this.type &&
            this.axisInstance &&
            this.axisInstance.get('labelRenderer')) {
            return true;
        }
        return false;
    };
    ApplyResponsiveAxis.prototype.apply = function () {
        var axis = this.axisInstance;
        var rawLabels = axis
            .get('labelRenderer')
            .get('group')
            .get('children');
        var shapes = [];
        for (var i = 0; i < rawLabels.length - 1; i++) {
            shapes.push(rawLabels[i]);
        }
        var shapeNodes = new shape_nodes_1.default({
            shapes: shapes,
        });
        var _a = this.responsiveTheme.axis.x[this.type], constraints = _a.constraints, rules = _a.rules;
        new responsive_1.default({
            nodes: shapeNodes,
            constraints: constraints,
            region: this.plot.view.get('viewRange'),
            rules: rules,
            plot: this.plot,
            onEnd: function (nodes) {
                if (axis.get('tickLine')) {
                    updateTicks(nodes, axis);
                }
            },
        });
    };
    ApplyResponsiveAxis.prototype.getType = function () {
        var props = this.plot.options;
        var axis = this.dim + "Axis";
        var field = this.dim + "Field";
        if (props[axis] && props[axis].type && props[axis].type === 'dateTime') {
            return 'dateTime';
        }
        var scaleType = this.plot.view.get('scales')[props[field]].type;
        return SCALE_MAPPER[scaleType];
    };
    ApplyResponsiveAxis.prototype.getAxisInstance = function () {
        var axisIndex = this.dim === 'x' ? 0 : 1;
        var axis = this.plot.view.get('axisController').axes[axisIndex];
        return axis;
    };
    return ApplyResponsiveAxis;
}(base_1.default));
exports.default = ApplyResponsiveAxis;
//# sourceMappingURL=axis.js.map