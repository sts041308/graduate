"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/** 简化折线点 */
var G2 = tslib_1.__importStar(require("@antv/g2"));
var _ = tslib_1.__importStar(require("@antv/util"));
var math_1 = require("../../util/math");
var path_1 = require("../../util/path");
var main_1 = tslib_1.__importDefault(require("./main"));
var G2DefaultTheme = G2.Global.theme;
G2.registerShape('line', 'miniLine', {
    draw: function (cfg, container) {
        var points = math_1.lineSimplification(cfg.points);
        var path = [];
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            var flag = i === 0 ? 'M' : 'L';
            path.push([flag, p.x, p.y]);
        }
        var style = _.deepMix({}, {
            lineJoin: 'round',
            lineCap: 'round',
        }, cfg.style);
        var shape = container.addShape('path', {
            attrs: _.mix({
                path: path,
                stroke: cfg.color || G2DefaultTheme.defaultColor,
                lineWidth: cfg.size || 2,
            }, style),
        });
        return shape;
    },
});
G2.registerShape('line', 'miniLineSmooth', {
    draw: function (cfg, container) {
        var points = math_1.lineSimplification(cfg.points);
        var constraint = [
            [0, 0],
            [1, 1],
        ];
        var path = path_1.getSplinePath(points, false, constraint);
        var shape = container.addShape('path', {
            attrs: _.mix({
                path: path,
                stroke: cfg.color || G2DefaultTheme.defaultColor,
                lineWidth: cfg.size || 2,
            }, cfg.style),
        });
        return shape;
    },
});
var MiniLineParser = /** @class */ (function (_super) {
    tslib_1.__extends(MiniLineParser, _super);
    function MiniLineParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MiniLineParser.prototype.init = function () {
        _super.prototype.init.call(this);
        this.parseShape();
    };
    MiniLineParser.prototype.parseShape = function () {
        var props = this.plot.options;
        if (props.smooth) {
            this.config.shape = { values: ['miniLineSmooth'] };
        }
        else {
            this.config.shape = { values: ['miniLine'] };
        }
    };
    return MiniLineParser;
}(main_1.default));
exports.default = MiniLineParser;
//# sourceMappingURL=mini.js.map