"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var domUtil = require("@antv/dom-util");
var Util = require("@antv/util");
var base_1 = require("./base");
var crosshair_1 = require("./crosshair");
var theme_1 = require("./theme");
var position_1 = require("./util/position");
var CONTAINER_CLASS = 'g2-tooltip';
var TITLE_CLASS = 'g2-tooltip-title';
var LIST_CLASS = 'g2-tooltip-list';
var MARKER_CLASS = 'g2-tooltip-marker';
var VALUE_CLASS = 'g2-tooltip-value';
var LIST_ITEM_CLASS = 'g2-tooltip-list-item';
var find = function (dom, cls) {
    return dom.getElementsByClassName(cls)[0];
};
var mergeStyles = function (styles, cfg) {
    // todo
    Object.keys(styles).forEach(function (k) {
        if (cfg[k]) {
            styles[k] = Util.mix(styles[k], cfg[k]);
        }
    });
    return styles;
};
var HtmlTooltip = /** @class */ (function (_super) {
    tslib_1.__extends(HtmlTooltip, _super);
    function HtmlTooltip(cfg) {
        var _this = _super.call(this, tslib_1.__assign({ 
            /**
             * tooltip 容器模板
             * @type {String}
             */
            containerTpl: "<div class=\"" + CONTAINER_CLASS + "\">\n        <div class=\"" + TITLE_CLASS + "\"></div>\n        <ul class=\"" + LIST_CLASS + "\"></ul>\n        </div>", 
            /**
             * tooltip 列表项模板
             * @type {String}
             */
            itemTpl: "<li data-index={index}>\n        <span style=\"background-color:{color};\" class=\"" + MARKER_CLASS + "\"></span>\n        {name}<span class=\"" + VALUE_CLASS + "\">{value}</span></li>", 
            /**
             * tooltip html内容
             * @type {String}
             */
            htmlContent: null, 
            /**
             * tooltip 内容跟随鼠标移动
             * @type {Boolean}
             */
            follow: true, 
            /**
             * 是否允许鼠标停留在 tooltip 上，默认不允许
             * @type {Boolean}
             */
            enterable: false }, cfg)) || this;
        var style = theme_1.default;
        _this.style = mergeStyles(style, cfg);
        _this._init_();
        if (_this.get('items')) {
            _this.render();
        }
        // crosshair
        var crosshair = _this.get('crosshairs');
        if (crosshair) {
            var plot = crosshair.type === 'rect' ? _this.get('backgroundGroup') : _this.get('frontgroundGroup');
            var crosshairGroup = new crosshair_1.default(Util.mix({
                plot: plot,
                panelRange: _this.get('panelRange'),
                canvas: _this.get('canvas'),
            }, _this.get('crosshairs')));
            crosshairGroup.hide();
            _this.set('crosshairGroup', crosshairGroup);
        }
        return _this;
    }
    HtmlTooltip.prototype._init_ = function () {
        var containerTpl = this.get('containerTpl');
        var outterNode = this.get('canvas').get('el').parentNode;
        var container;
        if (!this.get('htmlContent')) {
            if (/^\#/.test(containerTpl)) {
                // 如果传入 dom 节点的 id
                var id = containerTpl.replace('#', '');
                container = document.getElementById(id);
            }
            else {
                container = domUtil.createDom(containerTpl);
            }
        }
        else {
            container = this._getHtmlContent();
        }
        this.set('container', container);
        domUtil.modifyCSS(container, this.style[CONTAINER_CLASS]);
        outterNode.appendChild(container);
        outterNode.style.position = 'relative';
    };
    HtmlTooltip.prototype.render = function () {
        this.clear();
        if (this.get('htmlContent')) {
            var outterNode = this.get('canvas').get('el').parentNode;
            var container = this._getHtmlContent();
            outterNode.appendChild(container);
            domUtil.modifyCSS(container, this.style[CONTAINER_CLASS]);
            this.set('container', container);
        }
        else {
            this._renderTpl();
        }
    };
    HtmlTooltip.prototype._renderTpl = function () {
        var _this = this;
        var showTitle = this.get('showTitle');
        var titleContent = this.get('titleContent');
        var container = this.get('container');
        var titleDom = find(container, TITLE_CLASS);
        var listDom = find(container, LIST_CLASS);
        var items = this.get('items');
        if (titleDom && showTitle) {
            domUtil.modifyCSS(titleDom, this.style[TITLE_CLASS]);
            titleDom.innerHTML = titleContent;
        }
        if (listDom) {
            domUtil.modifyCSS(listDom, this.style[LIST_CLASS]);
            Util.each(items, function (item, index) {
                listDom.appendChild(_this._addItem(item, index));
            });
        }
    };
    HtmlTooltip.prototype.clear = function () {
        var container = this.get('container');
        if (container && this.get('htmlContent')) {
            container.remove();
        }
        else {
            var titleDom = find(container, TITLE_CLASS);
            var listDom = find(container, LIST_CLASS);
            if (titleDom) {
                titleDom.innerHTML = '';
            }
            if (listDom) {
                listDom.innerHTML = '';
            }
        }
    };
    HtmlTooltip.prototype.show = function () {
        var container = this.get('container');
        container.style.visibility = 'visible';
        container.style.display = 'block';
        var crosshairGroup = this.get('crosshairGroup');
        if (crosshairGroup) {
            crosshairGroup.show();
        }
        var markerGroup = this.get('markerGroup');
        if (markerGroup) {
            markerGroup.show();
        }
        _super.prototype.show.call(this);
        this.get('canvas').draw();
    };
    HtmlTooltip.prototype.hide = function () {
        var container = this.get('container');
        container.style.visibility = 'hidden';
        container.style.display = 'none';
        var crosshairGroup = this.get('crosshairGroup');
        if (crosshairGroup) {
            crosshairGroup.hide();
        }
        var markerGroup = this.get('markerGroup');
        if (markerGroup) {
            markerGroup.hide();
        }
        _super.prototype.hide.call(this);
        this.get('canvas').draw();
    };
    HtmlTooltip.prototype.destroy = function () {
        var container = this.get('container');
        var containerTpl = this.get('containerTpl');
        if (container && !/^\#/.test(containerTpl)) {
            container.parentNode.removeChild(container);
        }
        var crosshairGroup = this.get('crosshairGroup');
        if (crosshairGroup) {
            crosshairGroup.destroy();
        }
        var markerGroup = this.get('markerGroup');
        if (markerGroup) {
            markerGroup.remove();
        }
        _super.prototype.destroy.call(this);
    };
    HtmlTooltip.prototype._addItem = function (item, index) {
        var itemTpl = this.get('itemTpl'); // TODO: 有可能是个回调函数
        var itemDiv = Util.substitute(itemTpl, Util.mix(
        // @ts-ignore
        {
            // @ts-ignore
            index: index,
        }, item));
        var itemDOM = domUtil.createDom(itemDiv);
        domUtil.modifyCSS(itemDOM, this.style[LIST_ITEM_CLASS]);
        var markerDom = find(itemDOM, MARKER_CLASS);
        if (markerDom) {
            domUtil.modifyCSS(markerDom, this.style[MARKER_CLASS]);
        }
        var valueDom = find(itemDOM, VALUE_CLASS);
        if (valueDom) {
            domUtil.modifyCSS(valueDom, this.style[VALUE_CLASS]);
        }
        return itemDOM;
    };
    HtmlTooltip.prototype._getHtmlContent = function () {
        var htmlContent = this.get('htmlContent');
        var title = this.get('titleContent');
        var items = this.get('items');
        var html = htmlContent(title, items);
        var ele;
        if (Util.isElement(html)) {
            ele = html;
        }
        else {
            ele = domUtil.createDom(html);
        }
        return ele;
    };
    HtmlTooltip.prototype.setPosition = function (oldx, oldy, target) {
        // todo any 是 Shape
        var x = oldx;
        var y = oldy;
        var container = this.get('container');
        var outterNode = this.get('canvas').get('el');
        var viewWidth = domUtil.getWidth(outterNode);
        var viewHeight = domUtil.getHeight(outterNode);
        var containerWidth = container.clientWidth;
        var containerHeight = container.clientHeight;
        var endx = x;
        var endy = y;
        var position;
        var prePosition = this.get('prePosition') || { x: 0, y: 0 };
        // @2019-01-30 by blue.lb 由于display:none的元素获取clientWidth和clientHeight的值为0，这里强制显隐一下，其实直接在show和hide中去掉display设置最好，猜测为了更好的兼容浏览器
        if (!containerWidth) {
            container.style.display = 'block';
            containerWidth = container.clientWidth;
            containerHeight = container.clientHeight;
            container.style.display = 'none';
        }
        if (this.get('enterable')) {
            y = y - container.clientHeight / 2;
            position = [x, y];
            if (prePosition && x - prePosition.x > 0) {
                // 留 1px 防止鼠标点击事件无法在画布上触发
                x -= container.clientWidth + 1;
            }
            else {
                x += 1;
            }
        }
        else if (this.get('position')) {
            position = position_1.defaultPosition(x, y, this.get('position'), containerWidth, containerHeight, target);
            x = position[0];
            y = position[1];
        }
        else {
            position = position_1.constraintPositionInBoundary(x, y, containerWidth, containerHeight, viewWidth, viewHeight);
            x = position[0];
            y = position[1];
        }
        if (this.get('inPanel')) {
            // tooltip 必须限制在绘图区域内
            var panelRange = this.get('panelRange');
            var panelGroup = this.get('panelGroup');
            var panelClip = panelGroup.attr('clip');
            position = position_1.constraintPositionInPanel(x, y, containerWidth, containerHeight, panelClip ? panelClip.getBBox() : panelRange, this.get('enterable'));
            x = position[0];
            y = position[1];
        }
        var markerItems = this.get('markerItems');
        if (!Util.isEmpty(markerItems)) {
            endx = markerItems[0].x;
            endy = markerItems[0].y;
        }
        this.set('prePosition', position); // 记录上次的位置
        var follow = this.get('follow');
        if (follow) {
            container.style.left = x + "px";
            container.style.top = y + "px";
        }
        var crosshairGroup = this.get('crosshairGroup');
        if (crosshairGroup) {
            var items = this.get('items');
            crosshairGroup.setPosition(endx, endy, items);
        }
        _super.prototype.setPosition.call(this, x, y);
    };
    return HtmlTooltip;
}(base_1.default));
exports.default = HtmlTooltip;
//# sourceMappingURL=html.js.map