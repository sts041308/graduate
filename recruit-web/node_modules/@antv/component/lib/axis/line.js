"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var matrix_util_1 = require("@antv/matrix-util");
var Util = require("@antv/util");
var base_1 = require("./base");
var AUTO_ROTATE_DEGREES = [0, -45, -90];
var Line = /** @class */ (function (_super) {
    tslib_1.__extends(Line, _super);
    function Line(cfg) {
        if (cfg === void 0) { cfg = {}; }
        return _super.call(this, tslib_1.__assign({ type: 'line', x: null, y: null, isVertical: false, start: null, end: null }, cfg)) || this;
    }
    /**
     * 获取距离坐标轴的向量
     * @override
     * @param  {Number} offset 偏移值
     * @return {Array}        返回二维向量
     */
    Line.prototype.getSideVector = function (offset) {
        var isVertical = this.get('isVertical');
        var factor = this.get('factor');
        // if (Util.isArray(offset)) {
        //   return offset.map(value => value * factor);
        // }
        if (!Util.isNumber(offset)) {
            return [0, 0];
        }
        var start = this.get('start');
        var end = this.get('end');
        var axisVector = this.getAxisVector();
        var normal = matrix_util_1.vec2.normalize([], axisVector);
        var direction = false;
        if ((isVertical && start.y < end.y) || (!isVertical && start.x > end.x)) {
            direction = true;
        }
        var verticalVector = matrix_util_1.vec2.vertical([], normal, direction);
        return matrix_util_1.vec2.scale([], verticalVector, offset * factor);
    };
    Line.prototype.getAxisVector = function () {
        var start = this.get('start');
        var end = this.get('end');
        return [end.x - start.x, end.y - start.y];
    };
    Line.prototype.getLinePath = function () {
        var start = this.get('start');
        var end = this.get('end');
        return [
            ['M', start.x, start.y],
            ['L', end.x, end.y],
        ];
    };
    Line.prototype.getTickEnd = function (start, value) {
        var offsetVector = this.getSideVector(value);
        return {
            x: start.x + offsetVector[0],
            y: start.y + offsetVector[1],
        };
    };
    Line.prototype.getTickPoint = function (tickValue) {
        var start = this.get('start');
        var end = this.get('end');
        var rangeX = end.x - start.x;
        var rangeY = end.y - start.y;
        return {
            x: start.x + rangeX * tickValue,
            y: start.y + rangeY * tickValue,
        };
    };
    Line.prototype.renderTitle = function () {
        var title = this.get('title');
        var label = this.get('label');
        var rotate = Util.get(label, 'rotate');
        var autoRotateTitle = this.get('autoRotateTitle');
        var offsetPoint = this.getTickPoint(0.5);
        var titleOffset = title.offset ? title.offset : 20;
        // if (Util.isNil(titleOffset)) { // 没有指定 offset 则自动计算
        var labelRenderer = this.get('labelRenderer');
        if (labelRenderer) {
            var position = this.get('position');
            var property = position === 'bottom' || position === 'top' ? 'height' : 'width';
            var labelLength = this.getMaxLabelWidthOrHeight(labelRenderer, property);
            if (this.get('autoRotateLabel')) {
                var angle = this.getAutoRotateAngle();
                if (angle) {
                    labelLength = this.getOffsetByRotateAngle(angle);
                }
            }
            if (rotate) {
                labelLength = this.getOffsetByRotateAngle((rotate * Math.PI) / 180);
            }
            var labelOffset = Util.get(this.get('label'), 'offset', 5);
            titleOffset += labelLength + labelOffset;
        }
        // }
        var textStyle = title.textStyle;
        var cfg = Util.mix({}, textStyle);
        if (title.text) {
            var vector = this.getAxisVector(); // 坐标轴方向的向量
            if (autoRotateTitle && Util.isNil(title.rotate)) {
                // 自动旋转并且用户没有设置 title.rotate
                var angle = 0;
                if (!Util.isNumberEqual(vector[1], 0)) {
                    // 所有水平坐标轴，文本不转置
                    var v1 = [1, 0];
                    var v2 = [vector[0], vector[1]];
                    angle = matrix_util_1.vec2.angleTo(v2, v1, true);
                }
                cfg.rotate = angle * (180 / Math.PI);
            }
            else if (!Util.isNil(title.rotate)) {
                // 用户设置了旋转角度就以用户设置的为准
                cfg.rotate = (title.rotate / 180) * Math.PI; // 将角度转换为弧度
            }
            var sideVector = this.getSideVector(titleOffset);
            var point = void 0;
            var position = title.position;
            if (position === 'start') {
                point = {
                    x: this.get('start').x + sideVector[0],
                    y: this.get('start').y + sideVector[1],
                };
            }
            else if (position === 'end') {
                point = {
                    x: this.get('end').x + sideVector[0],
                    y: this.get('end').y + sideVector[1],
                };
            }
            else {
                point = {
                    x: offsetPoint.x + sideVector[0],
                    y: offsetPoint.y + sideVector[1],
                };
            }
            cfg.x = point.x;
            cfg.y = point.y;
            cfg.text = title.text;
            var group = this.get('group');
            var titleShape = group.addShape('Text', {
                zIndex: 2,
                attrs: cfg,
            });
            titleShape.name = 'axis-title';
            this.get('appendInfo') && titleShape.setSilent('appendInfo', this.get('appendInfo'));
        }
    };
    Line.prototype.autoRotateLabels = function () {
        var labelRenderer = this.get('labelRenderer');
        if (labelRenderer) {
            var labels = labelRenderer.getLabels();
            var vector = this.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景
            var angle_1 = this.getAutoRotateAngle();
            if (angle_1) {
                this.set('autoRotateAngle', angle_1);
                var offsetY_1 = -6 * Math.abs(Math.sin(angle_1));
                // const offsetY = (this.getMaxLabelWidthOrHeight(labelRenderer, 'width') * Math.abs(Math.sin(angle))) / 2;
                var textAlign_1 = angle_1 % Math.PI === 0
                    ? 'center'
                    : angle_1 > 0
                        ? angle_1 % (Math.PI * 2) < Math.PI
                            ? 'left'
                            : 'right'
                        : angle_1 % (Math.PI * 2) > -Math.PI
                            ? 'right'
                            : 'left';
                Util.each(labels, function (label) {
                    label.attr('textAlign', textAlign_1);
                    label.rotateAtStart(angle_1);
                    label.attr('y', label.attr('y') + offsetY_1);
                });
            }
        }
    };
    Line.prototype.autoHideLabels = function () {
        var labelRenderer = this.get('labelRenderer');
        var labelSpace;
        var tickStep;
        var append = 8;
        if (labelRenderer) {
            var ticks = this.get('tickItems');
            var labels_1 = labelRenderer.getLabels();
            var vector = this.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景
            if (labels_1.length < 2) {
                return;
            }
            if (Util.isNumberEqual(vector[0], 0)) {
                // 坐标轴垂直
                var maxHeight = this.getMaxLabelWidthOrHeight(labelRenderer, 'height') + append;
                var avgHeight = Math.abs(this._getAvgLabelHeightSpace(labelRenderer));
                if (maxHeight > avgHeight) {
                    labelSpace = maxHeight;
                    tickStep = avgHeight;
                }
            }
            else if (Util.isNumberEqual(vector[1], 0) && labels_1.length > 1) {
                // 坐标轴水平
                var maxWidth = this.getMaxLabelWidthOrHeight(labelRenderer, 'width') + append;
                var avgWidth = Math.abs(this._getAvgLabelLength(labelRenderer));
                if (maxWidth > avgWidth) {
                    labelSpace = maxWidth;
                    tickStep = avgWidth;
                }
            }
            if (labelSpace && tickStep) {
                var ratio_1 = Math.ceil(labelSpace / tickStep);
                Util.each(labels_1, function (label, i) {
                    if (i % ratio_1 !== 0) {
                        label.set('visible', false);
                        label.attr('text', '');
                    }
                });
                if (ticks) {
                    var visibleTicks = Util.filter(ticks, function (tick, idx) { return labels_1[idx].get('visible'); });
                    if (Util.size(visibleTicks) > 0) {
                        this.set('tickItems', visibleTicks);
                        Util.remove(this.get('group').get('children'), function (s) { return s.name === 'axis-ticks'; });
                        this._renderTicks();
                    }
                }
            }
        }
    };
    Line.prototype.getAutoRotateAngleByAvgWidth = function (avgWidth) {
        var autoRotate = this.get('autoRotateLabel');
        var labelRenderer = this.get('labelRenderer');
        var title = this.get('title');
        var angle;
        if (labelRenderer) {
            var labels = labelRenderer.getLabels();
            var offset = this.get('label').offset;
            var append = 12;
            var titleOffset = title && title.offset ? title.offset : 20;
            if (titleOffset < 0) {
                // 如果是负的的话就不旋转
                return;
            }
            var vector = this.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景
            var maxWidth = void 0;
            var maxHeight = void 0;
            if (Util.isNumberEqual(vector[0], 0) && title && title.text) {
                // 坐标轴垂直，由于不知道边距，只能防止跟title重合，如果title不存在，则不自动旋转
                maxWidth = this.getMaxLabelWidthOrHeight(labelRenderer, 'width');
                if (maxWidth > titleOffset - offset - append) {
                    angle = Math.acos((titleOffset - offset - append) / maxWidth) * -1;
                }
            }
            else if (Util.isNumberEqual(vector[1], 0) && labels.length > 1) {
                // 坐标轴水平，不考虑边距，根据最长的和平均值进行翻转
                maxWidth = this.getMaxLabelWidthOrHeight(labelRenderer, 'width');
                maxHeight = this.getMaxLabelWidthOrHeight(labelRenderer, 'height');
                if (maxWidth > avgWidth) {
                    var degrees = Util.isArray(autoRotate) ? autoRotate : AUTO_ROTATE_DEGREES;
                    for (var _i = 0, degrees_1 = degrees; _i < degrees_1.length; _i++) {
                        var degree = degrees_1[_i];
                        angle = (degree * Math.PI) / 180;
                        if (avgWidth * Math.abs(Math.sin(angle)) > maxHeight + 4) {
                            break;
                        }
                    }
                }
            }
        }
        return angle;
    };
    Line.prototype.getOffsetByRotateAngle = function (angle) {
        var labelRenderer = this.get('labelRenderer');
        var position = this.get('position');
        var property = position === 'bottom' || position === 'top' ? 'height' : 'width';
        var labelLength = this.getMaxLabelWidthOrHeight(labelRenderer, property);
        return angle
            ? Math.max(labelLength, this.getMaxLabelWidthOrHeight(labelRenderer, 'width') * Math.abs(Math.sin(angle)))
            : labelLength;
    };
    Line.prototype._getAvgLabelLength = function (labelRenderer) {
        var labels = labelRenderer.getLabels();
        return labels[1].attr('x') - labels[0].attr('x');
    };
    Line.prototype._getAvgLabelHeightSpace = function (labelRenderer) {
        var labels = labelRenderer.getLabels();
        return labels[1].attr('y') - labels[0].attr('y');
    };
    Line.prototype.getAutoRotateAngle = function () {
        var labelRenderer = this.get('labelRenderer');
        var labels = labelRenderer.getLabels();
        if (!labels || labels.length < 2) {
            return;
        }
        var avgWidth = Math.abs(this._getAvgLabelLength(labelRenderer));
        return this.getAutoRotateAngleByAvgWidth(avgWidth);
    };
    return Line;
}(base_1.default));
exports.default = Line;
//# sourceMappingURL=line.js.map