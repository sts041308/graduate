import { Coordinate } from '@antv/coord';
import { Group } from '@antv/g';
declare type Func = (...args: any[]) => any;
export interface CommonCfg {
    [k: string]: any;
}
export interface GuideCfg {
    id?: string | null;
    readonly canvas?: any;
    readonly container?: Group | string | HTMLDivElement | null;
    readonly group?: any;
    readonly capture?: boolean;
    readonly panelRange?: any;
    readonly offsetX?: number;
    readonly offsetY?: number;
    readonly position?: [number, number];
    readonly visible?: boolean;
    readonly zIndex?: number;
    [key: string]: any;
}
export interface Attrs {
    visible?: boolean;
    [key: string]: any;
}
export interface LabelType {
    readonly tagName?: string;
    readonly innerHTML?: string;
    readonly id?: string;
    readonly attr: Func;
    readonly resetMatrix?: Func;
    readonly textStyle?: {
        [key: string]: any;
    };
    readonly getBBox: Func;
    readonly remove: Func;
}
export interface ShapeType {
    readonly getBBox: Func;
}
export interface TextType {
    readonly x: number;
    readonly y: number;
    readonly text: string;
    readonly angle?: number;
    readonly fontSize?: number;
    readonly fontFamily?: string;
    readonly fontStyle?: string;
    readonly fontWeight?: string | number;
    readonly fontVariant?: string;
    readonly textAlign?: string;
    readonly textBaseline?: string;
    readonly lineHeight?: number;
    readonly textArr?: string;
}
export interface LabelItem extends TextType {
    id: string;
}
export interface PointType {
    x: number;
    y: number;
}
export interface GroupType {
    readonly getBBox: Func;
    readonly move: Func;
    readonly setSilent: Func;
    readonly findBy: Func;
    readonly get: Func;
    readonly set: Func;
}
export interface LegendItem {
    value: string;
    checked: boolean;
    marker: any;
}
export interface EventType {
    x: number;
    y: number;
    clientX: any;
    clientY: any;
    cfg: {
        [key: string]: any;
    };
    type: string;
    target: any;
    currentTarget: any;
    bubbles: boolean;
    cancelable: boolean;
    timeStamp: number;
    defaultPrevented: boolean;
    propagationStopped: boolean;
    event: any;
    [key: string]: any;
}
export interface LegendCfg extends GuideCfg {
    readonly type: string;
    readonly title?: string;
    readonly x?: number;
    readonly y?: number;
    readonly items?: CommonCfg[];
    readonly formatter?: Func;
}
export interface CategoryLegendCfg extends LegendCfg {
    layout?: 'horizontal' | 'vertical';
    reversed?: boolean;
    clickable?: boolean;
    hoverable?: boolean;
    selectedMode?: 'single' | 'multiple';
    allowAllCanceled?: boolean;
    titleStyle?: CommonCfg;
    unSelectedColor?: string;
    backgroudStyle?: CommonCfg;
    offsetX?: number;
    offsetY?: number;
}
export interface CanvasCategoryLegendCfg extends CategoryLegendCfg {
    readonly textStyle: CommonCfg;
    readonly titleDistance: number;
    readonly itemDistance?: number;
    readonly autoWrap: boolean;
    readonly itemWidth: number;
    readonly wordSpacing: number;
    readonly itemMarginBottom: number;
    readonly backgroundPadding: number | number[];
    readonly maxLength: number;
    maxWidth?: number;
    maxHeight?: number;
}
export interface HTMLCategoryLegendCfg extends CategoryLegendCfg {
    readonly container?: HTMLDivElement | string;
    readonly maxWidth: number;
    readonly maxHeight: number;
    readonly containerTpl?: string;
    readonly itemTpl?: string | Func;
    readonly pagination: CommonCfg | false;
    readonly prefixClassName?: string;
    readonly itemStyle?: CommonCfg;
    readonly markerStyle?: CommonCfg;
    readonly listStyle?: CommonCfg;
    readonly highlight?: boolean;
}
export interface ContinuousLegendCfg extends LegendCfg {
    readonly items: any[];
    readonly textStyle: object;
    readonly width: number;
    readonly height: number;
    readonly handleIcon: any;
    readonly handleSize: [number, number];
    readonly handleStyle: object;
    readonly backgroundStyle: object;
    readonly fillStyle: object;
    readonly operational: boolean;
}
export interface ContinuousItem {
    readonly value: string | number;
    readonly color?: string;
}
export interface SizeContinuousLegendCfg extends ContinuousLegendCfg {
    readonly items: ContinuousItem[];
}
export interface ColorItemType extends ContinuousItem {
    percentage?: number;
}
export interface ColorContinuousLegendCfg extends ContinuousLegendCfg {
    readonly items: ColorItemType[];
    readonly isSegment: boolean;
}
interface Tick {
    text: string;
    value: number;
    tickValue: string | number;
}
interface TickLine {
    length?: number;
    [key: string]: any;
}
declare type gridCallback = (text: string, index: number, total: number) => CommonCfg | null;
interface AxisLabelOption {
    offset?: number;
    offsetX?: number;
    offsetY?: number;
    rotate?: number;
    textStyle?: CommonCfg;
    text?: string;
    useHtml?: boolean;
    htmlTemplate?: string;
}
declare type labelCallback = (text: string, index: number, total: number) => AxisLabelOption | null;
interface AxisTitleOption {
    offset?: number;
    textStyle?: CommonCfg;
    position?: 'start' | 'center' | 'end';
}
export interface GridPoint {
    x: number;
    y: number;
    flag?: number;
    radius?: number;
}
export interface GridPoints {
    id: string;
    points: GridPoint[];
}
export interface AxisCfg extends GuideCfg {
    type: string;
    ticks: Tick[];
    line?: CommonCfg;
    tickLine?: TickLine;
    subTickCount?: number;
    subTickLine?: TickLine;
    grid?: CommonCfg | gridCallback | null;
    label?: AxisLabelOption | labelCallback | null;
    title?: AxisTitleOption;
    autoRotateLabel?: boolean;
    autoHideLabel?: boolean;
    autoRotateTitle?: boolean;
    gridType?: 'line' | 'arc';
    gridAlign?: 'center';
    gridAlternateColor?: string | [string, string];
    theme?: CommonCfg;
    appendInfo?: any;
    coord?: Coordinate;
    gridPoints?: GridPoints[];
}
export interface CircleAxisCfg extends AxisCfg {
    startAngle?: number;
    endAngle?: number;
    center: PointType;
    radius: number;
    inner: number;
}
export interface HelixAxisCfg extends AxisCfg {
    startAngle?: number;
    endAngle?: number;
    center: PointType;
    inner: number;
    a: number;
    axisStart: PointType;
    crp: PointType[];
}
export interface LineAxisCfg extends AxisCfg {
    isVertical: boolean;
    start: PointType;
    end: PointType;
    factor: 1 | -1;
}
export {};
