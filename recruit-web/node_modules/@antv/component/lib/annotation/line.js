"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var matrix_util_1 = require("@antv/matrix-util");
var _ = require("@antv/util");
var const_1 = require("../const");
var base_1 = require("./base");
var Line = /** @class */ (function (_super) {
    tslib_1.__extends(Line, _super);
    function Line(cfg) {
        /* istanbul ignore next */
        return _super.call(this, _.deepMix({
            type: 'line',
            xScales: null,
            yScales: null,
            line: {
                style: {
                    stroke: '#000',
                },
            },
            text: {
                display: true,
                position: 'end',
                autoRotate: true,
                style: {
                    fill: '#999',
                    fontSize: 12,
                    fontWeight: 500,
                    fontFamily: const_1.FONT_FAMILY,
                },
            },
        }, cfg)) || this;
    }
    Line.prototype.render = function (coord, group) {
        var _this = this;
        var start = this.parsePoint(coord, this.get('start'));
        var end = this.parsePoint(coord, this.get('end'));
        var guideLineGroup = group.addGroup();
        this.drawLines(start, end, guideLineGroup);
        var text = this.get('text');
        if (text.display && text.content) {
            this.drawText(start, end, guideLineGroup);
        }
        guideLineGroup.get('children').forEach(function (child) {
            child.name = 'annotation-line';
            _this.get('appendInfo') && child.setSilent('appendInfo', _this.get('appendInfo'));
        });
        this.set('el', guideLineGroup);
    };
    Line.prototype.drawLines = function (start, end, group) {
        var path = [['M', start.x, start.y], ['L', end.x, end.y]];
        group.addShape('Path', {
            attrs: _.assign({ path: path }, this.get('line').style),
        });
    };
    Line.prototype.drawText = function (start, end, group) {
        var textCfg = this.get('text');
        var position = textCfg.position;
        var textStyle = textCfg.style || {};
        var percent = 1;
        if (position === 'start') {
            percent = 0;
        }
        else if (position === 'center') {
            percent = 0.5;
        }
        else if (!_.isNil(position) && _.includes(position, '%')) {
            percent = parseInt(position, 10) / 100;
        }
        else if (_.isNumber(position) && (position >= 0 && position < 1)) {
            percent = position;
        }
        var cfg = {
            x: start.x + (end.x - start.x) * percent,
            y: start.y + (end.y - start.y) * percent,
            text: textCfg.content,
        };
        if (textCfg.offsetX) {
            // 设置了偏移量
            cfg.x += textCfg.offsetX;
        }
        if (textCfg.offsetY) {
            // 设置了偏移量
            cfg.y += textCfg.offsetY;
        }
        _.assign(cfg, textStyle);
        if (textCfg.autoRotate && _.isNil(textStyle.rotate)) {
            // 自动旋转且用户没有设置旋转角度
            var angle = matrix_util_1.vec2.angleTo([end.x - start.x, end.y - start.y], [1, 0], 1);
            cfg.rotate = angle;
        }
        else if (!_.isNil(textStyle.rotate)) {
            // 用户设置了旋转角度
            cfg.rotate = (textStyle.rotate * Math.PI) / 180;
        }
        group.addShape('Text', {
            attrs: cfg,
        });
    };
    return Line;
}(base_1.default));
exports.default = Line;
//# sourceMappingURL=line.js.map