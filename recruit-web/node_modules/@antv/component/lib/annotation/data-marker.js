"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("@antv/util");
var base_1 = require("./base");
var DataMarker = /** @class */ (function (_super) {
    tslib_1.__extends(DataMarker, _super);
    function DataMarker(cfg) {
        /* istanbul ignore next */
        return _super.call(this, _.deepMix({
            type: 'dataMarker',
            zIndex: 1,
            position: null,
            point: {
                display: true,
                style: {
                    r: 3,
                    fill: '#ffffff',
                    stroke: '#1890FF',
                    lineWidth: 2,
                },
            },
            line: {
                display: true,
                lineLength: 20,
                style: {
                    stroke: '#A3B1BF',
                    lineWidth: 1,
                },
            },
            text: {
                display: true,
                style: {
                    fill: '#000000',
                    opacity: 0.65,
                    fontSize: 12,
                    textAlign: 'start',
                },
            },
            direction: 'upward',
            autoAdjust: true,
        }, cfg)) || this;
    }
    DataMarker.prototype.render = function (coord, group) {
        var _this = this;
        var point = this.parsePoint(coord, this.get('position'));
        // container
        var markerGroup = group.addGroup();
        var positions = this.getElementPosition(point);
        var lineCfg = this.get('line');
        var pointCfg = this.get('point');
        var textCfg = this.get('text');
        var lineShape;
        var textShape;
        // add line
        if (lineCfg.display) {
            var lineData = positions.line;
            lineShape = this.drawLine(lineData, markerGroup);
        }
        // add text
        if (textCfg.display && textCfg.content) {
            var textPosition = positions.text;
            textShape = this.drawText(textPosition, markerGroup);
        }
        // add circle
        if (pointCfg.display) {
            var pointPoisition = positions.point;
            this.drawPoint(pointPoisition, markerGroup);
        }
        if (this.get('autoAdjust')) {
            var bbox = markerGroup.getBBox();
            var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
            var start = coord.start, end = coord.end;
            if (textShape) {
                if (minX <= start.x) {
                    // 左侧超出
                    textShape.attr('textAlign', 'start');
                }
                if (maxX >= end.x) {
                    // 右侧超出
                    textShape.attr('textAlign', 'end');
                }
                var direction = this.get('direction');
                if ((direction === 'upward' && minY <= end.y) || (direction !== 'upward' && maxY >= start.y)) {
                    // 上方或者下方超出
                    var textBaseline = void 0;
                    var dir = void 0;
                    if (direction === 'upward' && minY <= end.y) {
                        textBaseline = 'top';
                        dir = 1;
                    }
                    else {
                        textBaseline = 'bottom';
                        dir = -1;
                    }
                    textShape.attr('textBaseline', textBaseline);
                    var lineLength = 0;
                    if (lineCfg.display) {
                        lineLength = lineCfg.lineLength;
                        var linePath = [['M', point.x, point.y], ['L', point.x, point.y + lineLength * dir]];
                        lineShape.attr('path', linePath);
                    }
                    var newY = point.y + (lineLength + 2) * dir;
                    textShape.attr('y', newY);
                }
            }
        }
        // 用于事件以及动画识别
        markerGroup.get('children').forEach(function (child) {
            child.name = 'annotation-data-marker';
            _this.get('appendInfo') && child.setSilent('appendInfo', _this.get('appendInfo'));
        });
        this.set('el', markerGroup);
    };
    DataMarker.prototype.getElementPosition = function (position) {
        var x = position.x, y = position.y;
        var lineLength = this.get('line').display ? this.get('line').lineLength : 0;
        var direction = this.get('direction');
        var textStyle = this.get('text').style;
        textStyle.textBaseline = direction === 'upward' ? 'bottom' : 'top';
        var dir = direction === 'upward' ? -1 : 1;
        var pointPoisition = { x: x, y: y };
        var lineStart = { x: x, y: y };
        var lineEnd = { x: x, y: lineLength * dir + y };
        var textPosition = { x: x, y: (lineLength + 2) * dir + y };
        return {
            point: pointPoisition,
            line: [lineStart, lineEnd],
            text: textPosition,
        };
    };
    DataMarker.prototype.drawLine = function (lineData, g) {
        var lineStyle = this.get('line').style;
        var linePath = [['M', lineData[0].x, lineData[0].y], ['L', lineData[1].x, lineData[1].y]];
        var lineShape = g.addShape('path', {
            attrs: _.assign({
                path: linePath,
            }, lineStyle),
        });
        return lineShape;
    };
    DataMarker.prototype.drawText = function (position, g) {
        var textCfg = this.get('text');
        var textShape = g.addShape('text', {
            attrs: _.assign({
                text: textCfg.content,
            }, textCfg.style, position),
        });
        return textShape;
    };
    DataMarker.prototype.drawPoint = function (position, g) {
        var pointStyle = this.get('point').style;
        var pointShape = g.addShape('circle', {
            attrs: _.assign({}, pointStyle, position),
        });
        return pointShape;
    };
    return DataMarker;
}(base_1.default));
exports.default = DataMarker;
//# sourceMappingURL=data-marker.js.map