"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("@antv/util");
var g_1 = require("@antv/g");
var color_util_1 = require("@antv/color-util");
var base_1 = require("./base");
var constant_1 = require("./constant");
var Color = /** @class */ (function (_super) {
    tslib_1.__extends(Color, _super);
    function Color(cfg) {
        return _super.call(this, tslib_1.__assign({ type: 'color-legend' }, cfg)) || this;
    }
    /* 计算占比，是否需要缓存以提高重复渲染的性能；是否需要排序 */
    Color.prototype.calculatePercent = function (items) {
        var min = _.head(items).value;
        var max = _.last(items).value;
        var diff = max - min;
        return _.map(items, function (item) {
            return tslib_1.__assign(tslib_1.__assign({}, item), { percentage: (Number(item.value) - min) / diff });
        });
    };
    /* 颜色是否分段 */
    Color.prototype.isSegment = function () {
        return !!this.get('isSegment');
    };
    /* 可交互的情况 */
    Color.prototype.getOperationalGroup = function () {
        var width = this.get('width');
        var height = this.get('height');
        var items = this.calculatePercent(this.get('items'));
        var backgroundStyle = this.get('backgroundStyle');
        var fill = '';
        var rgbColor;
        if (this.isHorizontal()) {
            fill += 'l (0) ';
            _.each(items, function (v) {
                rgbColor = color_util_1.default.toRGB(v.color);
                fill += v.percentage + ":" + rgbColor + " ";
            });
        }
        else {
            fill += 'l (90) ';
            _.each(items, function (v) {
                rgbColor = color_util_1.default.toRGB(v.color);
                fill += 1 - v.percentage + ":" + rgbColor + " ";
            });
        }
        var background = new g_1.Rect({
            attrs: tslib_1.__assign({ x: 0, y: 0, width: width,
                height: height, strokeOpacity: 0 }, backgroundStyle),
        });
        var frontend = new g_1.Rect({
            attrs: {
                x: 0,
                y: 0,
                width: width,
                height: height,
                fill: fill,
                strokeOpacity: 0,
            },
        });
        var group = new g_1.Group();
        if (this.isOperational()) {
            group.add(background);
            group.add(frontend);
        }
        else {
            // 不可交互的时候，不需要 frontend
            group.add(frontend);
        }
        return {
            group: group,
            background: background,
            frontend: frontend,
        };
    };
    /**
     * 不可交互的情况：
     * 1. 无滑块
     * 2. 可以连续和分段
     * 3. 分段的时候下面有文字
     */
    Color.prototype.getUnOperationalGroup = function () {
        var _this = this;
        var width = this.get('width');
        var height = this.get('height');
        var items = this.calculatePercent(this.get('items'));
        var textStyle = this.get('textStyle');
        var group = new g_1.Group();
        var fill = '';
        var rgbColor;
        var path = [];
        var isize = items.length;
        // gradient color distributed according to the percentage
        if (this.isHorizontal()) {
            fill += 'l (0) ';
            _.each(items, function (item, i) {
                if (i !== 0 && (i !== isize - 1)) {
                    path.push(['M', item.percentage * width, 0]);
                    path.push(['L', item.percentage * width, height]);
                }
                rgbColor = color_util_1.default.toRGB(items[i].color);
                if (_this.isSegment() && i > 0) {
                    var preRgbColor = color_util_1.default.toRGB(items[i - 1].color);
                    fill += item.percentage + ":" + preRgbColor + " ";
                }
                fill += item.percentage + ":" + rgbColor + " ";
                group.addShape('text', {
                    attrs: tslib_1.__assign(tslib_1.__assign({ x: item.percentage * width, y: height + constant_1.TEXT_OFFSET, text: "" + _this.formatterValue(item.value) }, textStyle), { textBaseline: 'top', textAlign: 'center' }),
                });
            });
        }
        else {
            fill += 'l (90) ';
            _.each(items, function (item, i) {
                if (i !== 0 && (i !== isize - 1)) {
                    path.push(['M', 0, height - item.percentage * height]);
                    path.push(['L', width, height - item.percentage * height]);
                }
                rgbColor = color_util_1.default.toRGB(items[i].color);
                fill += 1 - item.percentage + ":" + rgbColor + " ";
                // one color instead of gradient color for a block while isSegment === true
                if (_this.isSegment() && i > 0) {
                    var preRgbColor = color_util_1.default.toRGB(items[i - 1].color);
                    fill += 1 - item.percentage + ":" + preRgbColor + " ";
                }
                group.addShape('text', {
                    attrs: tslib_1.__assign(tslib_1.__assign({ x: width + constant_1.TEXT_OFFSET, y: (1 - item.percentage) * height, text: "" + _this.formatterValue(item.value) }, textStyle), { textAlign: 'start', textBaseline: 'middle' }),
                });
            });
        }
        var background = group.addShape('rect', {
            attrs: {
                x: 0,
                y: 0,
                width: width,
                height: height,
                fill: fill,
                strokeOpacity: 0,
            },
        });
        // the white line segment to seperate color blocks
        group.addShape('path', {
            attrs: {
                path: path,
                lineWidth: 1,
                stroke: '#fff',
            },
        });
        return {
            group: group,
            background: background,
            frontend: undefined,
        };
    };
    /* 背景的样式，size 和 color 的背景完全不一样 */
    Color.prototype.createBackgroundGroup = function () {
        return this.isOperational() ? this.getOperationalGroup() : this.getUnOperationalGroup();
    };
    return Color;
}(base_1.default));
exports.default = Color;
//# sourceMappingURL=color.js.map