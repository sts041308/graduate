"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var g_1 = require("@antv/g");
var domUtil = require("@antv/dom-util");
var constant_1 = require("../constant");
/**
 * 滑动条的逻辑
 *
 * 滑动条包括几个部分：
 * - 滑动条背景
 * - 小滑块区域（滑块 + 文本）
 * - 大滑块区域（滑块 + 文本
 * - 中间滑动区域（左右滑块中间可以滑动选中的区域）
 * - 鼠标 hover 提示文本（暂时不处理）
 *
 * 其中 min，max，range 的创建内置掉，仅有外部的布局（v，h）、类型（rect、circle）影响
 */
var Slider = /** @class */ (function (_super) {
    tslib_1.__extends(Slider, _super);
    function Slider(cfg) {
        var _this = _super.call(this) || this;
        // 拖拽过程中，更新 slider 状态位置
        _this.onMouseMove = function (e) {
            var clientX = e.clientX, clientY = e.clientY;
            _this.updateSliderStatus(clientX, clientY);
        };
        // 拖拽结束，清除事件
        _this.onMouseUp = function () {
            // 走到这里，理论上一定会存在方法
            if (_this.clearAllEvents) {
                _this.clearAllEvents();
            }
            _this.currentTarget = undefined;
        };
        // cfg 属性全部存储到 this 上，而不是存储到 cfg 中！
        var layout = cfg.layout, sliderType = cfg.sliderType, sliderSize = cfg.sliderSize, operational = cfg.operational, width = cfg.width, height = cfg.height, textStyle = cfg.textStyle, min = cfg.min, max = cfg.max, range = cfg.range, formatter = cfg.formatter;
        _this.layout = layout;
        _this.sliderType = sliderType;
        var _a = sliderSize || [], _b = _a[0], w = _b === void 0 ? constant_1.SLIDER_WIDTH : _b, _c = _a[1], h = _c === void 0 ? constant_1.SLIDER_HEIGHT : _c;
        _this.sliderSize = [w, h];
        _this.operational = operational;
        _this.width = width;
        _this.height = height;
        _this.min = min;
        _this.max = max;
        _this.range = range;
        _this.textStyle = textStyle;
        _this.formatter = formatter;
        // 创建初始的内容
        _this.initialSlider();
        return _this;
    }
    /**
     * 外部设置 background
     * @param bg
     */
    Slider.prototype.setBackground = function (bg) {
        // 如果已经存在，那么先移除
        if (this.backgroundGroup) {
            // this.remove(true);
            // this.backgroundGroup.remove(true);
            // this.removeChild(this.backgroundGroup, true);
            this.backgroundGroup.destroy();
        }
        var group = bg.group, background = bg.background, frontend = bg.frontend;
        // 然后添加
        this.backgroundGroup = group;
        this.backgroundGroup.set('zIndex', 0);
        if (this.operational && this.rangeSliderShape && frontend) {
            frontend.attr('clip', this.rangeSliderShape);
            // this.add(this.rangeSliderShape);
        }
        this.add(this.backgroundGroup);
        this.sort();
    };
    /**
     * 滚动条布局，是否为横向
     * true  横向
     * false 纵向
     */
    Slider.prototype.isHorizontal = function () {
        return this.layout === 'horizontal';
    };
    /**
     * 初始化滑块
     * 在配置完滑块的背景之后，挑用初始化方法来初始化 slider
     */
    Slider.prototype.initialSlider = function () {
        if (this.operational) {
            this.rangeSliderShape = this.createRangeSliderShape();
            this.rangeSliderShape.set('zIndex', 1);
            this.minSliderGroup = this.createMinSliderGroup();
            this.minSliderGroup.set('zIndex', 2);
            this.maxSliderGroup = this.createMaxSliderGroup();
            this.maxSliderGroup.set('zIndex', 2);
            var _a = this.range, min = _a[0], max = _a[1];
            // 使用默认的 range 范围渲染 UI
            this.renderUIWithRange(min, max);
        }
        // 绑定事件
        this.bindEvent();
    };
    /* 滑块 hover 的鼠标样式 */
    Slider.prototype.getSliderCursor = function () {
        return this.isHorizontal() ? 'ew-resize' : 'ns-resize';
    };
    /* 小滑块的区域样式 */
    Slider.prototype.createMinSliderGroup = function () {
        var group = this.addGroup();
        this.minSliderShape = this.createSliderButton(group, true);
        this.minTextShape = this.createSliderText(group, true);
        return group;
    };
    /* 大滑块的区域样式 */
    Slider.prototype.createMaxSliderGroup = function () {
        var group = this.addGroup();
        this.maxSliderShape = this.createSliderButton(group, false);
        this.maxTextShape = this.createSliderText(group, false);
        return group;
    };
    /* 拖动两个滑块 button 中间，可以滑动整体 */
    Slider.prototype.createRangeSliderShape = function () {
        return this.addShape('rect', {
            attrs: {
                fill: '#fff',
                fillOpacity: 0,
                cursor: 'move',
            },
        });
    };
    /* rect 的属性信息 */
    Slider.prototype.getRectButtonAttribute = function (isMin) {
        var _a = this.sliderSize, sliderWidth = _a[0], sliderHeight = _a[1];
        // 前提，滑块的高度是宽度的一半
        if (this.isHorizontal()) {
            return {
                x: isMin ? -sliderWidth : 0,
                y: this.height / 2 - sliderHeight / 2,
                width: sliderWidth,
                height: sliderHeight,
            };
        }
        return {
            x: this.width / 2 - sliderHeight / 2,
            y: isMin ? 0 : -sliderWidth,
            width: sliderHeight,
            height: sliderWidth,
        };
    };
    Slider.prototype.getCircleButtonAttribute = function (isMin) {
        // circle 坐标系为圆心
        if (this.isHorizontal()) {
            return {
                x: 0,
                y: this.height / 2,
                r: constant_1.SLIDER_CIRCLE_MAX_SIZE / 2,
            };
        }
        return {
            x: this.width / 2,
            y: 0,
            r: constant_1.SLIDER_CIRCLE_MAX_SIZE / 2,
        };
    };
    /**
     * 创建滑块
     * @param group
     * @param isMin 是小滑块还是大滑块
     */
    Slider.prototype.createSliderButton = function (group, isMin) {
        var buttonAttr = this.sliderType === 'rect' ? this.getRectButtonAttribute(isMin) :
            this.sliderType === 'circle' ? this.getCircleButtonAttribute(isMin) : {};
        // 不同的 slider 滑块
        var buttonAttribute = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, buttonAttr), constant_1.SliderBtnStyle), { cursor: this.getSliderCursor() });
        return group.addShape(this.sliderType, {
            attrs: buttonAttribute,
        });
    };
    Slider.prototype.getRectTextAttribute = function (isMin) {
        var _a = this.sliderSize, sliderWidth = _a[0], sliderHeight = _a[1];
        return this.isHorizontal() ? {
            // text 文本值
            x: isMin ? -sliderWidth / 2 : sliderWidth / 2,
            y: this.height / 2 + sliderHeight / 2 + 4,
            textAlign: 'center',
            textBaseline: 'top',
        } : {
            x: this.width / 2 + sliderHeight / 2 + 4,
            y: isMin ? sliderWidth / 2 : -sliderWidth / 2,
            textAlign: 'left',
            textBaseline: 'middle',
        };
    };
    Slider.prototype.getCircleTextAttribute = function (isMin) {
        return this.isHorizontal() ? {
            // text 文本值
            x: 0,
            y: this.height / 2 + constant_1.SLIDER_CIRCLE_MAX_SIZE / 2 + 4,
            textAlign: 'center',
            textBaseline: 'top',
        } : {
            x: this.width / 2 + constant_1.SLIDER_CIRCLE_MAX_SIZE / 2 + 4,
            y: 0,
            textAlign: 'left',
            textBaseline: 'middle',
        };
    };
    /**
     * 创建滑块文字
     * @param group
     * @param isMin
     */
    Slider.prototype.createSliderText = function (group, isMin) {
        var textAttribute = this.sliderType === 'rect' ? this.getRectTextAttribute(isMin) :
            this.sliderType === 'circle' ? this.getCircleTextAttribute(isMin) : {};
        var textAttr = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this.textStyle), textAttribute), { text: '' });
        return group.addShape('text', {
            attrs: textAttr,
        });
    };
    // 绑定事件：大小滑块鼠标事件，range 区域的鼠标事件
    Slider.prototype.bindEvent = function () {
        if (this.operational) {
            // 鼠标点击的时候，开始滑动
            this.on('mousedown', this.onMouseDown);
        }
    };
    Slider.prototype.onMouseDown = function (ev) {
        // 当前触发的 shape
        this.currentTarget = ev.target;
        var originEvent = ev.event;
        // 阻止冒泡
        originEvent.stopPropagation();
        originEvent.preventDefault();
        var clientX = originEvent.clientX, clientY = originEvent.clientY;
        // 鼠标坐标位置
        this.pos = this.isHorizontal() ? clientX : clientY;
        this.bindCanvasEvents();
    };
    Slider.prototype.bindCanvasEvents = function () {
        var containerDOM = this.get('canvas').get('containerDOM');
        var e1 = domUtil.addEventListener(containerDOM, 'mousemove', this.onMouseMove);
        var e2 = domUtil.addEventListener(containerDOM, 'mouseup', this.onMouseUp);
        var e3 = domUtil.addEventListener(containerDOM, 'mouseleave', this.onMouseUp);
        // 清除所有事件的方法，在交互结束的时候执行
        this.clearAllEvents = function () {
            e1.remove();
            e2.remove();
            e3.remove();
        };
    };
    Slider.prototype.isDragMin = function () {
        return this.currentTarget === this.minSliderShape;
    };
    Slider.prototype.isDragMax = function () {
        return this.currentTarget === this.maxSliderShape;
    };
    Slider.prototype.isDragAll = function () {
        return this.currentTarget === this.rangeSliderShape;
    };
    /**
     * 根据鼠标位置 x,y，更新滑块位置状态
     * @param x
     * @param y
     */
    Slider.prototype.updateSliderStatus = function (x, y) {
        var _this = this;
        var totalLength = this.isHorizontal() ? this.width : this.height;
        var sign = this.isHorizontal() ? 1 : -1; // canvas 坐标和事件坐标相反
        var _a = this.range, min = _a[0], max = _a[1]; // 默认的 range
        var prePosition = this.pos;
        var currentPosition = this.isHorizontal() ? x : y;
        // 鼠标拖拽的长度
        var diffLength = currentPosition - prePosition;
        // 鼠标拖拽的比例，用于做 range 计算
        var diff = (diffLength / totalLength) * sign;
        var newRange = [min, max];
        // 左右两个一起拖拽（拖拽左右滑块中间区域，可以实现两个滑块一起拖拽）
        if (this.isDragAll()) {
            if (diff >= 0 && max + diff > 1) {
                // max 超出
                newRange = [min + (1 - max), 1];
            }
            else if (diff < 0 && min + diff < 0) {
                // min 超出
                newRange = [0, max - min];
            }
            else {
                // 都没有超出
                newRange = [min + diff, max + diff];
            }
        }
        else {
            // 分别处理
            if (this.isDragMin()) {
                newRange[0] = this.getNewRange(min, diff);
            }
            if (this.isDragMax()) {
                newRange[1] = this.getNewRange(max, diff);
            }
            // 如果处理之后 max < min，则设置成一样的，拖那个用哪个
            if (newRange[1] < newRange[0]) {
                newRange = Array(2).fill(this.isDragMin() ? newRange[0] : newRange[1]);
            }
        }
        // 更新状态
        this.pos = currentPosition;
        this.range = newRange;
        // 发送事件
        this.emit('sliderchange', {
            range: newRange,
            value: newRange.map(function (r) { return _this.getValue(r); }),
        });
        this.renderUIWithRange(newRange[0], newRange[1]);
        // 渲染 redraw
        this.get('canvas').draw();
    };
    /* 根据 range 变更 ui */
    Slider.prototype.renderUIWithRange = function (minRatio, maxRatio) {
        var width = this.width;
        var height = this.height;
        // resetMatrix 是 reset 的创建的属性
        this.minSliderGroup.resetMatrix();
        this.maxSliderGroup.resetMatrix();
        // 修改滑块位置
        // 横向，纵向的变换逻辑不一样
        if (this.isHorizontal()) {
            this.rangeSliderShape.attr({
                x: width * minRatio,
                y: 0,
                width: (maxRatio - minRatio) * width,
                height: height,
            });
            this.minSliderGroup.translate(minRatio * width, 0);
            this.maxSliderGroup.translate(maxRatio * width, 0);
        }
        else {
            this.rangeSliderShape.attr({
                x: 0,
                y: height * (1 - maxRatio),
                width: width,
                height: (maxRatio - minRatio) * height,
            });
            // 纵向图例，上大下小
            this.minSliderGroup.translate(0, (1 - minRatio) * height);
            this.maxSliderGroup.translate(0, (1 - maxRatio) * height);
        }
        // 更新文本
        this.minTextShape.attr('text', this.formatter(this.getValue(minRatio)));
        this.maxTextShape.attr('text', this.formatter(this.getValue(maxRatio)));
        // 对于 circle 的情况下，滑块的大小需要随着变化而变化
        if (this.sliderType === 'circle') {
            this.minSliderShape.attr({
                r: (constant_1.SLIDER_HEIGHT + minRatio * (constant_1.SLIDER_CIRCLE_MAX_SIZE - constant_1.SLIDER_HEIGHT)) / 2,
            });
            this.maxSliderShape.attr({
                r: (constant_1.SLIDER_HEIGHT + maxRatio * (constant_1.SLIDER_CIRCLE_MAX_SIZE - constant_1.SLIDER_HEIGHT)) / 2,
            });
        }
    };
    /**
     * 在原来 range 的基础上，增加一个 diff
     * @param range
     * @param diff
     */
    Slider.prototype.getNewRange = function (range, diff) {
        var r = diff + range;
        return r > 1 ? 1 :
            r < 0 ? 0 : r;
    };
    Slider.prototype.getValue = function (ratio) {
        var v = this.min + (this.max - this.min) * ratio;
        return Number(v.toFixed(v > 1 ? 0 : 2)); // todo 格式化规则
    };
    return Slider;
}(g_1.Group));
exports.default = Slider;
//# sourceMappingURL=slider.js.map