import { __assign, __extends } from "tslib";
import { Element } from '@antv/g';
import * as _ from '@antv/util';
import Guide from '../base';
var Annotation = /** @class */ (function (_super) {
    __extends(Annotation, _super);
    function Annotation(cfg) {
        /* istanbul ignore next */
        return _super.call(this, __assign({ xScales: null, yScales: null, el: null }, cfg)) || this;
    }
    Annotation.prototype.clear = function () {
        var el = this.get('el');
        if (el) {
            el.remove();
        }
    };
    Annotation.prototype.changeVisible = function (visible) {
        this.set('visible', visible);
        var el = this.get('el');
        if (el instanceof Element) {
            el.set('visible', visible);
        }
        else if (el instanceof HTMLElement) {
            el.style.display = visible ? '' : 'none';
        }
    };
    /** 批量修改内部状态 */
    Annotation.prototype.change = function (cfg) {
        this.cfg = _.deepMix({}, this.cfg, cfg);
    };
    // 修改基类会导致label中大量不严谨的类型写法需要重构
    Annotation.prototype.get = function (name) {
        return this.cfg[name];
    };
    Annotation.prototype.set = function (name, value) {
        this.cfg[name] = value;
        return this;
    };
    Annotation.prototype.parsePoint = function (coord, _position) {
        var xScales = this.get('xScales');
        var yScales = this.get('yScales');
        var position = _.isFunction(_position) ? _position.call(null, xScales, yScales) : _position;
        var x = 0;
        var y = 0;
        // 入参是['50%', '50%']时
        if (_.isArray(position) && _.includes(position[0], '%')) {
            return this.parsePercentPoint(coord, position);
        }
        if (_.isArray(position)) {
            x = this.getNormalizedValue(position[0], _.head(_.values(xScales)));
            y = this.getNormalizedValue(position[1], _.head(_.values(yScales)));
        }
        else if (!_.isNil(position)) {
            for (var _i = 0, _a = _.keys(position); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = position[key];
                if (xScales[key]) {
                    x = this.getNormalizedValue(value, xScales[key]);
                }
                if (yScales[key]) {
                    y = this.getNormalizedValue(value, yScales[key]);
                }
            }
        }
        return coord.convert({ x: x, y: y });
    };
    Annotation.prototype.getNormalizedValue = function (val, scale) {
        var result;
        var scaled;
        switch (val) {
            case 'start':
                result = 0;
                break;
            case 'end':
                result = 1;
                break;
            case 'median': {
                scaled = scale.isCategory ? (scale.values.length - 1) / 2 : (scale.min + scale.max) / 2;
                result = scale.scale(scaled);
                break;
            }
            case 'min':
            case 'max':
                if (scale.isCategory) {
                    scaled = val === 'min' ? 0 : scale.values.length - 1;
                }
                else {
                    scaled = scale[val];
                }
                result = scale.scale(scaled);
                break;
            default:
                result = scale.scale(val);
        }
        return result;
    };
    Annotation.prototype.parsePercentPoint = function (coord, position) {
        var xPercent = parseFloat(position[0]) / 100;
        var yPercent = parseFloat(position[1]) / 100;
        var start = coord.start, end = coord.end;
        var topLeft = {
            x: Math.min(start.x, end.x),
            y: Math.min(start.y, end.y),
        };
        var x = coord.getWidth() * xPercent + topLeft.x;
        var y = coord.getHeight() * yPercent + topLeft.y;
        return { x: x, y: y };
    };
    return Annotation;
}(Guide));
export default Annotation;
//# sourceMappingURL=base.js.map