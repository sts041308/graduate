import { __assign, __extends } from "tslib";
import * as Util from '@antv/util';
import Guide from '../base';
import Label from '../label/base';
import Theme from './theme';
var Axis = /** @class */ (function (_super) {
    __extends(Axis, _super);
    function Axis(cfg) {
        var _this = _super.call(this, __assign({ type: 'base', id: null, line: {
                lineWidth: 1,
                stroke: '#C0D0E0',
            }, tickLine: {
                lineWidth: 1,
                stroke: '#C0D0E0',
                length: 5,
            }, subTickCount: 0, subTickLine: null, grid: null, label: null, title: null, autoRotateLabel: true, autoHideLabel: false, autoRotateTitle: true, gridType: 'line', ticks: [], labelItems: [], gridPoints: [] }, cfg)) || this;
        _this._processTicks();
        return _this;
    }
    Axis.prototype.render = function () {
        var grid = this.get('grid');
        grid && this._renderGrid(); // 渲染坐标轴网格线
        var line = this.get('line');
        line && this._renderLine(); // 渲染坐标轴线
        var tickLine = this.get('tickLine');
        tickLine && this._renderTicks(); // 渲染坐标轴刻度线
        var label = this.get('label');
        label && this._renderLabels(); // 渲染坐标轴文本
        var title = this.get('title');
        if (title) {
            // 渲染坐标轴标题
            this.set('title', Util.deepMix({}, Theme.title, this.get('title')));
            this.renderTitle();
        }
    };
    Axis.prototype.destroy = function () {
        if (!this.destroyed) {
            _super.prototype.destroy.call(this);
            var gridGroup = this.get('gridGroup');
            gridGroup && gridGroup.remove();
            var labelRenderer = this.get('labelRenderer');
            labelRenderer && labelRenderer.destroy();
            var group = this.get('group');
            group.destroy();
            this.destroyed = true;
        }
    };
    Axis.prototype.clear = function () {
        var group = this.get('group');
        if (!group.get('destroyed') && group.get('children').length) {
            var gridGroup = this.get('gridGroup');
            gridGroup && gridGroup.clear();
            var labelRenderer = this.get('labelRenderer');
            labelRenderer && labelRenderer.clear();
            // 再飞 mark: 这样就会将所有的 axis 实例中创建的 shapes 和 groups 清空
            // 按照正常的逻辑，应该只负责清空当前实例创建的 shaps 和 groups
            this.get('group').clear();
        }
    };
    /**
     * 解析 tick 文本
     * @param tick tick 文本值
     * @param index tick 对应的索引值
     * @param length 所有 tick 的总长度
     */
    Axis.prototype.parseTick = function (tick, index, length) {
        return {
            text: tick,
            value: index / (length - 1),
        };
    };
    /**
     * 添加 labelItems
     * @param tick 坐标轴刻度信息
     * @param point 位置点信息
     * @param index 对应的索引值
     * @param tickCount 全部坐标轴刻度的个数
     */
    Axis.prototype.addLabel = function (tick, point, index, tickCount) {
        var theme = this.get('theme') || {};
        var label = this.get('label');
        var labelCfg = label;
        if (Util.isFunction(labelCfg)) {
            // 如果用户定义的 label 属性是回调函数
            var executedLabel = label(tick.text, index, tickCount);
            labelCfg = executedLabel ? Util.deepMix({}, theme.label, executedLabel) : null;
        }
        if (labelCfg) {
            labelCfg = Util.deepMix({ text: tick.text }, Theme.label, labelCfg);
            // 支持formatter配置
            if (labelCfg.formatter) {
                labelCfg.text = labelCfg.formatter(tick.text, index, tickCount);
            }
            var vector = this.getSideVector(labelCfg.offset, point, index);
            var newPoint = {
                x: point.x + vector[0] + labelCfg.offsetX,
                y: point.y + vector[1] + labelCfg.offsetY,
            };
            labelCfg.x = newPoint.x;
            labelCfg.y = newPoint.y;
            labelCfg.point = newPoint;
            if (!Util.isNil(point.rotate)) {
                labelCfg.rotate = point.rotate;
            }
            if (!Util.isNil(labelCfg.rotate)) {
                labelCfg.textAlign =
                    labelCfg.rotate % 180 === 0
                        ? 'center'
                        : labelCfg.rotate > 0
                            ? labelCfg.rotate % 360 < 180
                                ? 'left'
                                : 'right'
                            : labelCfg.rotate % 360 > -180
                                ? 'right'
                                : 'left';
                var offset = -6 * Math.abs(Math.sin((labelCfg.rotate * Math.PI) / 180));
                labelCfg.y += offset;
                labelCfg.point.y += offset;
            }
            else {
                labelCfg.textAlign = this.getTextAnchor(vector);
            }
            if (labelCfg.useHtml) {
                labelCfg.text = labelCfg.htmlTemplate; // TODO: 是否直接在 text 中定义 html 模板？
            }
            this.get('labelItems').push(labelCfg);
        }
    };
    /**
     * 根据向量值获取文本的对齐方式
     * @param vector 文本的向量值
     */
    Axis.prototype.getTextAnchor = function (vector) {
        var ratio = Math.abs(vector[1] / vector[0]);
        if (ratio >= 1) {
            // 上面或者下面
            return 'center';
        }
        if (vector[0] > 0) {
            // 右侧
            return 'start';
        }
        return 'end'; // 左侧
    };
    Axis.prototype.getMaxLabelWidthOrHeight = function (labelRenderer, property) {
        var labels = labelRenderer.getLabels();
        var max = 0;
        Util.each(labels, function (label) {
            var bbox = label.getBBox();
            var value = bbox[property];
            if (max < value) {
                max = value;
            }
        });
        return max;
    };
    /**
     * 自动旋转文本
     * @override
     */
    Axis.prototype.autoRotateLabels = function () { };
    /**
     * 文本自动防遮罩
     * @override
     */
    Axis.prototype.autoHideLabels = function () { };
    /**
     * 渲染标题
     * @override
     */
    Axis.prototype.renderTitle = function () { };
    // 渲染坐标轴线
    Axis.prototype._renderLine = function () {
        var path = this.getLinePath();
        var lineCfg = __assign({ path: path }, this.get('line'));
        var group = this.get('group'); // 获取容器
        var lineShape = group.addShape('path', {
            attrs: lineCfg,
            zIndex: 1,
        });
        lineShape.name = 'axis-line';
        this.get('appendInfo') && lineShape.setSilent('appendInfo', this.get('appendInfo'));
        this.set('lineShape', lineShape);
    };
    // 渲染坐标轴线
    Axis.prototype._renderTicks = function () {
        var tickLineCfg = this.get('tickLine');
        var tickItems = this.get('tickItems');
        var subTickItems = this.get('subTickItems');
        if (tickItems && tickItems.length) {
            this._addTickLine(tickItems, tickLineCfg);
        }
        if (subTickItems && subTickItems.length) {
            var subTickLineCfg = this.get('subTickLine') || tickLineCfg;
            this._addTickLine(subTickItems, subTickLineCfg);
        }
    };
    Axis.prototype._renderGrid = function () {
        var _this = this;
        var coord = this.get('coord');
        var appendInfo = this.get('appendInfo');
        var group = this.get('group');
        var gridPoints = this.get('gridPoints');
        var grid = this.get('grid');
        var gridType = this.get('gridType');
        var theme = this.get('theme') || {};
        var ticks = this.get('ticks');
        var count = gridPoints.length;
        var gridGroup = group.addGroup({
            class: 'axis-grid',
            zIndex: 0,
        });
        // 这边也可以用 gridGroup.setZIndex(0); 但在顶上直接管理好声明的顺序更好一点
        // 最好不要用 gridGroup.toBack(); toBack 适合 zIndex 相同的 silbings 排序
        this.set('gridGroup', gridGroup);
        // 渲染网格线
        var gridCfg = grid;
        Util.each(gridPoints, function (subPoints, index) {
            if (Util.isFunction(grid)) {
                // grid 是回调函数
                var tick = ticks[index];
                var executedGrid = tick && grid(tick.text, index, count);
                gridCfg = executedGrid ? Util.mix({}, theme.grid, executedGrid) : null;
            }
            if (gridCfg) {
                var points = subPoints.points;
                var path_1 = [];
                if (gridType === 'arc') {
                    // 弧形
                    Util.each(points, function (point, idx) {
                        var radius = point.radius, x = point.x, y = point.y, flag = point.flag;
                        if (idx === 0) {
                            path_1.push(['M', x, y]);
                        }
                        else {
                            path_1.push(['A', radius, radius, 0, 0, flag, x, y]);
                        }
                    });
                }
                else {
                    Util.each(points, function (point, idx) {
                        var x = point.x, y = point.y;
                        if (idx === 0) {
                            path_1.push(['M', x, y]);
                        }
                        else {
                            path_1.push(['L', x, y]);
                        }
                    });
                }
                var gridLineShape = gridGroup.addShape('path', {
                    attrs: Util.mix({ path: path_1 }, Theme.grid, gridCfg),
                });
                gridLineShape.name = 'axis-grid';
                gridLineShape.id = subPoints.id;
                gridLineShape.set('coord', coord);
                appendInfo && gridLineShape.setSilent('appendInfo', gridLineShape);
            }
        });
        // 用户设置了网格的交替填充色
        var gridAlternateColor = this.get('gridAlternateColor');
        if (gridAlternateColor) {
            var preItem_1;
            Util.each(gridPoints, function (item, index) {
                if (preItem_1) {
                    _this._drawAlternativeBg(item, preItem_1, index);
                }
                preItem_1 = item;
            });
        }
    };
    Axis.prototype._renderLabels = function () {
        var group = this.get('group');
        var labelRenderer = new Label({ name: 'axis-label' });
        labelRenderer.set('coord', this.get('coord'));
        labelRenderer.set('group', group.addGroup({
            class: 'axis-labels',
        }));
        labelRenderer.set('canvas', this.get('canvas'));
        labelRenderer.set('items', this.get('labelItems'));
        labelRenderer.draw(false);
        this.set('labelRenderer', labelRenderer);
        if (this.get('autoRotateLabel')) {
            this.autoRotateLabels();
        }
        if (this.get('autoHideLabel')) {
            this.autoHideLabels();
        }
    };
    // 生成 ticks
    Axis.prototype._processTicks = function () {
        var _this = this;
        var labelCfg = this.get('label');
        var subTickCount = this.get('subTickCount');
        var tickLineCfg = this.get('tickLine');
        var ticks = this._parseTicks(this.get('ticks'));
        var tickCount = ticks.length;
        Util.each(ticks, function (tick, index) {
            var tickPoint = _this.getTickPoint(tick.value, index);
            if (tickLineCfg) {
                _this._addTickItem(index, tickPoint, tickLineCfg.length);
            }
            if (labelCfg) {
                _this.addLabel(tick, tickPoint, index, tickCount);
            }
        });
        if (subTickCount) {
            // 如果有设置次级分点，添加次级tick
            var subTickLineCfg_1 = this.get('subTickLine');
            Util.each(ticks, function (tick, index) {
                if (index > 0) {
                    var diff = tick.value - ticks[index - 1].value;
                    diff = diff / (_this.get('subTickCount') + 1);
                    for (var i = 1; i <= subTickCount; i++) {
                        var subTick = {
                            text: '',
                            value: index ? ticks[index - 1].value + i * diff : i * diff,
                        };
                        var tickPoint = _this.getTickPoint(subTick.value);
                        var subTickLength = void 0;
                        if (subTickLineCfg_1 && subTickLineCfg_1.length) {
                            subTickLength = subTickLineCfg_1.length;
                        }
                        else {
                            subTickLength = Math.floor(tickLineCfg.length * (3 / 5));
                        }
                        _this._addTickItem(i - 1, tickPoint, subTickLength, 'sub');
                    }
                }
            });
        }
    };
    Axis.prototype._parseTicks = function (ticks) {
        if (ticks === void 0) { ticks = []; }
        var ticksLength = ticks.length;
        for (var i = 0; i < ticksLength; i++) {
            var item = ticks[i];
            if (!Util.isObject(item)) {
                ticks[i] = this.parseTick(item, i, ticksLength);
            }
        }
        this.set('ticks', ticks);
        return ticks;
    };
    Axis.prototype._addTickItem = function (index, point, length, type) {
        if (type === void 0) { type = ''; }
        var tickItems = this.get('tickItems') || [];
        var subTickItems = this.get('subTickItems') || [];
        var end = this.getTickEnd(point, length, index);
        var cfg = {
            x1: point.x,
            y1: point.y,
            x2: end.x,
            y2: end.y,
        };
        if (type === 'sub') {
            subTickItems.push(cfg);
        }
        else {
            tickItems.push(cfg);
        }
        this.set('tickItems', tickItems);
        this.set('subTickItems', subTickItems);
    };
    Axis.prototype._addTickLine = function (ticks, lineCfg) {
        var cfg = Util.mix({}, lineCfg);
        var path = [];
        Util.each(ticks, function (item) {
            path.push(['M', item.x1, item.y1]);
            path.push(['L', item.x2, item.y2]);
        });
        delete cfg.length;
        cfg.path = path;
        var group = this.get('group');
        var tickShape = group.addShape('path', {
            attrs: cfg,
            zIndex: 1,
        });
        tickShape.name = 'axis-ticks';
        tickShape.id = this.get('id') + "-ticks";
        tickShape.set('coord', this.get('coord'));
        this.get('appendInfo') && tickShape.setSilent('appendInfo', this.get('appendInfo'));
    };
    // Grid 的背景层绘制逻辑
    Axis.prototype._drawAlternativeBg = function (item, preItem, index) {
        var alternateColor = this.get('gridAlternateColor');
        var attrs;
        var oddColor;
        var evenColor;
        if (Util.isString(alternateColor)) {
            oddColor = alternateColor;
        }
        else if (Util.isArray(alternateColor)) {
            oddColor = alternateColor[0];
            evenColor = alternateColor[1];
        }
        if (index % 2 === 0) {
            if (evenColor) {
                attrs = this._getBackItem(preItem.points, item.points, evenColor);
            }
        }
        else if (oddColor) {
            attrs = this._getBackItem(preItem.points, item.points, oddColor);
        }
        var gridGroup = this.get('gridGroup');
        var shape = gridGroup.addShape('Path', {
            attrs: attrs,
        });
        shape.name = 'axis-grid-rect'; // TODO： 需要区分 -rect 吗？还是统一叫做 axis-grid
        shape.id = item.id && item.id.replace('grid', 'grid-rect');
        shape.set('coord', this.get('coord'));
        this.get('appendInfo') && shape.setSilent('appendInfo', this.get('appendInfo'));
    };
    Axis.prototype._getBackItem = function (start, end, bgColor) {
        var path = [];
        var gridType = this.get('gridType');
        if (gridType === 'arc') {
            Util.each(start, function (subItem, index) {
                var x = subItem.x, y = subItem.y, radius = subItem.radius, flag = subItem.flag;
                if (index === 0) {
                    path.push(['M', x, y]);
                }
                else {
                    path.push(['A', radius, radius, 0, 0, flag, x, y]);
                }
            });
            for (var j = end.length - 1; j >= 0; j--) {
                var endSubItem = end[j];
                var x = endSubItem.x, y = endSubItem.y, radius = endSubItem.radius, flag = endSubItem.flag;
                if (j === end.length - 1) {
                    path.push(['M', x, y]);
                }
                else {
                    path.push(['A', radius, radius, 0, 0, flag === 1 ? 0 : 1, x, y]);
                }
            }
        }
        else {
            Util.each(start, function (subItem, index) {
                var x = subItem.x, y = subItem.y;
                if (index === 0) {
                    path.push(['M', x, y]);
                }
                else {
                    path.push(['L', x, y]);
                }
            });
            for (var i = end.length - 1; i >= 0; i--) {
                path.push(['L', end[i].x, end[i].y]);
            }
            path.push(['Z']);
        }
        return {
            fill: bgColor,
            path: path,
        };
    };
    return Axis;
}(Guide));
export default Axis;
//# sourceMappingURL=base.js.map