import { __assign, __extends } from "tslib";
import * as Util from '@antv/util';
import Guide from '../base';
var Crosshair = /** @class */ (function (_super) {
    __extends(Crosshair, _super);
    function Crosshair(cfg) {
        var _this = _super.call(this, __assign({ 
            /**
             * crosshair的类型
             */
            type: null, 
            /**
             * 画在哪层视图
             */
            plot: null, 
            /**
             * x轴上，移动到位置的偏移量
             */
            panelRange: null, 
            /**
             * 默认rect crosshair样式
             * @type {Object}
             */
            rectStyle: {
                fill: '#CCD6EC',
                opacity: 0.3,
            }, 
            /**
             * 默认line crosshair样式
             */
            lineStyle: {
                stroke: 'rgba(0, 0, 0, 0.25)',
                lineWidth: 1,
            }, isTransposed: false }, cfg)) || this;
        _this._init_();
        _this.render();
        return _this;
    }
    Crosshair.prototype._init_ = function () {
        var plot = this.get('plot');
        var group = plot.addGroup();
        this.set('container', group);
    };
    Crosshair.prototype._addLineShape = function (attrs, type) {
        var container = this.get('container');
        var shape = container.addShape('line', {
            attrs: attrs,
            capture: false,
        });
        // shape.hide();
        this.set("crossLineShape" + type, shape);
        return shape;
    };
    Crosshair.prototype._renderHorizontalLine = function (canvas, panelRange) {
        // todo
        var style = Util.mix(this.get('lineStyle'), this.get('style'));
        var attrs = Util.mix({
            x1: panelRange ? panelRange.bl.x : canvas.get('width'),
            y1: 0,
            x2: panelRange ? panelRange.br.x : 0,
            y2: 0,
        }, style);
        this._addLineShape(attrs, 'X');
    };
    Crosshair.prototype._renderVerticalLine = function (canvas, panelRange) {
        // todo
        var style = Util.mix(this.get('lineStyle'), this.get('style'));
        var attrs = Util.mix({
            x1: 0,
            y1: panelRange ? panelRange.bl.y : canvas.get('height'),
            x2: 0,
            y2: panelRange ? panelRange.tl.y : 0,
        }, style);
        this._addLineShape(attrs, 'Y');
    };
    Crosshair.prototype._renderBackground = function (canvas, panelRange) {
        var style = Util.mix(this.get('rectStyle'), this.get('style'));
        var container = this.get('container');
        var attrs = Util.mix({
            x: panelRange ? panelRange.tl.x : 0,
            y: panelRange ? panelRange.tl.y : canvas.get('height'),
            width: panelRange ? panelRange.br.x - panelRange.bl.x : canvas.get('width'),
            height: panelRange ? Math.abs(panelRange.tl.y - panelRange.bl.y) : canvas.get('height'),
        }, style);
        var shape = container.addShape('rect', {
            attrs: attrs,
            capture: false,
        });
        // shape.hide();
        this.set('crosshairsRectShape', shape);
        return shape;
    };
    Crosshair.prototype._updateRectShape = function (items) {
        var offset;
        var crosshairsRectShape = this.get('crosshairsRectShape');
        var isTransposed = this.get('isTransposed');
        var firstItem = items[0];
        var lastItem = items[items.length - 1];
        var dim = isTransposed ? 'y' : 'x';
        var attr = isTransposed ? 'height' : 'width';
        var startDim = firstItem[dim];
        if (items.length > 1 && firstItem[dim] > lastItem[dim]) {
            startDim = lastItem[dim];
        }
        if (this.get('width')) {
            // 用户定义了 width
            crosshairsRectShape.attr(dim, startDim - this.get('crosshairs').width / 2);
            crosshairsRectShape.attr(attr, this.get('width'));
        }
        else {
            if (Util.isArray(firstItem.point[dim]) && !firstItem.size) {
                // 直方图
                var width = firstItem.point[dim][1] - firstItem.point[dim][0];
                crosshairsRectShape.attr(dim, firstItem.point[dim][0]);
                crosshairsRectShape.attr(attr, width);
            }
            else {
                offset = (3 * firstItem.size) / 4;
                crosshairsRectShape.attr(dim, startDim - offset);
                if (items.length === 1) {
                    crosshairsRectShape.attr(attr, (3 * firstItem.size) / 2);
                }
                else {
                    crosshairsRectShape.attr(attr, Math.abs(lastItem[dim] - firstItem[dim]) + 2 * offset);
                }
            }
        }
    };
    Crosshair.prototype.render = function () {
        var canvas = this.get('canvas');
        var panelRange = this.get('panelRange');
        var isTransposed = this.get('isTransposed');
        this.clear();
        switch (this.get('type')) {
            case 'x':
                this._renderHorizontalLine(canvas, panelRange);
                break;
            case 'y':
                this._renderVerticalLine(canvas, panelRange);
                break;
            case 'cross':
                this._renderHorizontalLine(canvas, panelRange);
                this._renderVerticalLine(canvas, panelRange);
                break;
            case 'rect':
                this._renderBackground(canvas, panelRange);
                break;
            default:
                isTransposed ? this._renderHorizontalLine(canvas, panelRange) : this._renderVerticalLine(canvas, panelRange);
        }
    };
    Crosshair.prototype.show = function () {
        var container = this.get('container');
        // super.show();
        container.show();
    };
    Crosshair.prototype.hide = function () {
        var container = this.get('container');
        // super.hide();
        container.hide();
    };
    Crosshair.prototype.clear = function () {
        var container = this.get('container');
        this.set('crossLineShapeX', null);
        this.set('crossLineShapeY', null);
        this.set('crosshairsRectShape', null);
        // super.clear();
        container.clear();
    };
    Crosshair.prototype.destroy = function () {
        var container = this.get('container');
        _super.prototype.destroy.call(this);
        container.remove();
    };
    Crosshair.prototype.setPosition = function (x, y, items) {
        var crossLineShapeX = this.get('crossLineShapeX');
        var crossLineShapeY = this.get('crossLineShapeY');
        var crosshairsRectShape = this.get('crosshairsRectShape');
        if (crossLineShapeY && !crossLineShapeY.get('destroyed')) {
            // 第一次进入时，画布需要单独绘制，所以需要先设定corss的位置
            crossLineShapeY.move(x, 0);
        }
        if (crossLineShapeX && !crossLineShapeX.get('destroyed')) {
            crossLineShapeX.move(0, y);
        }
        if (crosshairsRectShape && !crosshairsRectShape.get('destroyed')) {
            this._updateRectShape(items);
        }
    };
    return Crosshair;
}(Guide));
export default Crosshair;
//# sourceMappingURL=crosshair.js.map