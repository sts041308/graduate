import * as _ from '@antv/util';
var Greedy = /** @class */ (function () {
    function Greedy(cfg) {
        this.bitmap = {};
        this.xGap = 1;
        this.yGap = 8; // optimizing for text overlapping detection: use a min text height as gap
        if (cfg) {
            _.mix(this, cfg);
        }
    }
    Greedy.prototype.hasGap = function (bbox) {
        var hasGap = true;
        var bitmap = this.bitmap;
        var minX = Math.round(bbox.minX);
        var maxX = Math.round(bbox.maxX);
        var minY = Math.round(bbox.minY);
        var maxY = Math.round(bbox.maxY);
        for (var i = minX; i <= maxX; i += 1) {
            if (!bitmap[i]) {
                bitmap[i] = {};
                continue;
            }
            if (i === minX || i === maxX) {
                for (var j = minY; j <= maxY; j++) {
                    if (bitmap[i][j]) {
                        hasGap = false;
                        break;
                    }
                }
            }
            else {
                if (bitmap[i][minY] || bitmap[i][maxY]) {
                    hasGap = false;
                    break;
                }
            }
        }
        return hasGap;
    };
    Greedy.prototype.fillGap = function (bbox) {
        var bitmap = this.bitmap;
        var minX = Math.round(bbox.minX);
        var maxX = Math.round(bbox.maxX);
        var minY = Math.round(bbox.minY);
        var maxY = Math.round(bbox.maxY);
        // filling grid
        for (var i = minX; i <= maxX; i += 1) {
            if (!bitmap[i]) {
                bitmap[i] = {};
            }
        }
        for (var i = minX; i <= maxX; i += this.xGap) {
            for (var j = minY; j <= maxY; j += this.yGap) {
                bitmap[i][j] = true;
            }
            bitmap[i][maxY] = true;
        }
        // filling y edges
        if (this.yGap !== 1) {
            for (var i = minY; i <= maxY; i += 1) {
                bitmap[minX][i] = true;
                bitmap[maxX][i] = true;
            }
        }
        // filling x edges
        if (this.xGap !== 1) {
            for (var i = minX; i <= maxX; i += 1) {
                bitmap[i][minY] = true;
                bitmap[i][maxY] = true;
            }
        }
    };
    Greedy.prototype.destroy = function () {
        this.bitmap = {};
    };
    return Greedy;
}());
export default Greedy;
//# sourceMappingURL=greedy.js.map