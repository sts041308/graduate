import { __assign, __extends } from "tslib";
import * as domUtil from '@antv/dom-util';
import * as Util from '@antv/util';
import Guide from '../base';
import bboxAdjust from './adjust/bbox';
import positionAdjust from './adjust/position';
import spirialAdjust from './adjust/spiral';
var LAYOUTS = {
    scatter: positionAdjust,
    map: spirialAdjust,
    treemap: bboxAdjust,
};
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label(cfg) {
        return _super.call(this, __assign({ name: 'label', type: 'default', 
            // html 渲染时用的容器的模板，必须存在 class = "g-labels"
            containerTpl: '<div class="g-labels" style="position:absolute;top:0;left:0;"></div>', 
            // html 渲染时单个 label 的模板，必须存在 class = "g-label"
            itemTpl: '<div class="g-label" style="position:absolute;">{text}</div>', items: null, lineGroup: null, shapes: null, useHtml: false }, cfg)) || this;
    }
    /**
     * label绘制全过程
     */
    Label.prototype.render = function () {
        this.clear();
        this._init();
        this.emit('beforerender');
        this.draw();
        this.emit('afterrender');
    };
    /**
     * 更新 label
     * 1. 将items与group中的children对比，更新/新增/删除labels
     * 2. labels布局优化
     * 3. 画label连接线
     * 4. 绘制到画布
     */
    Label.prototype.draw = function (canvasDraw) {
        if (canvasDraw === void 0) { canvasDraw = true; }
        this._dryDraw();
        canvasDraw && this.get('canvas').draw();
    };
    /*
     * 清空label容器
     */
    Label.prototype.clear = function () {
        var group = this.get('group');
        var container = this.get('container');
        if (group && !group.destroyed) {
            group.clear();
        }
        if (container) {
            container.innerHTML = '';
        }
    };
    /**
     * 销毁group
     */
    Label.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        var group = this.get('group');
        var container = this.get('container');
        if (group && !group.destroyed) {
            group.destroy();
        }
        if (container) {
            container.innerHTML = '';
        }
    };
    /*
     * 更新label
     * oldLabel shape或label dom
     * newLabel label data
     * index items中的下标
     */
    Label.prototype.changeLabel = function (oldLabel, newLabel) {
        if (!oldLabel) {
            return;
        }
        if (oldLabel.tagName) {
            var node = this._createDom(newLabel);
            oldLabel.innerHTML = node.innerHTML;
            this._setCustomPosition(newLabel, oldLabel);
        }
        else {
            oldLabel.id = newLabel.id;
            oldLabel.attr('text', newLabel.text);
            if (oldLabel.attr('x') !== newLabel.x || oldLabel.attr('y') !== newLabel.y) {
                oldLabel.resetMatrix();
                if (newLabel.textStyle.rotate) {
                    oldLabel.rotateAtStart(newLabel.textStyle.rotate);
                    delete newLabel.textStyle.rotate;
                }
                oldLabel.attr(newLabel);
            }
        }
    };
    /**
     * 显示label
     */
    Label.prototype.show = function () {
        var group = this.get('group');
        var container = this.get('container');
        if (group) {
            group.show();
        }
        if (container) {
            container.style.opacity = 1;
        }
    };
    /**
     * 隐藏label
     */
    Label.prototype.hide = function () {
        var group = this.get('group');
        var container = this.get('container');
        if (group) {
            group.hide();
        }
        if (container) {
            container.style.opacity = 0;
        }
    };
    /**
     * 画label连接线
     */
    Label.prototype.drawLines = function () {
        var _this = this;
        var lineGroup = this.get('lineGroup');
        if (!lineGroup || lineGroup.destroyed) {
            lineGroup = this.get('group').addGroup();
            this.set('lineGroup', lineGroup);
        }
        else {
            lineGroup.clear();
        }
        Util.each(this.get('items'), function (label) {
            _this._lineToLabel(label, lineGroup);
        });
    };
    Label.prototype._lineToLabel = function (label, lineGroup) {
        if (!label.labelLine) {
            // labelLine: null | false，关闭 label 对应的 labelLine
            return;
        }
        var lineStyle = Util.isBoolean(label.labelLine) ? {} : label.labelLine; // 兼容 labelLine: true，此时使用默认的样式
        var capture = typeof label.capture === 'undefined' ? this.get('capture') : label.capture;
        var path = lineStyle.path;
        if (path && Util.isFunction(lineStyle.path)) {
            path = lineStyle.path(label);
        }
        if (!path) {
            var start = label.start;
            path = [['M', start.x, start.y], ['L', label.x, label.y]];
        }
        var stroke = label.color;
        if (!stroke) {
            if (label.textStyle && label.textStyle.fill) {
                stroke = label.textStyle.fill;
            }
            else {
                stroke = '#000';
            }
        }
        var lineShape = lineGroup.addShape('path', {
            capture: capture,
            attrs: Util.mix({
                path: path,
                stroke: stroke,
                fill: null,
            }, lineStyle),
        });
        // label 对应线的动画关闭
        lineShape.name = this.get('name');
        // generate labelLine id according to label id
        lineShape.id = label.id && label.id.replace('glabel', 'glabelline');
        lineShape.set('coord', this.get('coord'));
    };
    // 根据type对label布局
    Label.prototype._adjustLabels = function () {
        var type = this.get('type');
        var labels = this.getLabels();
        var shapes = this.get('shapes');
        var layout = LAYOUTS[type];
        if (!layout) {
            return;
        }
        layout(labels, shapes);
    };
    /**
     * 获取当前所有label实例
     * @return {Array} 当前label实例
     */
    Label.prototype.getLabels = function () {
        var container = this.get('container');
        if (container) {
            return Util.toArray(container.childNodes);
        }
        var children = this.get('group').get('children');
        return Util.filter(children, function (child) { return child.isShape; });
    };
    // 分html dom和G shape两种情况生成label实例
    Label.prototype._createText = function (oldcfg) {
        var cfg = oldcfg;
        var container = this.get('container');
        var capture = typeof cfg.capture === 'undefined' ? this.get('capture') : cfg.capture;
        var labelShape;
        if (cfg.useHtml || cfg.htmlTemplate) {
            if (!container) {
                container = this._initHtmlContainer();
            }
            var node = this._createDom(cfg);
            container.appendChild(node);
            this._setCustomPosition(cfg, node);
        }
        else {
            var name_1 = this.get('name');
            var origin_1 = cfg.origin;
            var group = this.get('group');
            delete cfg.origin; // 临时解决，否则影响动画
            var rotate = cfg.rotate;
            // textStyle中的rotate虽然可以正常画出，但是在做动画的时候可能会导致动画异常。移出，在定义好shape后通过transform实现效果。
            if (cfg.textStyle) {
                if (cfg.textStyle.rotate) {
                    rotate = cfg.textStyle.rotate;
                    delete cfg.textStyle.rotate;
                }
                cfg = Util.mix({
                    x: cfg.x,
                    y: cfg.y,
                    textAlign: cfg.textAlign,
                    text: cfg.text,
                }, cfg.textStyle);
            }
            labelShape = group.addShape('text', {
                capture: capture,
                attrs: cfg,
            });
            if (rotate) {
                // rotate是用角度定义的，转换为弧度
                if (Math.abs(rotate) > Math.PI * 2) {
                    rotate = (rotate / 180) * Math.PI;
                }
                labelShape.transform([['t', -cfg.x, -cfg.y], ['r', rotate], ['t', cfg.x, cfg.y]]);
            }
            labelShape.setSilent('origin', origin_1 || cfg);
            labelShape.name = name_1; // 用于事件标注
            this.get('appendInfo') && labelShape.setSilent('appendInfo', this.get('appendInfo'));
            return labelShape;
        }
    };
    Label.prototype._initHtmlContainer = function () {
        var container = this.get('container');
        if (!container) {
            var containerTpl = this.get('containerTpl');
            var wrapper = this.get('canvas').get('el').parentNode;
            container = domUtil.createDom(containerTpl);
            wrapper.style.position = 'relative';
            wrapper.appendChild(container);
            this.set('container', container);
        }
        return container;
    };
    Label.prototype._createDom = function (cfg) {
        var itemTpl = this.get('itemTpl');
        var str = Util.substitute(itemTpl, { text: cfg.text });
        return domUtil.createDom(str);
    };
    // 根据文本对齐方式确定dom位置
    Label.prototype._setCustomPosition = function (cfg, htmlDom) {
        var textAlign = cfg.textAlign || 'left';
        var top = cfg.y;
        var left = cfg.x;
        var width = domUtil.getOuterWidth(htmlDom);
        var height = domUtil.getOuterHeight(htmlDom);
        top = top - height / 2;
        if (textAlign === 'center') {
            left = left - width / 2;
        }
        else if (textAlign === 'right') {
            left = left - width;
        }
        htmlDom.style.top = parseInt(top, 10) + "px";
        htmlDom.style.left = parseInt(left, 10) + "px";
    };
    // label 容器初始化
    Label.prototype._init = function () {
        if (!this.get('group')) {
            var group = this.get('canvas').addGroup({
                id: 'label-group',
            });
            this.set('group', group);
        }
    };
    Label.prototype._dryDraw = function () {
        var _this = this;
        var items = this.get('items');
        var children = this.getLabels();
        var count = children.length;
        Util.each(items, function (item, index) {
            if (index < count) {
                var label = children[index];
                _this.changeLabel(label, item);
            }
            else {
                var labelShape = _this._createText(item);
                if (labelShape) {
                    labelShape.id = item.id;
                    labelShape.set('coord', item.coord);
                }
            }
        });
        for (var i = count - 1; i >= items.length; i -= 1) {
            children[i].remove();
        }
        this._adjustLabels();
        this.drawLines();
    };
    return Label;
}(Guide));
export default Label;
//# sourceMappingURL=base.js.map