"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var domUtil = require("@antv/dom-util");
var g_1 = require("@antv/g");
var _ = require("@antv/util");
var style_1 = require("./style");
var ScrollBar = /** @class */ (function (_super) {
    tslib_1.__extends(ScrollBar, _super);
    function ScrollBar(scrollBarCfg) {
        var _this = _super.call(this) || this;
        // 通过拖拽开始的事件是 mousedown 还是 touchstart 来决定是移动端还是 pc 端
        _this._isMobile = false;
        _this._onStartEvent = function (isMobile) { return function (e) {
            _this._isMobile = isMobile;
            // 阻止冒泡
            e.event.preventDefault();
            var event = _this._isMobile ? _.get(e.event, 'touches.0', e) : e;
            var clientX = event.clientX, clientY = event.clientY;
            // 将开始的点记录下来
            _this._startPos = _this.isHorizontal ? clientX : clientY;
            _this._bindLaterEvent();
        }; };
        // 点击滑道的事件回调,移动滑块位置
        _this._onTrackClick = function (e) {
            var containerDOM = _this.get('canvas').get('containerDOM');
            var rect = containerDOM.getBoundingClientRect();
            var clientX = e.clientX, clientY = e.clientY;
            var offset = _this.isHorizontal
                ? clientX - rect.left - _this.position.x - _this.thumbLen / 2
                : clientY - rect.top - _this.position.y - _this.thumbLen / 2;
            var newOffset = _this._validateRange(offset);
            _this.updateThumbOffset(newOffset);
        };
        // 拖拽滑块的事件回调
        // 这里是 dom 原生事件，绑定在 dom 元素上的
        _this._onMouseMove = function (e) {
            e.preventDefault();
            var event = _this._isMobile ? _.get(e, 'touches.0', e) : e;
            var clientX = event.clientX;
            var clientY = event.clientY;
            // 鼠标松开的位置
            var endPos = _this.isHorizontal ? clientX : clientY;
            // 滑块需要移动的距离, 由于这里是对滑块监听，所以移动的距离就是 diffDis, 如果监听对象是 container dom，则需要算比例
            var diff = endPos - _this._startPos;
            // 更新 _startPos
            _this._startPos = endPos;
            _this.updateThumbOffset(_this.thumbOffset + diff);
        };
        // 滑块鼠标松开事件回调
        _this._onMouseUp = function (e) {
            // 松开鼠标时，清除所有事件
            e.preventDefault();
            _this._clearEvents();
        };
        _this._onTrackMouseOver = function (e) {
            var thumbColor = _this.theme.hover.thumbColor;
            _this.thumbShape.attr('stroke', thumbColor);
            _this.get('canvas').draw();
        };
        _this._onTrackMouseOut = function (e) {
            var thumbColor = _this.theme.default.thumbColor;
            _this.thumbShape.attr('stroke', thumbColor);
            _this.get('canvas').draw();
        };
        var _a = scrollBarCfg.isHorizontal, isHorizontal = _a === void 0 ? false : _a, trackLen = scrollBarCfg.trackLen, thumbLen = scrollBarCfg.thumbLen, position = scrollBarCfg.position, _b = scrollBarCfg.minThumbLen, minThumbLen = _b === void 0 ? 20 : _b, _c = scrollBarCfg.thumbOffset, thumbOffset = _c === void 0 ? 0 : _c, theme = scrollBarCfg.theme;
        _this.isHorizontal = isHorizontal;
        _this.thumbOffset = thumbOffset;
        _this.trackLen = trackLen;
        _this.thumbLen = thumbLen;
        _this.position = position;
        _this.minThumbLen = minThumbLen;
        _this.theme = _.deepMix({}, style_1.DEFAULT_THEME, theme);
        _this._initScrollBar();
        return _this;
    }
    /**
     * 当前滑块滑动的位置 0 ~ 1
     */
    ScrollBar.prototype.current = function () {
        var thumbRate = this.thumbLen / this.trackLen;
        var offsetRate = this.thumbOffset / this.trackLen;
        return offsetRate / (1 - thumbRate);
    };
    /**
     * 更新滑道长度
     * @param newTrackLen 新的滑块长度
     */
    ScrollBar.prototype.updateTrackLen = function (newTrackLen) {
        // 如果更新后的 trackLen 没改变，无需执行后续逻辑
        if (this.trackLen === newTrackLen) {
            return;
        }
        // 更新滑道长度的时候，同时按比例更新滑块长度和 offset(增大视窗或者减小视窗的场景))
        var thumbRate = this.thumbLen / this.trackLen;
        var offsetRate = this.thumbOffset / this.trackLen;
        var newThumbLen = newTrackLen * thumbRate;
        var newOffset = newTrackLen * offsetRate;
        this.trackLen = newTrackLen;
        if (this.isHorizontal) {
            this.trackShape.attr('x2', newTrackLen);
        }
        else {
            this.trackShape.attr('y2', newTrackLen);
        }
        this.updateThumbLen(newThumbLen);
        this.updateThumbOffset(newOffset);
        this._renderNewScrollBar();
    };
    /**
     * 更新滑块长度
     * @param newThumbLen 新的滑道长度
     */
    ScrollBar.prototype.updateThumbLen = function (newThumbLen) {
        // 如果更新后的 thumbLen 没改变，无需执行后续逻辑
        if (this.thumbLen === newThumbLen) {
            return;
        }
        this.thumbLen = newThumbLen;
        if (this.isHorizontal) {
            this.thumbShape.attr('x2', this.thumbOffset + newThumbLen);
        }
        else {
            this.thumbShape.attr('y2', this.thumbOffset + newThumbLen);
        }
        this._renderNewScrollBar();
    };
    /**
     * 更新滑块的 offset 值
     * @param offset
     */
    ScrollBar.prototype.updateThumbOffset = function (offset) {
        var newOffset = this._validateRange(offset);
        // 如果更新后的 offset 与原值相同，则不改变
        if (this.thumbOffset === newOffset) {
            return;
        }
        this.thumbOffset = newOffset;
        if (this.isHorizontal) {
            this.thumbShape.attr({
                x1: newOffset,
                x2: newOffset + this.thumbLen,
            });
        }
        else {
            this.thumbShape.attr({
                y1: newOffset,
                y2: newOffset + this.thumbLen,
            });
        }
        this._renderNewScrollBar();
    };
    /**
     * 更新滑道位置
     * @param newPos 新的滑块位置
     */
    ScrollBar.prototype.updateScrollBarPos = function (newPos) {
        if (newPos.x === this.position.x && newPos.y === this.position.y) {
            return;
        }
        this.position = newPos;
        this.scrollBarGroup.move(newPos.x, newPos.y);
        this._renderNewScrollBar();
    };
    // 绘制新的 scrollBar
    ScrollBar.prototype._renderNewScrollBar = function () {
        // 发送事件
        this.emit('scrollchange', {
            thumbOffset: this.thumbOffset,
            ratio: _.clamp(this.thumbOffset / (this.trackLen - this.thumbLen), 0, 1),
        });
        // 渲染
        if (this.get('canvas')) {
            this.get('canvas').draw();
        }
    };
    ScrollBar.prototype.updateTheme = function (theme) {
        this.theme = _.deepMix({}, style_1.DEFAULT_THEME, theme);
        this.thumbShape.attr('stroke', this.theme.default.thumbColor);
        this.thumbShape.attr('lineWidth', this.theme.default.size);
        this.thumbShape.attr('lineCap', this.theme.default.lineCap);
        this.get('canvas').draw();
    };
    // 初始化 scrollBar
    ScrollBar.prototype._initScrollBar = function () {
        this.scrollBarGroup = this._createScrollBarGroup();
        this.scrollBarGroup.move(this.position.x, this.position.y);
        // 绑定事件
        this._bindEvents();
    };
    // 创建 scrollBar 的 group
    ScrollBar.prototype._createScrollBarGroup = function () {
        var group = this.addGroup({ className: this.isHorizontal ? 'horizontalBar' : 'verticalBar' });
        this.trackShape = this._createTrackShape(group);
        this.thumbShape = this._createThumbShape(group);
        return group;
    };
    // 创建滑道的 shape
    ScrollBar.prototype._createTrackShape = function (group) {
        var _a = this.theme.default, lineCap = _a.lineCap, trackColor = _a.trackColor, size = _a.size;
        if (this.isHorizontal) {
            return group.addShape('line', {
                attrs: {
                    x1: 0,
                    y1: size / 2,
                    x2: this.trackLen,
                    y2: size / 2,
                    lineWidth: size,
                    stroke: trackColor,
                    lineCap: lineCap,
                },
            });
        }
        return group.addShape('line', {
            attrs: {
                x1: size / 2,
                y1: 0,
                x2: size / 2,
                y2: this.trackLen,
                lineWidth: size,
                stroke: trackColor,
                lineCap: lineCap,
            },
        });
    };
    // 创建滑块的 shape
    ScrollBar.prototype._createThumbShape = function (group) {
        var _a = this.theme.default, size = _a.size, lineCap = _a.lineCap, thumbColor = _a.thumbColor;
        if (this.isHorizontal) {
            return group.addShape('line', {
                attrs: {
                    x1: this.thumbOffset,
                    y1: size / 2,
                    x2: this.thumbOffset + this.thumbLen,
                    y2: size / 2,
                    lineWidth: size,
                    stroke: thumbColor,
                    lineCap: lineCap,
                    cursor: 'default',
                },
            });
        }
        return group.addShape('line', {
            attrs: {
                x1: size / 2,
                y1: this.thumbOffset,
                x2: size / 2,
                y2: this.thumbOffset + this.thumbLen,
                lineWidth: size,
                stroke: thumbColor,
                lineCap: lineCap,
                cursor: 'default',
            },
        });
    };
    // 事件绑定
    ScrollBar.prototype._bindEvents = function () {
        this.on('mousedown', this._onStartEvent(false));
        // 因为上层交叉表交互 prevent 事件，导致 containerDOM 上的 mouseup 事件没有执行，
        // 整个拖拽过程没有 cancel 掉。
        this.on('mouseup', this._onMouseUp);
        this.on('touchstart', this._onStartEvent(true));
        this.on('touchend', this._onMouseUp);
        this.trackShape.on('click', this._onTrackClick);
        this.thumbShape.on('mouseover', this._onTrackMouseOver);
        this.thumbShape.on('mouseout', this._onTrackMouseOut);
    };
    ScrollBar.prototype._bindLaterEvent = function () {
        var containerDOM = this.get('canvas').get('containerDOM');
        var events = [];
        if (this._isMobile) {
            events = [
                domUtil.addEventListener(containerDOM, 'touchmove', this._onMouseMove),
                domUtil.addEventListener(containerDOM, 'touchend', this._onMouseUp),
                domUtil.addEventListener(containerDOM, 'touchcancel', this._onMouseUp),
            ];
        }
        else {
            events = [
                domUtil.addEventListener(containerDOM, 'mousemove', this._onMouseMove),
                domUtil.addEventListener(containerDOM, 'mouseup', this._onMouseUp),
                // 为了保证划出 canvas containerDom 时还没触发 mouseup
                domUtil.addEventListener(containerDOM, 'mouseleave', this._onMouseUp),
            ];
        }
        this._clearEvents = function () {
            events.forEach(function (e) {
                e.remove();
            });
        };
    };
    // 判断滑块位置是否超出滑道区域
    ScrollBar.prototype._validateRange = function (offset) {
        var newOffset = offset;
        if (offset + this.thumbLen > this.trackLen) {
            newOffset = this.trackLen - this.thumbLen;
        }
        else if (offset + this.thumbLen < this.thumbLen) {
            newOffset = 0;
        }
        return newOffset;
    };
    return ScrollBar;
}(g_1.Group));
exports.default = ScrollBar;
//# sourceMappingURL=index.js.map