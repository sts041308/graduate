"use strict";
/**
 * @file 基于 G 的缩略轴组件（Slider 组件）
 * @author hustcc
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var g_1 = require("@antv/g");
var _ = require("@antv/util");
var trend_1 = require("../trend");
var constant_1 = require("./constant");
var handler_1 = require("./handler");
/**
 * 缩略轴组件
 * 设计稿：https://yuque.antfin-inc.com/antv/cfksca/432935?artboard_type=artboard&view=&from=#comment-518267
 */
var Slider = /** @class */ (function (_super) {
    tslib_1.__extends(Slider, _super);
    function Slider(cfg) {
        var _this = _super.call(this) || this;
        _this.prevX = 0;
        _this.prevY = 0;
        _this.onMouseDown = function (handler) { return function (e) {
            // 1. 记录点击的滑块
            _this.currentHandler = handler;
            // 2. 存储当前点击位置
            var event = e.event;
            event.stopPropagation();
            event.preventDefault();
            // 兼容移动端获取数据
            _this.prevX = _.get(event, 'touches.0.pageX', event.pageX);
            _this.prevY = _.get(event, 'touches.0.pageY', event.pageY);
            // 3. 开始滑动的时候，绑定 move 和 up 事件
            var containerDOM = _this.get('canvas').get('containerDOM');
            containerDOM.addEventListener('mousemove', _this.onMouseMove);
            containerDOM.addEventListener('mouseup', _this.onMouseUp);
            containerDOM.addEventListener('mouseleave', _this.onMouseUp);
            // 移动端事件
            containerDOM.addEventListener('touchmove', _this.onMouseMove);
            containerDOM.addEventListener('touchend', _this.onMouseUp);
            containerDOM.addEventListener('touchcancel', _this.onMouseUp);
        }; };
        _this.onMouseMove = function (e) {
            // 滑动过程中，计算偏移，更新滑块，然后 emit 数据出去
            e.stopPropagation();
            e.preventDefault();
            var x = _.get(e, 'touches.0.pageX', e.pageX);
            var y = _.get(e, 'touches.0.pageY', e.pageY);
            // 横向的 slider 只处理 x
            var offsetX = x - _this.prevX;
            var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);
            // 更新 start end range 范围
            _this.updateStartEnd(offsetXRange);
            // 更新 ui
            _this._updateUI();
            _this.prevX = x;
            _this.prevY = y;
            _this.get('canvas').draw();
            // 因为存储的 start、end 可能不一定是按大小存储的，所以排序一下，对外是 end >= start
            _this.emit(constant_1.SLIDER_CHANGE, [_this.start, _this.end].sort());
        };
        _this.onMouseUp = function () {
            // 结束之后，取消绑定的事件
            if (_this.currentHandler) {
                _this.currentHandler = undefined;
            }
            var containerDOM = _this.get('canvas').get('containerDOM');
            if (containerDOM) {
                containerDOM.removeEventListener('mousemove', _this.onMouseMove);
                containerDOM.removeEventListener('mouseup', _this.onMouseUp);
                // 防止滑动到 canvas 外部之后，状态丢失
                containerDOM.removeEventListener('mouseleave', _this.onMouseUp);
                // 移动端事件
                containerDOM.removeEventListener('touchmove', _this.onMouseMove);
                containerDOM.removeEventListener('touchend', _this.onMouseUp);
                containerDOM.removeEventListener('touchcancel', _this.onMouseUp);
            }
        };
        var _a = cfg.x, x = _a === void 0 ? 0 : _a, _b = cfg.y, y = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 100 : _c, _d = cfg.height, height = _d === void 0 ? 16 : _d, trendCfg = cfg.trendCfg, _e = cfg.backgroundStyle, backgroundStyle = _e === void 0 ? {} : _e, _f = cfg.foregroundStyle, foregroundStyle = _f === void 0 ? {} : _f, _g = cfg.handlerStyle, handlerStyle = _g === void 0 ? {} : _g, _h = cfg.textStyle, textStyle = _h === void 0 ? {} : _h, 
        // 缩略轴的初始位置
        _j = cfg.start, 
        // 缩略轴的初始位置
        start = _j === void 0 ? 0 : _j, _k = cfg.end, end = _k === void 0 ? 1 : _k, _l = cfg.minText, minText = _l === void 0 ? '' : _l, _m = cfg.maxText, maxText = _m === void 0 ? '' : _m;
        // position size
        _this.x = x;
        _this.y = y;
        _this.width = width;
        _this.height = height;
        _this.trendCfg = trendCfg;
        // style
        _this.backgroundStyle = tslib_1.__assign(tslib_1.__assign({}, constant_1.BACKGROUND_STYLE), backgroundStyle);
        _this.foregroundStyle = tslib_1.__assign(tslib_1.__assign({}, constant_1.FOREGROUND_STYLE), foregroundStyle);
        _this.handlerStyle = tslib_1.__assign(tslib_1.__assign({}, constant_1.HANDLER_STYLE), handlerStyle);
        _this.textStyle = tslib_1.__assign(tslib_1.__assign({}, constant_1.TEXT_STYLE), textStyle);
        // 初始信息
        _this.start = start;
        _this.end = end;
        _this.minText = minText;
        _this.maxText = maxText;
        _this._initial();
        return _this;
    }
    /**
     * 更新配置
     * @param cfg
     */
    Slider.prototype.update = function (cfg) {
        var x = cfg.x, y = cfg.y, width = cfg.width, height = cfg.height, minText = cfg.minText, maxText = cfg.maxText, start = cfg.start, end = cfg.end;
        // start、end 只能是 0~1 范围
        this.start = Math.min(1, Math.max(start, 0));
        this.end = Math.min(1, Math.max(end, 0));
        // 如果传了则更新，没有传则不更新
        // @ts-ignore
        _.assign(this, {
            x: x,
            y: y,
            width: width,
            height: height,
            minText: minText,
            maxText: maxText,
        });
        // 更新 ui，不自动绘制
        this._updateUI();
    };
    /**
     * 初始化组件结构
     * @private
     */
    Slider.prototype._initial = function () {
        var width = this.width;
        var height = this.height;
        // 趋势图数据
        if (_.size(_.get(this.trendCfg, 'data'))) {
            this.trendShape = new trend_1.default(tslib_1.__assign({ x: 0, y: 0, width: width,
                height: height }, this.trendCfg));
            this.add(this.trendShape);
        }
        // 1. 背景
        this.backgroundShape = this.addShape('rect', {
            attrs: tslib_1.__assign({ x: 0, y: 0, width: width,
                height: height }, this.backgroundStyle),
        });
        // 2. 左右文字
        this.minTextShape = this.addShape('text', {
            attrs: tslib_1.__assign({ 
                // x: 0,
                y: height / 2, textAlign: 'right', text: this.minText, silent: false }, this.textStyle),
        });
        this.maxTextShape = this.addShape('text', {
            attrs: tslib_1.__assign({ 
                // x: 0,
                y: height / 2, textAlign: 'left', text: this.maxText, silent: false }, this.textStyle),
        });
        // 3. 前景 选中背景框
        this.foregroundShape = this.addShape('rect', {
            attrs: tslib_1.__assign({ 
                // x: 0,
                y: 0, 
                // width: 0,
                height: height }, this.foregroundStyle),
        });
        // 滑块相关的大小信息
        var handlerWidth = _.get(this.handlerStyle, 'width', 10);
        var handlerHeight = _.get(this.handlerStyle, 'height', 24);
        // 4. 左右滑块
        this.minHandlerShape = new handler_1.default(tslib_1.__assign({ x: 0, y: (height - handlerHeight) / 2, width: width, height: handlerHeight, cursor: 'ew-resize' }, this.handlerStyle));
        this.add(this.minHandlerShape);
        this.maxHandlerShape = new handler_1.default(tslib_1.__assign({ x: 0, y: (height - handlerHeight) / 2, width: width, height: handlerHeight, cursor: 'ew-resize' }, this.handlerStyle));
        this.add(this.maxHandlerShape);
        // 根据 start end 更新 ui 的位置信息
        this._updateUI();
        // 移动到对应的位置
        this.move(this.x, this.y);
        // 绑定事件鼠标事件
        this._bindEvents();
    };
    /**
     * 绑定事件：
     *  - 点击
     *  - 滑动
     *  - 拖拽
     *  - 滚动
     * @private
     */
    Slider.prototype._bindEvents = function () {
        // 1. 左滑块的滑动
        this.minHandlerShape.on('mousedown', this.onMouseDown(this.minHandlerShape));
        this.minHandlerShape.on('touchstart', this.onMouseDown(this.minHandlerShape));
        // 2. 右滑块的滑动
        this.maxHandlerShape.on('mousedown', this.onMouseDown(this.maxHandlerShape));
        this.maxHandlerShape.on('touchstart', this.onMouseDown(this.maxHandlerShape));
        // 3. 前景选中区域
        this.foregroundShape.on('mousedown', this.onMouseDown(this.foregroundShape));
        this.foregroundShape.on('touchstart', this.onMouseDown(this.foregroundShape));
    };
    /**
     * 调整 offsetRange，因为一些范围的限制
     * @param offsetRange
     */
    Slider.prototype.adjustOffsetRange = function (offsetRange) {
        // 针对不同的滑动组件，处理的方式不同
        switch (this.currentHandler) {
            case this.minHandlerShape: {
                var min = 0 - this.start;
                var max = 1 - this.start;
                return Math.min(max, Math.max(min, offsetRange));
            }
            case this.maxHandlerShape: {
                var min = 0 - this.end;
                var max = 1 - this.end;
                return Math.min(max, Math.max(min, offsetRange));
            }
            case this.foregroundShape: {
                var min = 0 - this.start;
                var max = 1 - this.end;
                return Math.min(max, Math.max(min, offsetRange));
            }
            default:
                return 0;
        }
    };
    Slider.prototype.updateStartEnd = function (offsetRange) {
        // 操作不同的组件，反馈不一样
        switch (this.currentHandler) {
            case this.minHandlerShape:
                this.start += offsetRange;
                break;
            case this.maxHandlerShape:
                this.end += offsetRange;
                break;
            case this.foregroundShape:
                this.start += offsetRange;
                this.end += offsetRange;
                break;
        }
    };
    /**
     * 根据移动的比例来更新 ui
     * @private
     */
    Slider.prototype._updateUI = function () {
        var _this = this;
        var min = this.start * this.width;
        var max = this.end * this.width;
        // 1. foreground
        this.foregroundShape.attr('x', min);
        this.foregroundShape.attr('width', max - min);
        // 滑块相关的大小信息
        var handlerWidth = _.get(this.handlerStyle, 'width', constant_1.DEFAULT_HANDLER_WIDTH);
        // 设置文本
        this.minTextShape.attr('text', this.minText);
        this.maxTextShape.attr('text', this.maxText);
        var _a = this._dodgeText([min, max]), minAttrs = _a[0], maxAttrs = _a[1];
        // 2. 左侧滑块和文字位置
        this.minHandlerShape.setX(min - handlerWidth / 2);
        // this.minText.attr('x', min);
        _.each(minAttrs, function (v, k) { return _this.minTextShape.attr(k, v); });
        // 3. 右侧滑块和文字位置
        this.maxHandlerShape.setX(max - handlerWidth / 2);
        // this.maxText.attr('x', max);
        _.each(maxAttrs, function (v, k) { return _this.maxTextShape.attr(k, v); });
    };
    /**
     * 调整 text 的位置，自动躲避
     * 根据位置，调整返回新的位置
     * @param range
     */
    Slider.prototype._dodgeText = function (range) {
        var _a, _b;
        var PADDING = 2;
        var handlerWidth = _.get(this.handlerStyle, 'width', constant_1.DEFAULT_HANDLER_WIDTH);
        var minTextShape = this.minTextShape;
        var maxTextShape = this.maxTextShape;
        var min = range[0], max = range[1];
        var sorted = false;
        // 如果交换了位置，则对应的 min max 也交互
        if (min > max) {
            _a = [max, min], min = _a[0], max = _a[1];
            _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
            sorted = true;
        }
        // 避让规则，优先显示在两侧，只有显示不下的时候，才显示在中间
        var minBBox = minTextShape.getBBox();
        var maxBBox = maxTextShape.getBBox();
        var minAttrs = minBBox.width > min - PADDING
            ? { x: min + handlerWidth / 2 + PADDING, textAlign: 'left' }
            : { x: min - handlerWidth / 2 - PADDING, textAlign: 'right' };
        var maxAttrs = maxBBox.width > this.width - max - PADDING
            ? { x: max - handlerWidth / 2 - PADDING, textAlign: 'right' }
            : { x: max + handlerWidth / 2 + PADDING, textAlign: 'left' };
        return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    return Slider;
}(g_1.Group));
exports.default = Slider;
//# sourceMappingURL=index.js.map