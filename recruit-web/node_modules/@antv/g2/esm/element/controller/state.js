/**
 * @description Element 上响应 shape 状态的改变
 */
import * as _ from '@antv/util';
var FIELD_ORIGIN = '_origin';
// 通过 shape 上的原始数据来判断两个 shape 是否相同
function _isSameShape(shape1, shape2) {
    if (_.isNil(shape1) || _.isNil(shape2)) {
        return false;
    }
    var shape1Origin = shape1.get('origin');
    var shape2Origin = shape2.get('origin');
    return _.isEqual(shape1Origin, shape2Origin);
}
function isChange(preShapes, shapes) {
    if (!preShapes) {
        return true;
    }
    if (preShapes.length !== shapes.length) {
        return true;
    }
    var rst = false;
    _.each(shapes, function (shape, index) {
        if (!_isSameShape(shape, preShapes[index])) {
            rst = true;
            return false;
        }
    });
    return rst;
}
function getOriginAttrs(modifiedAttrs, originAttrs) {
    var result = {};
    _.each(modifiedAttrs, function (v, k) {
        var originValue = originAttrs[k];
        if (_.isArray(originValue)) {
            originValue = originValue.concat(); // 缓存原来的属性，由于 .attr('matrix') 是数组，所以此处需要深度复制
        }
        result[k] = originValue;
    });
    return result;
}
var StateController = /** @class */ (function () {
    function StateController(element) {
        this.element = null;
        this._activeShapes = null;
        this._selectedShapes = null;
        this._inactiveShapes = null;
        this.element = element;
    }
    StateController.prototype.bind = function () {
        var element = this.element;
        var view = element.get('view');
        view.on('active:change', _.wrapBehavior(this, '_onActive'));
        view.on('selected:change', _.wrapBehavior(this, '_onSelected'));
        view.on('inactive:change', _.wrapBehavior(this, '_onInactive'));
    };
    StateController.prototype.unbind = function () {
        var element = this.element;
        var view = element.get('view');
        view.off('active:change', _.getWrapBehavior(this, '_onActive'));
        view.off('selected:change', _.getWrapBehavior(this, '_onSelected'));
        view.off('inactive:change', _.getWrapBehavior(this, '_onInactive'));
    };
    StateController.prototype._onActive = function (activeObject) {
        var _this = this;
        var element = this.element;
        var activeOptions = element.get('activeOptions');
        if (activeOptions === false) { // element.active(false); 不允许 active
            return;
        }
        var shapeContainer = element.get('shapeContainer');
        var exp = activeObject.exp, draw = activeObject.draw;
        var activeShapes = this._filterShapes(exp);
        // 判断是否同上一次 activeShapes 相同，相同则不需要处理
        var preActiveShapes = this._activeShapes;
        if (!isChange(preActiveShapes, activeShapes)) {
            return;
        }
        if (preActiveShapes) {
            this._clearActiveShapes();
        }
        this._clearInactiveShapes(); // active 和 inactive 互斥，故需要清空
        activeShapes.forEach(function (activeShape) {
            if (activeShape.get('animating')) {
                activeShape.stopAnimate();
            }
            _this._setShapeActive(activeShape);
        });
        this._activeShapes = activeShapes;
        shapeContainer.sort();
        draw && this._draw();
    };
    // 清空原先 active 状态的 shapes
    StateController.prototype._clearActiveShapes = function () {
        var shapes = this._activeShapes;
        _.each(shapes, function (shape) {
            var originAttrs = shape.get('_beforeActiveAttrs');
            shape.attr(originAttrs);
            shape.setZIndex(0);
            shape.set('_beforeActiveAttrs', null);
        });
        // 恢复原来排序
        var shapeContainer = this.element.get('shapeContainer');
        var children = shapeContainer.get('children');
        children.sort(function (obj1, obj2) {
            return obj1._INDEX - obj2._INDEX;
        });
        this._activeShapes = null;
    };
    StateController.prototype._setShapeActive = function (shape) {
        var activeStyle = this._getShapeStyleByState(shape, 'active');
        // active 是基于当前 shape 的样式进行变化
        var originAttrs = getOriginAttrs(activeStyle, shape.attr());
        shape.setSilent('_beforeActiveAttrs', originAttrs);
        shape.attr(activeStyle);
        shape.setZIndex(1); // 将 activeShapes 图层提前
    };
    StateController.prototype._onSelected = function (selectedObj) {
        var _this = this;
        var selectedOptions = this.element.get('selectedOptions');
        if (selectedOptions === false) { // element.active(false); 不允许 active
            return;
        }
        var exp = selectedObj.exp, draw = selectedObj.draw;
        var selectedShapes = this._filterShapes(exp);
        // 判断是否同上一次 selectedShapes 相同，相同则不需要处理
        var preSelectedShapes = this._selectedShapes;
        if (!isChange(preSelectedShapes, selectedShapes)) {
            return;
        }
        if (preSelectedShapes) {
            this._clearSelectedShapes();
        }
        this._clearInactiveShapes(); // selected 和 inactive 互斥，故需要清空
        selectedShapes.forEach(function (shape) {
            if (shape.get('animating')) {
                shape.stopAnimate();
            }
            _this._setShapeSelected(shape);
        });
        this._selectedShapes = selectedShapes;
        draw && this._draw();
    };
    StateController.prototype._clearSelectedShapes = function () {
        var shapes = this._selectedShapes;
        _.each(shapes, function (shape) {
            shape.set('selected', false);
            if (!shape.get('inactive')) {
                var originAttrs = shape.get('_originAttrs');
                shape.attr(originAttrs);
                shape.set('_originAttrs', null);
            }
        });
        this._selectedShapes = null;
    };
    StateController.prototype._setShapeSelected = function (shape) {
        shape.set('selected', true);
        var selectedStyle = this._getShapeStyleByState(shape, 'selected');
        this._applyShapeStyle(shape, selectedStyle);
    };
    StateController.prototype._onInactive = function (inactiveObj) {
        var _this = this;
        var inactiveOptions = this.element.get('inactiveOptions');
        if (inactiveOptions === false) { // element.active(false); 不允许 active
            return;
        }
        var exp = inactiveObj.exp, draw = inactiveObj.draw;
        var inactiveShapes = this._filterShapes(exp);
        // 判断是否同上一次 _inactiveShapes 相同，相同则不需要处理
        var preinactiveShapes = this._inactiveShapes;
        if (!isChange(preinactiveShapes, inactiveShapes)) {
            return;
        }
        if (preinactiveShapes) {
            this._clearInactiveShapes();
        }
        inactiveShapes.forEach(function (shape) {
            if (shape.get('animating')) {
                shape.stopAnimate();
            }
            _this._setShapeInactive(shape);
        });
        this._inactiveShapes = inactiveShapes;
        draw && this._draw();
    };
    StateController.prototype._clearInactiveShapes = function () {
        var shapes = this._inactiveShapes;
        _.each(shapes, function (shape) {
            shape.set('inactive', false);
            if (!shape.get('selected')) {
                var originAttrs = shape.get('_originAttrs');
                shape.attr(originAttrs);
                shape.set('_originAttrs', null);
            }
        });
        this._inactiveShapes = null;
    };
    StateController.prototype._setShapeInactive = function (shape) {
        shape.set('inactive', true);
        var inactiveStyle = this._getShapeStyleByState(shape, 'inactive');
        this._applyShapeStyle(shape, inactiveStyle);
    };
    StateController.prototype._applyShapeStyle = function (shape, style) {
        // 基于 shape 的初始状态
        var originAttrs = shape.get('_originAttrs');
        if (originAttrs) {
            shape.attr(originAttrs);
        }
        originAttrs = getOriginAttrs(style, shape.attr());
        shape.setSilent('_originAttrs', originAttrs);
        shape.attr(style);
    };
    StateController.prototype._filterShapes = function (exp) {
        var element = this.element;
        var shapeContainer = element.get('shapeContainer');
        var shapes = shapeContainer.get('children');
        return _.filter(shapes, function (shape) {
            if (shape.get('origin') && shape.get('visible')) {
                var origin_1 = shape.get('origin');
                // line、area、path 这三种 element，shape 的 origin 存储的是整个序列的数据集合
                var data = _.isArray(origin_1) ? origin_1[0][FIELD_ORIGIN] : origin_1[FIELD_ORIGIN];
                return exp(data);
            }
        });
    };
    StateController.prototype._getShapeStyleByState = function (shape, state) {
        var element = this.element;
        var shapeData = shape.get('origin');
        var shapeName = shapeData.shape || element.getDefaultValue('shape');
        if (_.isArray(shapeName)) {
            shapeName = shapeName[0];
        }
        var shapeFactory = element.get('shapeFactory');
        var shapeStyle = _.mix({}, shape.attr(), {
            origin: shapeData,
        });
        if (state === 'active') {
            var activeOptions = element.get('activeOptions');
            var defaultActiveStyle = shapeFactory.getActiveStyle(shapeName, shapeStyle) || {};
            return _.mix(defaultActiveStyle, activeOptions);
        }
        if (state === 'selected') {
            var selectedOptions = element.get('selectedOptions');
            var defaultSelectedStyle = shapeFactory.getSelectedStyle(shapeName, shapeStyle) || {};
            return _.mix(defaultSelectedStyle, selectedOptions);
        }
        if (state === 'inactive') {
            var inactiveOptions = element.get('inactiveOptions');
            var defaultInactiveStyle = shapeFactory.getInactiveStyle(shapeName, shapeStyle) || {};
            return _.mix(defaultInactiveStyle, inactiveOptions);
        }
        return shapeStyle;
    };
    StateController.prototype._draw = function () {
        var canvas = this.element.get('canvas');
        // 防止因为 state 处理是异步的，在 dom 元素移除之后再处理
        if (!canvas)
            return;
        var drawTimer = canvas.get('_drawTimer');
        if (drawTimer) {
            clearTimeout(drawTimer);
            canvas.set('_drawTimer', null);
        }
        drawTimer = setTimeout(function () {
            canvas.draw();
        }, 16);
        canvas.set('_drawTimer', drawTimer);
    };
    return StateController;
}());
export default StateController;
//# sourceMappingURL=state.js.map