import { DataPointType } from '../interface';
export interface States {
    [key: string]: any;
}
declare type Position = 'top' | 'right' | 'bottom' | 'left' | 'left-top' | 'left-center' | 'left-bottom' | 'right-top' | 'right-center' | 'right-bottom' | 'top-left' | 'top-center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'bottom-right';
declare type Marker = 'circle' | 'square' | 'diamond' | 'triangle' | 'triangleDown' | 'hexagon' | 'bowtie' | 'cross' | 'tick' | 'plus' | 'hyphen' | 'line' | 'hollowCircle' | 'hollowSquare' | 'hollowDiamond' | 'hollowTriangle' | 'hollowTriangleDown' | 'hollowHexagon' | 'hollowBowtie';
declare type MarkerCallback = (x: number, y: number, r: number) => any[][];
interface MarkerCfg {
    symbol: Marker | MarkerCallback;
    fill?: string;
    stroke?: string;
    radius?: number;
}
interface CustomLegendItem {
    value: any;
    checked?: boolean;
    color?: string;
    marker: Marker | MarkerCfg;
}
declare type HtmlItemTpl = (value: string, color: string, checked: boolean, index: number) => string;
export interface LegendOption {
    layout?: 'horizontal' | 'vertical';
    showTitle?: boolean;
    titleStyle?: DataPointType;
    titleDistance?: number;
    formatter?: (val: any) => any;
    offsetX?: number;
    offsetY?: number;
    reversed?: boolean;
    backgroundStyle?: DataPointType;
    position?: Position;
    marker?: Marker | MarkerCallback;
    useHtml?: boolean;
    flipPage?: boolean;
    custom?: boolean;
    items?: CustomLegendItem[];
    onClick?: Function;
    onMouseover?: Function;
    onMouseleave?: Function;
    unSelectedColor?: string;
    clickable?: boolean;
    hoverable?: boolean;
    selectedMode?: 'single' | 'multiple';
    allowAllCanceled?: boolean;
    highlight?: boolean;
    itemDistance?: number;
    itemMarginBottom?: number;
    itemWidth?: number;
    textStyle?: DataPointType;
    wordSpacing?: number;
    autoWrap?: boolean;
    backgroundPadding?: number | number[];
    width?: number;
    height?: number;
    container?: string | HTMLElement;
    containerTpl?: string;
    itemTpl?: string | HtmlItemTpl;
    listStyle?: DataPointType;
    itemStyle?: DataPointType;
    markerStyle?: DataPointType;
    prefixClassName?: string;
    pagination?: object | false;
    handleIcon?: 'circle' | 'rect';
    handleSize?: [number, number];
    handleStyle?: DataPointType;
    fillStyle?: DataPointType;
    operational?: boolean;
    isSegment?: boolean;
}
export interface LegendsOption extends LegendOption {
    fields: {
        [field: string]: LegendOption | boolean;
    };
}
export interface ThemeOption {
    defaultColor?: string;
    fontFamily?: string;
    defaultLegendPosition: string;
    legend?: {
        [key: string]: any;
    };
    [key: string]: any;
}
export interface SubRegion {
    maxWidth: number;
    totalWidth: number;
    maxHeight: number;
    totalHeight: number;
}
export interface Region {
    totalWidth: number;
    totalHeight: number;
    subs: SubRegion[];
}
export declare type CoordinateType = 'polar' | 'theta' | 'rect' | 'cartesian' | 'helix' | 'geo';
export interface CoordinateCfg {
    startAngle?: number;
    endAngle?: number;
    radius?: number;
    innerRadius?: number;
    zoom?: number;
    center?: [number, number];
}
export interface CoordinateOption {
    type?: CoordinateType;
    cfg?: CoordinateCfg;
    actions?: any[][];
}
interface AxisLabelOption {
    offset?: number;
    offsetX?: number;
    offsetY?: number;
    rotate?: number;
    textStyle?: DataPointType;
    text?: string;
    useHtml?: boolean;
    htmlTemplate?: string;
}
declare type labelCallback = (text: string, index: number, total: number) => AxisLabelOption | null;
declare type gridCallback = (text: string, index: number, total: number) => DataPointType | null;
interface AxisTitleOption {
    offset?: number;
    textStyle?: DataPointType;
    position?: 'start' | 'center' | 'end';
    rotate?: number;
}
interface AxisTickLineOption {
    length?: number;
    [key: string]: any;
}
export interface AxisOption {
    positon?: 'top' | 'bottom' | 'left' | 'right';
    line?: DataPointType | null;
    autoRotateLabel?: boolean;
    autoHideLabel?: boolean;
    autoRotateTitle?: true;
    label?: AxisLabelOption | labelCallback | null;
    gridType?: 'line' | 'arc';
    gridAlign?: 'center';
    gridAlternateColor?: string | [string, string];
    grid?: DataPointType | gridCallback | null;
    showTitle?: boolean;
    title?: AxisTitleOption;
    tickLine?: AxisTickLineOption;
    subTickCount?: number;
    subTickLine?: AxisTickLineOption;
}
export interface AxisOptions {
    [key: string]: AxisOption;
}
export interface AxesOption {
    fields: {
        [field: string]: AxisOption | boolean;
    };
}
interface CommonConfig {
    type: string;
    [propName: string]: any;
}
declare type ParserCallback = (states: States) => CommonConfig;
declare type TransformCallback = (states: States) => CommonConfig | CommonConfig[];
export interface DataCfg {
    source: any;
    parser?: CommonConfig | ParserCallback;
    transform?: CommonConfig | CommonConfig[] | TransformCallback;
}
interface CrosshairsCfg {
    type: 'cross' | 'x' | 'y';
    style?: DataPointType;
}
declare type HtmlContentCallback = (title: string, items: DataPointType[]) => string | HTMLElement;
export interface TooltipOption {
    showTitle?: boolean;
    triggerOn?: 'mousemove' | 'click' | 'none';
    inPanel?: boolean;
    position?: 'inside' | 'top' | 'bottom' | 'left' | 'right';
    shared?: boolean;
    follow?: boolean;
    crosshairs?: CrosshairsCfg | null;
    title?: string;
    useHtml?: boolean;
    showTooltipMarkers?: boolean;
    htmlContent?: HtmlContentCallback;
    containerTpl?: string;
    itemTpl?: string;
    enterable?: boolean;
    'g2-tooltip'?: DataPointType;
    'g2-tooltip-title'?: DataPointType;
    'g2-tooltip-list'?: DataPointType;
    'g2-tooltip-list-item'?: DataPointType;
    'g2-tooltip-marker'?: DataPointType;
    'g2-tooltip-value'?: DataPointType;
    backgroundStyle?: DataPointType;
    titleStyle?: DataPointType;
    nameStyle?: DataPointType;
    valueStyle?: DataPointType;
    markerStyle?: DataPointType;
    itemGap?: number;
}
export declare type FilterCallback = (fieldValue: any) => boolean;
interface ScaleCommonOption {
    alias?: string;
    values?: any[];
    range?: [number, number];
    formatter?: (value: any, index?: number) => string;
    ticks?: any[];
    tickCount?: number;
}
interface CategoryScaleOption extends ScaleCommonOption {
    type: 'cat';
    tickInterval?: number;
}
interface IdentityScaleOption extends ScaleCommonOption {
    type: 'identity';
}
interface LinearScaleOption extends ScaleCommonOption {
    type: 'linear';
    min?: number;
    max?: number;
    nice?: true;
}
interface PowScaleOption extends ScaleCommonOption {
    type: 'pow';
    exponent?: number;
}
interface LogScaleOption extends ScaleCommonOption {
    type: 'log';
    base?: number;
}
interface TimeScaleOption extends ScaleCommonOption {
    type: 'time';
    showLast?: boolean;
    tickInterval?: number;
}
export declare type ScaleOption = CategoryScaleOption | IdentityScaleOption | LinearScaleOption | PowScaleOption | LogScaleOption | TimeScaleOption;
export interface ScalesOption {
    [key: string]: ScaleOption;
}
export {};
