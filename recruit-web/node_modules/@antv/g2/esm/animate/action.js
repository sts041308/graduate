/**
 * @fileOverview Default animation funciton
 */
import * as pathUtil from '@antv/path-util';
import * as _ from '@antv/util';
import { doAnimation, doGroupScaleIn, getClip, getScaledMatrix } from './util';
// 获取图形的包围盒
function getPointsBox(points) {
    if (_.isEmpty(points)) {
        return null;
    }
    var minX = points[0].x;
    var maxX = points[0].x;
    var minY = points[0].y;
    var maxY = points[0].y;
    _.each(points, function (point) {
        minX = minX > point.x ? point.x : minX;
        maxX = maxX < point.x ? point.x : maxX;
        minY = minY > point.y ? point.y : minY;
        maxY = maxY < point.y ? point.y : maxY;
    });
    return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2,
    };
}
function getAngle(shape, coord) {
    var points = shape.points || shape.get('origin').points;
    var box = getPointsBox(points);
    var endAngle;
    var startAngle;
    var coordStartAngle = coord.startAngle;
    var coordEndAngle = coord.endAngle;
    var diffAngle = coordEndAngle - coordStartAngle;
    if (coord.isTransposed) {
        endAngle = box.maxY * diffAngle;
        startAngle = box.minY * diffAngle;
    }
    else {
        endAngle = box.maxX * diffAngle;
        startAngle = box.minX * diffAngle;
    }
    endAngle += coordStartAngle;
    startAngle += coordStartAngle;
    return {
        startAngle: startAngle,
        endAngle: endAngle,
    };
}
function scaleInY(shape, animateCfg) {
    var box = shape.getBBox();
    var points = shape.get('origin').points;
    var x = (box.minX + box.maxX) / 2;
    var y = points[0].y - points[1].y <= 0 ? box.maxY : box.minY;
    var endState = {
        matrix: getScaledMatrix(shape, [x, y, 1], 'y'),
    };
    doAnimation(shape, endState, animateCfg);
}
function scaleInX(shape, animateCfg) {
    var box = shape.getBBox();
    var points = shape.get('origin').points;
    var x = points[0].y - points[1].y > 0 ? box.maxX : box.minX;
    var y = (box.minY + box.maxY) / 2;
    var endState = {
        matrix: getScaledMatrix(shape, [x, y, 1], 'x'),
    };
    doAnimation(shape, endState, animateCfg);
}
function lineWidthOut(shape, animateCfg) {
    var endState = {
        lineWidth: 0,
        opacity: 0,
    };
    animateCfg.callback = function () { return shape.remove(); };
    doAnimation(shape, endState, animateCfg);
}
function zoomIn(shape, animateCfg, coord) {
    var x;
    var y;
    if (coord.isPolar && shape.name !== 'point') {
        x = coord.getCenter().x;
        y = coord.getCenter().y;
    }
    else {
        var box = shape.getBBox();
        x = (box.minX + box.maxX) / 2;
        y = (box.minY + box.maxY) / 2;
    }
    var endState = {
        matrix: getScaledMatrix(shape, [x, y, 1], 'xy'),
    };
    doAnimation(shape, endState, animateCfg);
}
function zoomOut(shape, animateCfg, coord) {
    var x;
    var y;
    if (coord.isPolar && shape.name !== 'point') {
        x = coord.getCenter().x;
        y = coord.getCenter().y;
    }
    else {
        var box = shape.getBBox();
        x = (box.minX + box.maxX) / 2;
        y = (box.minY + box.maxY) / 2;
    }
    var v = [x, y, 1];
    shape.apply(v);
    var endState = {
        transform: [
            ['t', -x, -y],
            ['s', 0.01, 0.01],
            ['t', x, y],
        ],
    };
    animateCfg.callback = function () { return shape.remove(); };
    doAnimation(shape, endState, animateCfg);
}
function pathIn(shape, animateCfg) {
    if (shape.get('type') !== 'path') {
        return;
    }
    var path = pathUtil.path2Curve(shape.attr('path'));
    shape.attr('path', [path[0]]);
    var endState = {
        path: path,
    };
    doAnimation(shape, endState, animateCfg);
}
function pathOut(shape, animateCfg) {
    if (shape.get('type') !== 'path') {
        return;
    }
    var path = pathUtil.path2Curve(shape.attr('path'));
    var endState = {
        path: [path[0]],
    };
    animateCfg.callback = function () { return shape.remove(); };
    doAnimation(shape, endState, animateCfg);
}
function clipIn(shape, animateCfg, coord, startAngle, endAngle) {
    var clip = getClip(coord);
    var canvas = shape.get('canvas');
    var endState;
    if (startAngle) {
        // 指定了 startAngle 和 endAngle
        clip.attr('startAngle', startAngle);
        clip.attr('endAngle', startAngle);
        endState = {
            endAngle: endAngle,
        };
    }
    else {
        endState = clip.endState;
    }
    clip.set('canvas', canvas);
    shape.attr('clip', clip);
    shape.setSilent('animating', true);
    animateCfg.callback = function () {
        if (shape && !shape.get('destroyed')) {
            shape.attr('clip', null);
            shape.setSilent('cacheShape', null);
            shape.setSilent('animating', false);
            clip.remove();
        }
    };
    doAnimation(clip, endState, animateCfg);
}
function fadeIn(shape, animateCfg) {
    var fillOpacity = _.isNil(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity');
    var strokeOpacity = _.isNil(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity');
    shape.attr('fillOpacity', 0);
    shape.attr('strokeOpacity', 0);
    var endState = {
        fillOpacity: fillOpacity,
        strokeOpacity: strokeOpacity,
    };
    doAnimation(shape, endState, animateCfg);
}
function fadeOut(shape, animateCfg) {
    var endState = {
        fillOpacity: 0,
        strokeOpacity: 0,
    };
    animateCfg.callback = function () { return shape.remove(); };
    doAnimation(shape, endState, animateCfg);
}
function fanIn(shape, animateCfg, coord) {
    var _a = getAngle(shape, coord), startAngle = _a.startAngle, endAngle = _a.endAngle;
    clipIn(shape, animateCfg, coord, startAngle, endAngle);
}
function groupScaleInX(container, animateCfg, coord, zeroY) {
    doGroupScaleIn(container, animateCfg, coord, zeroY, 'x');
}
function groupScaleInY(container, animateCfg, coord, zeroY) {
    doGroupScaleIn(container, animateCfg, coord, zeroY, 'y');
}
function groupScaleInXY(container, animateCfg, coord, zeroY) {
    doGroupScaleIn(container, animateCfg, coord, zeroY, 'xy');
}
function groupWaveIn(container, animateCfg, coord) {
    var clip = getClip(coord);
    clip.set('canvas', container.get('canvas'));
    container.attr('clip', clip);
    animateCfg.callback = function () {
        container.attr('clip', null);
        clip.remove();
    };
    var endState = clip.endState;
    doAnimation(clip, endState, animateCfg);
}
// 默认动画库
var Action = {
    enter: {
        clipIn: clipIn,
        zoomIn: zoomIn,
        pathIn: pathIn,
        scaleInY: scaleInY,
        scaleInX: scaleInX,
        fanIn: fanIn,
        fadeIn: fadeIn,
    },
    leave: {
        lineWidthOut: lineWidthOut,
        zoomOut: zoomOut,
        pathOut: pathOut,
        fadeOut: fadeOut,
        fadeIn: fadeIn,
    },
    appear: {
        clipIn: clipIn,
        zoomIn: zoomIn,
        pathIn: pathIn,
        scaleInY: scaleInY,
        scaleInX: scaleInX,
        fanIn: fanIn,
        fadeIn: fadeIn,
        groupWaveIn: groupWaveIn,
        groupScaleInX: groupScaleInX,
        groupScaleInY: groupScaleInY,
        groupScaleInXY: groupScaleInXY,
    },
    update: {
        fadeIn: fadeIn,
        fanIn: fanIn,
    },
};
// 给每一个方法增加 name 属性，防止 function name 被 uglify 改掉。
_.each(Action, function (v) {
    _.each(v, function (animate, name) {
        // @ts-ignore
        animate.animationName = name;
    });
});
export default Action;
//# sourceMappingURL=action.js.map