"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var dependents_1 = require("../dependents");
var _ = require("@antv/util");
var base_1 = require("./shape/base");
var base_2 = require("../base");
var global_1 = require("../global");
var tooltip_1 = require("./controller/tooltip");
var label_1 = require("./controller/label");
var state_1 = require("./controller/state");
var parse_fields_1 = require("./util/parse-fields");
var GROUP_ATTRS = ['color', 'shape', 'size'];
exports.FIELD_ORIGIN = '_origin';
var Element = /** @class */ (function (_super) {
    tslib_1.__extends(Element, _super);
    function Element(cfg) {
        var _this = _super.call(this, tslib_1.__assign({ id: null, type: 'base', shapeType: null, coord: null, attrs: {}, data: [], scales: {}, attrOptions: {}, view: null, canvas: null, container: null, shapeContainer: null, generatePoints: false, sortable: false, animate: true, visible: true, shareTooltip: true, activeOptions: null, inactiveOptions: null, selectedOptions: null, labelOptions: null, tooltipOptions: null, adjustOptions: null, styleOptions: null, statOptions: null, animateOptions: null, theme: null, widthRatio: global_1.default.widthRatio }, cfg)) || this;
        // 设置 theme
        var theme = _this.get('theme') || global_1.default.theme;
        _this.set('theme', theme);
        // 初始化容器，container 容器在 view 中添加 element 的时候创建
        _this.get('container') && _this._initContainer();
        // 初始化 Element 的辅助控制器对象
        _this._initController();
        return _this;
    }
    Element.prototype.position = function (cfg) {
        if (_.isString(cfg)) {
            this._setAttrOptions('position', {
                fields: parse_fields_1.parseFields(cfg),
            });
        }
        else {
            this._setAttrOptions('position', cfg);
        }
        return this;
    };
    Element.prototype.color = function (field, cfg) {
        this._createAttrOption('color', field, cfg);
        return this;
    };
    Element.prototype.shape = function (field, cfg) {
        this._createAttrOption('shape', field, cfg);
        return this;
    };
    Element.prototype.size = function (field, cfg) {
        this._createAttrOption('size', field, cfg);
        return this;
    };
    Element.prototype.opacity = function (field, callback) {
        this._createAttrOption('opacity', field, callback);
        return this;
    };
    Element.prototype.adjust = function (adjustCfg) {
        var adjusts = adjustCfg;
        if (_.isString(adjustCfg) || _.isPlainObject(adjustCfg)) {
            adjusts = [adjustCfg];
        }
        _.each(adjusts, function (adjust, index) {
            if (!_.isObject(adjust)) {
                adjusts[index] = { type: adjust };
            }
        });
        this.set('adjustOptions', adjusts);
        return this;
    };
    Element.prototype.style = function (field, callback) {
        if (_.isString(field)) {
            var fields = parse_fields_1.parseFields(field);
            this.set('styleOptions', {
                fields: fields,
                callback: callback,
            });
        }
        else {
            var fields = field.fields, callback_1 = field.callback, cfg = field.cfg;
            if (fields || callback_1 || cfg) {
                this.set('styleOptions', field);
            }
            else {
                this.set('styleOptions', {
                    cfg: field,
                });
            }
        }
        return this;
    };
    Element.prototype.tooltip = function (field, cfg) {
        if (_.isString(field)) {
            var fields = parse_fields_1.parseFields(field);
            this.set('tooltipOptions', {
                fields: fields,
                callback: cfg,
            });
        }
        else {
            this.set('tooltipOptions', field);
        }
        return this;
    };
    Element.prototype.label = function (field, cfg) {
        var labelOptions = {};
        if (_.isString(field)) {
            var fields = parse_fields_1.parseFields(field);
            labelOptions.fields = fields;
            labelOptions.callback = cfg;
            this.set('labelOptions', labelOptions);
        }
        else {
            this.set('labelOptions', field);
        }
        return this;
    };
    /**
     * element 上的动画配置
     * @param cfg 动画配置
     */
    Element.prototype.animate = function (cfg) {
        this.set('animateOptions', cfg);
        return this;
    };
    /**
     * 配置 element 下 shape 在 active 状态下的样式
     * @param cfg active 的样式，为 false 时表示不允许 active
     */
    Element.prototype.active = function (cfg) {
        this.set('activeOptions', cfg);
        return this;
    };
    /**
     * 配置 element 下 shape 在 selected 状态下的样式
     * @param cfg selected 的样式，为 false 时表示不允许 selected
     */
    Element.prototype.selected = function (cfg) {
        this.set('selectedOptions', cfg);
        return this;
    };
    /**
     * 配置 element 下 shape 在 inactive 状态下的样式
     * @param cfg inactive 的样式，为 false 时表示不允许 inactive
     */
    Element.prototype.inactive = function (cfg) {
        this.set('inactiveOptions', cfg);
        return this;
    };
    /**
     * 初始化 element，生成 attribute, scale 对象，同时对数据进行处理
     */
    Element.prototype.init = function () {
        var _this = this;
        // 将容器应用坐标系的变换
        var coord = this.get('coord');
        var shapeContainer = this.get('shapeContainer');
        shapeContainer.setMatrix(coord.matrix);
        // 执行统计函数
        var data = this.get('data'); // 原始数据
        // 生成图形属性对象以及对应的 scales
        this._initAttrs(data);
        // 创建 tooltip() 方法上声明字段对应的 scale 对象
        var tooltipOptions = this.get('tooltipOptions');
        if (tooltipOptions && tooltipOptions.fields) {
            var fields = tooltipOptions.fields;
            fields.forEach(function (field) {
                _this.createScale(field, data); // 创建 tooltip 上对应的度量
            });
        }
        var dataArray = this._processData(data);
        dataArray = this._adjustData(dataArray);
        this.set('dataArray', dataArray);
    };
    Element.prototype.bindStates = function () {
        if (this.get('view')) {
            var stateController = new state_1.default(this);
            stateController.bind();
            this.set('stateController', stateController);
        }
    };
    Element.prototype.unbindStates = function () {
        if (this.get('view')) {
            var stateController = this.get('stateController');
            stateController && stateController.unbind();
        }
    };
    /**
     * 进行数据到图形空间的映射同时绘制图形
     */
    Element.prototype.paint = function () {
        var coord = this.get('coord');
        var theme = this.get('theme');
        var dataArray = this.get('dataArray');
        var mappedArray = [];
        var shapeFactory = this._getShapeFactory();
        shapeFactory.setCoord(coord);
        shapeFactory.setTheme(theme.shape); // 获取主题
        var shapeContainer = this.get('shapeContainer');
        this._beforeMapping(dataArray);
        for (var i = 0, len = dataArray.length; i < len; i += 1) {
            var data = dataArray[i];
            data = this._mapping(data);
            mappedArray.push(data);
            this.draw(data, shapeContainer, shapeFactory, i);
        }
        // 添加 label
        if (this.get('labelOptions')) {
            var labelController = this.get('labelController');
            var labels = labelController.addLabels(_.union.apply(_, mappedArray), shapeContainer.get('children'));
            this.set('labels', labels);
        }
        if (!this.get('sortable')) {
            this._sort(mappedArray); // 便于数据的查找，需要对数据进行排序，用于 geom.findPoint()
        }
        else {
            this.set('dataArray', mappedArray);
        }
    };
    Element.prototype.clear = function () {
        this.clearInner();
        this.set('scales', {});
        this.set('labels', null);
    };
    Element.prototype.destroy = function () {
        this.clear();
        var shapeContainer = this.get('shapeContainer');
        shapeContainer && shapeContainer.remove();
        var container = this.get('container');
        container && container.remove();
        this.unbindStates();
        _super.prototype.destroy.call(this);
    };
    /**
     * 获取图形属性对应的默认值
     * @param attrName 图形属性名称
     */
    Element.prototype.getDefaultValue = function (attrName) {
        var value;
        var attr = this.getAttr(attrName);
        if (attr && _.isEmpty(attr.scales)) { // 获取映射至常量的值
            value = attr.values[0];
        }
        return value;
    };
    /**
     * 隐藏或者展示 Element
     * @param visible boolean 类型，是否可见
     * @param stopDraw 可选，boolean 类型，是否结束绘画
     */
    Element.prototype.changeVisible = function (visible, stopDraw) {
        this.set('visible', visible);
        var shapeContainer = this.get('shapeContainer');
        shapeContainer && shapeContainer.set('visible', visible);
        // should be done in controller
        var labelController = this.get('labelController');
        labelController && labelController.changeVisible(visible);
        if (!stopDraw && shapeContainer) {
            var canvas = this.get('canvas');
            canvas.draw();
        }
    };
    /**
     * 根据图形属性名称获取对应的图形属性对象
     * @param name 图形属性名
     */
    Element.prototype.getAttr = function (name) {
        return this.get('attrs')[name];
    };
    /**
     * 获取同图例相关的图形属性对象
     */
    Element.prototype.getAttrsForLegend = function () {
        var attrs = _.values(this.get('attrs'));
        return _.filter(attrs, function (attr) { return _.contains(GROUP_ATTRS, attr.type); });
    };
    /**
     * 获取 x 方向上的度量
     */
    Element.prototype.getXScale = function () {
        return this.getAttr('position').scales[0];
    };
    /**
     * 获取 y 方向上的度量，目前只支持二维
     */
    Element.prototype.getYScale = function () {
        return this.getAttr('position').scales[1];
    };
    /**
     * 获取 Element 上对应所有的图形对象 shape
     */
    Element.prototype.getShapes = function () {
        var shapeContainer = this.get('shapeContainer');
        return shapeContainer.get('children');
    };
    /**
     * 判断 Element 是否位于极坐标系下
     */
    Element.prototype.isInCircle = function () {
        var coord = this.get('coord');
        return !!(coord && coord.isPolar);
    };
    /**
     * 为每个 shape 添加额外的信息，用于动画
     * @param shape shape 实例
     * @param index 索引值，绘制的顺序，同数据顺序对应
     */
    Element.prototype.appendShapeInfo = function (shape, index) {
        if (shape) {
            shape.setSilent('index', index);
            shape.setSilent('coord', this.get('coord'));
            shape.setSilent('scales', this.get('scales'));
            if (this.get('animate') && !_.isNil(this.get('animateOptions'))) {
                shape.setSilent('animateOptions', this.get('animateOptions'));
            }
        }
    };
    /**
     * 判断是否发生同 adjustType 对应的调整
     * @param adjustType adjust 类型
     */
    Element.prototype.hasAdjust = function (adjustType) {
        var adjustOptions = this.get('adjustOptions');
        var rst = false;
        _.each(adjustOptions, function (adjustOption) {
            if (adjustOption.type === adjustType) {
                rst = true;
                return false;
            }
        });
        return rst;
    };
    /**
     * 获取图形属性对应的值
     * @param attr 图形属性对象
     * @param record 数据
     */
    Element.prototype.getAttrValues = function (attr, record) {
        var scales = attr.scales;
        var params = _.map(scales, function (scale) {
            var field = scale.field;
            if (scale.type === 'identity') {
                return scale.values[0];
            }
            if (scale.isCategory) {
                return record[field]; // 数据有可能发生过 adjust
            }
            return record[field];
        });
        return attr.mapping.apply(attr, params);
    };
    Element.prototype.getSize = function (obj) {
        var sizeController = this.get('sizeController');
        if (sizeController) {
            return sizeController.getSize(obj);
        }
    };
    Element.prototype.getNormalizedSize = function (obj) {
        var sizeController = this.get('sizeController');
        if (sizeController) {
            return sizeController.getNormalizedSize(obj);
        }
    };
    /**
     * 获取分组相关的度量
     */
    Element.prototype.getGroupScales = function () {
        var scales = this.get('groupScales');
        if (!scales) {
            var attrs = _.values(this.get('attrs'));
            // 所有的分组 Attribute 实例
            var groupAttrs = _.filter(attrs, function (attr) { return _.contains(GROUP_ATTRS, attr.type); });
            // 所有的分组 scale
            var groupScales = _.map(groupAttrs, function (attr) { return _.filter(attr.scales, function (scale) { return scale.isCategory; }); });
            // 打平，去重
            scales = _.uniq(_.flatten(groupScales));
            this.set('groupScales', scales);
        }
        return scales;
    };
    /**
     * 获取图例的字段集合
     */
    Element.prototype.getLegendFields = function () {
        var fields = [];
        var attrOptions = this.get('attrOptions'); // 因为会在生成 scale 前调用，所以通过 attrOptions 进行判断
        GROUP_ATTRS.forEach(function (attrName) {
            var attrOption = attrOptions[attrName];
            var attrFields = _.get(attrOption, 'fields', []);
            fields = fields.concat(attrFields);
        });
        return _.uniq(fields);
    };
    /**
     * 是否合并 tooltip
     */
    Element.prototype.isShareTooltip = function () {
        var isShareTooltip = this.get('shareTooltip');
        if (!this.getYScale()) { // 一维图表不合并 tooltip
            isShareTooltip = false;
        }
        return isShareTooltip;
    };
    /**
     * 根据画布坐标在 source 中查找匹配的数据
     * @param point 画布坐标
     * @param source 数据源(已排序)
     */
    Element.prototype.findPoint = function (point, source) {
        var tooltipController = this.get('tooltipController');
        return tooltipController.findPoint(point, source);
    };
    /**
     * 根据数据获取对应的 tooltip items 信息
     * @param data 数据记录
     * @param titleField tooltip title 字段名
     */
    Element.prototype.getTooltipItems = function (data, titleField) {
        var tooltipController = this.get('tooltipController');
        return tooltipController.getTooltipItems(data, titleField);
    };
    /**
     * 获取 Y 轴上的最小值
     */
    Element.prototype.getYMinValue = function () {
        var yScale = this.getYScale();
        var min = yScale.min, max = yScale.max;
        var value;
        if (min >= 0) {
            value = min;
        }
        else if (max <= 0) { // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0
            value = max;
        }
        else {
            value = 0;
        }
        return value;
    };
    /**
     * 为每个 shape 生成唯一标识 ID，用于动画
     * @param dataObj shape 的原始数据
     */
    Element.prototype.getShapeId = function (dataObj) {
        var id = this.get('id');
        var keyFields = this.get('keyFields');
        if (keyFields && keyFields.length > 0) {
            _.each(keyFields, function (key) {
                id = id + "-" + dataObj[key];
            });
        }
        else {
            var type = this.get('type');
            var xScale = this.getXScale();
            var yScale = this.getYScale();
            var xField = xScale.field || 'x';
            var yField = yScale.field || 'y';
            var yVal = dataObj[yField];
            var xVal = void 0;
            if (xScale.isIdentity) {
                xVal = xScale.values[0];
            }
            else {
                xVal = dataObj[xField];
            }
            if (type === 'interval' || type === 'schema') {
                id = id + "-" + xVal;
            }
            else if (type === 'line' || type === 'area' || type === 'path') {
                id = id + "-" + type;
            }
            else {
                id = id + "-" + xVal + "-" + yVal;
            }
            var groupScales = this.getGroupScales();
            if (!_.isEmpty(groupScales)) {
                _.each(groupScales, function (groupScale) {
                    // @ts-ignore
                    var field = groupScale.field;
                    if (groupScale.type !== 'identity') {
                        id = id + "-" + dataObj[field];
                    }
                });
            }
        }
        return id;
    };
    /**
     * 根据画布坐标点获取对应的原始数据
     * @param point 画布坐标点
     */
    Element.prototype.getOriginDataByPoint = function (point) {
        var _a;
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var coord = this.get('coord');
        var invertPoint = coord.invert(point);
        var xValue = xScale.invert(invertPoint.x);
        var yValue = yScale.invert(invertPoint.y);
        var xField = xScale.field;
        var yField = yScale.field;
        return _a = {},
            _a[xField] = xValue,
            _a[yField] = yValue,
            _a;
    };
    /**
     * @protected
     * 根据数据获取图形的关键点数据
     * @param obj 数据对象
     */
    Element.prototype.createShapePointsCfg = function (obj) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var x = this._normalizeValues(obj[xScale.field], xScale);
        var y; // 存在没有 y 的情况
        if (yScale) {
            y = this._normalizeValues(obj[yScale.field], yScale);
        }
        else {
            y = obj.y ? obj.y : 0.1;
        }
        return {
            x: x,
            y: y,
            y0: yScale ? yScale.scale(this.getYMinValue()) : undefined,
        };
    };
    /**
     * @protected
     * 根据数据生成图形
     * @param data 需要绘制的数据集合
     * @param container 图形容器
     * @param shapeFactory shape 的管理对象
     * @param index 索引值
     */
    Element.prototype.draw = function (data, container, shapeFactory, index) {
        for (var i = 0, len = data.length; i < len; i += 1) {
            var obj = data[i];
            this.drawPoint(obj, container, shapeFactory, index + i);
        }
    };
    /**
     * @protected
     * 绘制具体的 shape
     * @param obj 需要绘制的一套数据
     * @param container 图形容器
     * @param shapeFactory  shape 的管理对象
     * @param index 索引值
     */
    Element.prototype.drawPoint = function (obj, container, shapeFactory, index) {
        var shape = obj.shape;
        var cfg = this.getDrawCfg(obj);
        var geomShape = shapeFactory.drawShape(shape, cfg, container);
        this.appendShapeInfo(geomShape, index);
    };
    /**
     * 构造绘图图形需要的属性
     * @param obj 数据
     */
    Element.prototype.getDrawCfg = function (obj) {
        var cfg = {
            origin: obj,
            x: obj.x,
            y: obj.y,
            color: obj.color,
            size: obj.size,
            shape: obj.shape,
            isInCircle: this.isInCircle(),
            opacity: obj.opacity,
        };
        var styleOptions = this.get('styleOptions');
        if (styleOptions) {
            cfg.style = this._getStyleCfg(styleOptions, obj[exports.FIELD_ORIGIN]);
        }
        if (this.get('generatePoints')) {
            cfg.points = obj.points;
            cfg.nextPoints = obj.nextPoints;
        }
        cfg.id = this.getShapeId(obj[exports.FIELD_ORIGIN]);
        return cfg;
    };
    Element.prototype.clearInner = function () {
        // this.clearActivedShapes();
        // this.clearSelected();
        var shapeContainer = this.get('shapeContainer');
        shapeContainer && shapeContainer.clear();
        // 由于 Labels 对应的模块需要生成group，所以这个地方需要删除
        var labelController = this.get('labelController');
        labelController && labelController.clear();
        this.set('attrs', {});
        this.set('groupScales', null);
        var sizeController = this.get('sizeController');
        sizeController && sizeController.clear();
        var tooltipController = this.get('tooltipController');
        tooltipController.clear();
        // todo clear other controller
    };
    // 创建图形属性相关的配置项
    Element.prototype._createAttrOption = function (attrName, field, cfg) {
        if (_.isObject(field)) {
            this._setAttrOptions(attrName, field);
        }
        else {
            var attrCfg = {};
            if (_.isNumber(field)) { // size(3), opacity(0.8)
                attrCfg.values = [field];
            }
            else {
                attrCfg.fields = parse_fields_1.parseFields(field);
            }
            if (cfg) {
                if (_.isFunction(cfg)) {
                    attrCfg.callback = cfg;
                }
                else {
                    attrCfg.values = cfg;
                }
            }
            this._setAttrOptions(attrName, attrCfg);
        }
    };
    // 初始化容器
    Element.prototype._initContainer = function () {
        var container = this.get('container');
        var view = this.get('view'); // element 所在的 view
        var viewId = view.get('id');
        var visible = this.get('visible');
        var shapeContainer = container.addGroup({
            viewId: viewId,
            visible: visible,
        });
        this.set('shapeContainer', shapeContainer);
    };
    // 初始化 element 相关的控制器
    Element.prototype._initController = function () {
        // tooltipController
        var tooltipController = new tooltip_1.default(this);
        this.set('tooltipController', tooltipController);
        // labelController
        var labelController = new label_1.default(this);
        this.set('labelController', labelController);
    };
    // 存储用户设置的图形属性配置项
    Element.prototype._setAttrOptions = function (name, cfg) {
        var attrOptions = this.get('attrOptions');
        attrOptions[name] = cfg;
    };
    // 给字段创建度量
    Element.prototype.createScale = function (field, data) {
        var view = this.get('view');
        var scales = this.get('scales');
        var scale = scales[field];
        if (!scale) {
            scale = view._initScale(field, data);
            scales[field] = scale;
        }
        return scale;
    };
    // 初始化 Attribute 实例同时生成相关的 scale 度量
    Element.prototype._initAttrs = function (data) {
        var _this = this;
        var attrs = this.get('attrs'); // attribute 实例
        var attrOptions = this.get('attrOptions'); // 传入的配置
        var coord = this.get('coord');
        var theme = this.get('theme');
        var geomType = this.get('type');
        // 遍历每一个 attrOption，各自创建 Attribute 实例
        _.each(attrOptions, function (option, type) {
            var attrOption = tslib_1.__assign({}, option);
            var callback = attrOption.callback, values = attrOption.values, _a = attrOption.fields, fields = _a === void 0 ? [] : _a;
            // 饼图的特殊逻辑，填充 position 上的一维映射
            if (type === 'position' && fields.length === 1 && coord.type === 'theta') {
                fields.unshift('1');
            }
            // 给每一个字段创建 scale
            var scales = _.map(fields, function (field) {
                return _this.createScale(field, data);
            });
            // 饼图需要填充满整个空间
            if (coord.type === 'theta' && type === 'position' && scales.length > 1) {
                var yScale = scales[1];
                yScale.change({
                    nice: false,
                    min: 0,
                    max: Math.max.apply(null, yScale.values),
                });
            }
            attrOption.scales = scales;
            if (_.indexOf(['color', 'size', 'shape', 'opacity'], type) !== -1 &&
                scales.length === 1 && scales[0].isIdentity) { // 用户在图形通道上声明了常量字段 color('red'), size(5)
                attrOption.values = scales[0].values;
            }
            else if (!callback && !values) { // 用户没有指定任何规则，则使用默认的映射规则
                if (type === 'size') {
                    attrOption.values = theme.sizes;
                }
                else if (type === 'shape') {
                    attrOption.values = theme.shapes[geomType] || [];
                }
                else if (type === 'opacity') {
                    attrOption.values = theme.opacities;
                }
                else if (type === 'color' && scales.length) { // TODO 需要优化
                    var valuesLen = scales[0].values.length;
                    if (valuesLen <= 10) {
                        attrOption.values = theme.colors;
                    }
                    else {
                        attrOption.values = theme.colors_20;
                    }
                }
            }
            var attrCtor = dependents_1.getAttribute(type);
            attrs[type] = new attrCtor(attrOption);
        });
    };
    // 更新发生层叠后的数据对应的度量范围
    Element.prototype._updateStackRange = function (field, scale, dataArray) {
        var view = this.get('view');
        var scaleDefs = view.get('options').scales;
        var mergeArray = _.flatten(dataArray);
        var min = scale.min;
        var max = scale.max;
        for (var i = 0, len = mergeArray.length; i < len; i += 1) {
            var obj = mergeArray[i];
            var tmpMin = Math.min.apply(null, obj[field]);
            var tmpMax = Math.max.apply(null, obj[field]);
            if (tmpMin < min) {
                min = tmpMin;
            }
            if (tmpMax > max) {
                max = tmpMax;
            }
        }
        var cfg = {};
        if ((min < scale.min) && !_.get(scaleDefs, [field, 'min'])) {
            // 用户如果在列定义中定义了 min，则以用户定义的为准
            cfg.min = min;
        }
        if ((max > scale.max) && !_.get(scaleDefs, [field, 'max'])) {
            // 用户如果在列定义中定义了 max
            cfg.max = max;
        }
        if (!_.isEmpty(cfg)) {
            scale.change(cfg);
        }
    };
    // 对数据进行分组
    Element.prototype._groupData = function (data) {
        var groupScales = this.getGroupScales();
        var fields = groupScales.map(function (scale) { return scale.field; });
        return _.group(data, fields);
    };
    // 数据调整前保存原始数据
    Element.prototype._saveOrigin = function (data) {
        return _.map(data, function (origin) {
            var _a;
            return tslib_1.__assign(tslib_1.__assign({}, origin), (_a = {}, _a[exports.FIELD_ORIGIN] = origin, _a));
        });
    };
    // 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理
    Element.prototype._numeric = function (data) {
        var positionAttr = this.getAttr('position');
        var scales = positionAttr.scales;
        for (var j = 0, len = data.length; j < len; j += 1) {
            var obj = data[j];
            for (var i = 0; i < Math.min(2, scales.length); i += 1) {
                var scale = scales[i];
                if (scale.isCategory) {
                    var field = scale.field;
                    obj[field] = scale.translate(obj[field]); // TODO
                }
            }
        }
    };
    // 处理数据：分组、存储原始数据、将分类数据数字化
    Element.prototype._processData = function (data) {
        var _this = this;
        var groupedArray = this._groupData(data);
        return _.map(groupedArray, function (subData) {
            var tempData = _this._saveOrigin(subData);
            _this._numeric(tempData);
            return tempData;
        });
    };
    // 进行数据调整
    Element.prototype._adjustData = function (dataArray) {
        var _this = this;
        var adjustOptions = this.get('adjustOptions');
        var result = dataArray;
        if (adjustOptions) {
            var theme = this.get('theme');
            var xScale_1 = this.getXScale();
            var yScale_1 = this.getYScale();
            var xField_1 = xScale_1.field;
            var yField_1 = yScale_1 ? yScale_1.field : null;
            adjustOptions.forEach(function (adjust) {
                var adjustCfg = tslib_1.__assign({ xField: xField_1,
                    yField: yField_1 }, adjust);
                var type = adjust.type;
                if (type === 'dodge') {
                    var adjustNames = [];
                    if (xScale_1.isCategory || xScale_1.isIdentity) {
                        adjustNames.push('x');
                    }
                    else if (!yScale_1) {
                        adjustNames.push('y');
                    }
                    else {
                        throw new Error('dodge is not support linear attribute, please use category attribute!');
                    }
                    adjustCfg.adjustNames = adjustNames;
                    adjustCfg.dodgeRatio = _this.get('widthRatio').column;
                }
                else if (type === 'stack') {
                    var coord = _this.get('coord');
                    if (!yScale_1) {
                        // 一维的情况下获取高度和默认size
                        adjustCfg.height = coord.getHeight();
                        var size = _this.getDefaultValue('size') || 3;
                        adjustCfg.size = size;
                    }
                    // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下
                    if (!coord.isTransposed && _.isNil(adjustCfg.reverseOrder)) {
                        adjustCfg.reverseOrder = true;
                    }
                }
                var adjustCtor = dependents_1.getAdjust(type);
                var adjustInstance = new adjustCtor(adjustCfg);
                result = adjustInstance.process(result);
                if (type === 'stack' && yScale_1) {
                    _this._updateStackRange(yField_1, yScale_1, result);
                }
            });
        }
        return result;
    };
    // 获取 element 对应 shape 的工厂对象
    Element.prototype._getShapeFactory = function () {
        var shapeFactory = this.get('shapeFactory');
        if (!shapeFactory) {
            var shapeType = this.get('shapeType');
            shapeFactory = base_1.getShapeFactory(shapeType);
            this.set('shapeFactory', shapeFactory);
        }
        return shapeFactory;
    };
    // 生成 shape 的关键点
    Element.prototype._generatePoints = function (data) {
        var shapeFactory = this._getShapeFactory();
        var shapeAttr = this.getAttr('shape');
        for (var i = 0, len = data.length; i < len; i += 1) {
            var obj = data[i];
            var cfg = this.createShapePointsCfg(obj);
            var shape = shapeAttr ? this.getAttrValues(shapeAttr, obj) : null;
            var points = shapeFactory.getShapePoints(shape, cfg);
            obj.points = points;
        }
    };
    // 将数据归一化
    Element.prototype._normalizeValues = function (values, scale) {
        var rst = [];
        if (_.isArray(values)) {
            for (var i = 0, len = values.length; i < len; i += 1) {
                var v = values[i];
                rst.push(scale.scale(v));
            }
        }
        else {
            rst = scale.scale(values);
        }
        return rst;
    };
    // 将数据映射至图形空间前的操作：排序以及关键点的生成
    Element.prototype._beforeMapping = function (dataArray) {
        var _this = this;
        if (this.get('sortable')) {
            var xScale_2 = this.getXScale();
            var field_1 = xScale_2.field;
            _.each(dataArray, function (data) {
                data.sort(function (v1, v2) {
                    return xScale_2.translate(v1[field_1]) - xScale_2.translate(v2[field_1]); // TODO
                });
            });
        }
        if (this.get('generatePoints')) {
            _.each(dataArray, function (data) {
                _this._generatePoints(data);
            });
            _.each(dataArray, function (data, index) {
                var nextData = dataArray[index + 1];
                if (nextData) {
                    data[0].nextPoints = nextData[0].points;
                }
            });
        }
    };
    // 将数据映射至图形空间
    Element.prototype._mapping = function (data) {
        var attrs = this.get('attrs');
        var mappedData = [];
        for (var i = 0, len = data.length; i < len; i += 1) {
            var record = data[i];
            var newRecord = {
                _origin: record[exports.FIELD_ORIGIN],
                points: record.points,
                nextPoints: record.nextPoints,
            };
            for (var k in attrs) {
                if (attrs.hasOwnProperty(k)) {
                    var attr = attrs[k];
                    var names = attr.names;
                    var values = this.getAttrValues(attr, record);
                    if (names.length > 1) { // position 之类的生成多个字段的属性
                        for (var j = 0; j < values.length; j += 1) {
                            var val = values[j];
                            var name_1 = names[j];
                            newRecord[name_1] = (_.isArray(val) && val.length === 1) ? val[0] : val; // 只有一个值时返回第一个属性值
                        }
                    }
                    else {
                        // newRecord[names[0]] = values.length === 1 ? values[0] : values;
                        // FIXME: 目前只有 color 通道是受 attr 结果统一为数组的影响的，暂时这么调整
                        if (values.length === 1 || names[0] === 'color') {
                            newRecord[names[0]] = values[0];
                        }
                        else {
                            newRecord[names[0]] = values;
                        }
                    }
                }
            }
            this._convertPoint(newRecord); // 将 x、y 转换成画布坐标
            mappedData.push(newRecord);
        }
        return mappedData;
    };
    // 将归一化的坐标值转换成画布坐标
    Element.prototype._convertPoint = function (mappedRecord) {
        var x = mappedRecord.x, y = mappedRecord.y;
        if (_.isNil(x) || _.isNil(y)) {
            return;
        }
        var rstX;
        var rstY;
        var obj;
        var coord = this.get('coord');
        if (_.isArray(y) && _.isArray(x)) {
            rstX = [];
            rstY = [];
            for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
                obj = coord.convertPoint({
                    x: x[i],
                    y: y[j],
                });
                rstX.push(obj.x);
                rstY.push(obj.y);
            }
        }
        else if (_.isArray(y)) {
            rstY = [];
            y.forEach(function (yVal) {
                obj = coord.convertPoint({
                    x: x,
                    y: yVal,
                });
                if (rstX && rstX !== obj.x) {
                    if (!_.isArray(rstX)) {
                        rstX = [rstX];
                    }
                    rstX.push(obj.x);
                }
                else {
                    rstX = obj.x;
                }
                rstY.push(obj.y);
            });
        }
        else if (_.isArray(x)) {
            rstX = [];
            x.forEach(function (xVal) {
                obj = coord.convertPoint({
                    x: xVal,
                    y: y,
                });
                if (rstY && rstY !== obj.y) {
                    if (!_.isArray(rstY)) {
                        rstY = [rstY];
                    }
                    rstY.push(obj.y);
                }
                else {
                    rstY = obj.y;
                }
                rstX.push(obj.x);
            });
        }
        else {
            var point = coord.convertPoint({
                x: x,
                y: y,
            });
            rstX = point.x;
            rstY = point.y;
        }
        mappedRecord.x = rstX;
        mappedRecord.y = rstY;
    };
    // 获取 style 配置
    Element.prototype._getStyleCfg = function (styleOptions, origin) {
        var _a = styleOptions.fields, fields = _a === void 0 ? [] : _a, callback = styleOptions.callback, cfg = styleOptions.cfg;
        if (cfg) { // 用户直接配置样式属性
            return cfg;
        }
        var params = fields.map(function (field) {
            return origin[field];
        });
        return callback.apply(void 0, params);
    };
    // 对数据进行排序
    Element.prototype._sort = function (mappedArray) {
        var xScale = this.getXScale();
        var xField = xScale.field;
        _.each(mappedArray, function (itemArr) {
            itemArr.sort(function (obj1, obj2) {
                return xScale.translate(obj1[exports.FIELD_ORIGIN][xField]) - xScale.translate(obj2[exports.FIELD_ORIGIN][xField]);
            });
        });
        this.set('dataArray', mappedArray);
    };
    return Element;
}(base_2.default));
exports.default = Element;
//# sourceMappingURL=base.js.map