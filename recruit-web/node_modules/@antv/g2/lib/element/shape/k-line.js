"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("@antv/util");
var shape_1 = require("../util/shape");
var base_1 = require("./base");
function _sortValue(oldValue) {
    var value = oldValue;
    if (!_.isArray(oldValue)) {
        value = [oldValue];
    }
    // 从大到小排序
    var sorted = value.sort(function (a, b) {
        return a < b ? 1 : -1;
    });
    var length = sorted.length;
    if (length < 4) {
        var min = sorted[length - 1];
        for (var i = 0; i < 4 - length; i++) {
            sorted.push(min);
        }
    }
    return sorted;
}
function _getPoints(x, y, width) {
    var yValues = _sortValue(y);
    var points = [
        {
            x: x,
            y: yValues[0],
        },
        {
            x: x,
            y: yValues[1],
        },
        {
            x: x - width / 2,
            y: yValues[2],
        },
        {
            x: x - width / 2,
            y: yValues[1],
        },
        {
            x: x + width / 2,
            y: yValues[1],
        },
        {
            x: x + width / 2,
            y: yValues[2],
        },
        {
            x: x,
            y: yValues[2],
        },
        {
            x: x,
            y: yValues[3],
        },
    ]; // 按照顺时针连接
    return points;
}
function _getPath(points) {
    var path = [
        ['M', points[0].x, points[0].y],
        ['L', points[1].x, points[1].y],
        ['M', points[2].x, points[2].y],
        ['L', points[3].x, points[3].y],
        ['L', points[4].x, points[4].y],
        ['L', points[5].x, points[5].y],
        ['Z'],
        ['M', points[6].x, points[6].y],
        ['L', points[7].x, points[7].y],
    ];
    return path;
}
function _getAttrs(cfg) {
    var lineAttrs = cfg.style;
    shape_1.setFillStyle(lineAttrs, cfg);
    shape_1.setStrokeStyle(lineAttrs, cfg);
    return lineAttrs;
}
var KLineShapeFactory = base_1.registerShapeFactory('kline', {
    defaultShapeType: 'kline',
});
base_1.registerShape('kline', 'kline', {
    getPoints: function (pointInfo) {
        return _getPoints(pointInfo.x, pointInfo.y, pointInfo.size);
    },
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getPath(cfg.points);
        path = this.parsePath(path);
        return container.addShape('path', {
            attrs: _.mix(attrs, {
                path: path,
            }),
        });
    },
    getMarkerStyle: function (markerCfg) {
        return {
            symbol: function (x, y, r) {
                var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
                var points = _getPoints(x, yValues, r);
                return [
                    ['M', points[0].x, points[0].y],
                    ['L', points[1].x, points[1].y],
                    ['M', points[2].x, points[2].y],
                    ['L', points[3].x, points[3].y],
                    ['L', points[4].x, points[4].y],
                    ['L', points[5].x, points[5].y],
                    ['Z'],
                    ['M', points[6].x, points[6].y],
                    ['L', points[7].x, points[7].y],
                ];
            },
            lineWidth: 1,
            stroke: markerCfg.color,
            fill: markerCfg.color,
            radius: 6,
        };
    },
});
exports.default = KLineShapeFactory;
//# sourceMappingURL=k-line.js.map