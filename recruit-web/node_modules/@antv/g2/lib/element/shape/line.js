"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * @description line shapes
 */
var _ = require("@antv/util");
var base_1 = require("./base");
var path_1 = require("../util/path");
var shape_1 = require("../util/shape");
var symbol_1 = require("../util/symbol");
var DOT_LINEDASH = [1, 1];
var DASH_LINEDASH = [5.5, 1];
// 获取图形属性
function _getAttrs(cfg) {
    var lineAttrs = cfg.style;
    shape_1.setStrokeStyle(lineAttrs, cfg);
    if (cfg.size) {
        lineAttrs.lineWidth = cfg.size;
    }
    return lineAttrs;
}
// 获取 Marker 的图形属性
function _getMarkerAttrs(cfg) {
    var markerAttrs = {
        lineWidth: 2,
        radius: 6,
    };
    shape_1.setStrokeStyle(markerAttrs, cfg);
    return markerAttrs;
}
// 当只有一个数据时绘制点
function _drawPointShape(cfg, container) {
    var point = cfg.points[0];
    return container.addShape('circle', {
        attrs: {
            x: point.x,
            y: point.y,
            r: 2,
            fill: cfg.color,
        },
    });
}
// 获取带有上下区间的 path
function _getRangePath(points, smooth, isInCircle, cfg) {
    var isStack = cfg.isStack;
    var topPoints = [];
    var bottomPoints = [];
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        var tmp = shape_1.splitPoints(point);
        bottomPoints.push(tmp[0]);
        topPoints.push(tmp[1]);
    }
    var topPath = _getSinglePath(topPoints, smooth, isInCircle, cfg);
    var bottomPath = _getSinglePath(bottomPoints, smooth, isInCircle, cfg);
    if (isStack) {
        return topPath;
    }
    return topPath.concat(bottomPath);
}
// 单条 path
function _getSinglePath(points, smooth, isInCircle, cfg) {
    var path;
    if (!smooth) {
        path = path_1.getLinePath(points, false);
        isInCircle && path.push(['Z']);
    }
    else {
        // 直角坐标系下绘制曲线时限制最大值、最小值
        var constraint = cfg.constraint;
        isInCircle && points.length && points.push({ x: points[0].x, y: points[0].y });
        path = path_1.getSplinePath(points, false, constraint);
    }
    return path;
}
// get line path
function _getPath(cfg, smooth) {
    var points = cfg.points, isInCircle = cfg.isInCircle;
    var first = points[0];
    return _.isArray(first.y) ?
        _getRangePath(points, smooth, isInCircle, cfg) :
        _getSinglePath(points, smooth, isInCircle, cfg);
}
function _interpPoints(points, fn) {
    var tmpPoints = [];
    _.each(points, function (point, index) {
        var nextPoint = points[index + 1];
        tmpPoints.push(point);
        if (nextPoint) {
            tmpPoints = tmpPoints.concat(fn(point, nextPoint));
        }
    });
    return tmpPoints;
}
// 插值的图形path，不考虑null
function _getInterPath(points) {
    var path = points.map(function (point, index) {
        return index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];
    });
    return path;
}
// 插值的图形
function _getInterPointShapeCfg(cfg, fn) {
    var points = _interpPoints(cfg.points, fn);
    return _getInterPath(points);
}
var LineShapeFactory = base_1.registerShapeFactory('line', {
    defaultShapeType: 'line',
    drawShape: function (type, cfg, container) {
        var shape = this.getShape(type);
        // 因为覆盖了 ShapeFactotyBase.drawShape 方法，所以记得要应用 shape 主题配置
        var shapeName = shape.name;
        var theme = this._theme;
        if (theme && theme.line && theme.line[shapeName]) {
            var defaultShapeStyle = theme.line[shapeName].default;
            cfg.style = _.mix({}, defaultShapeStyle, cfg.style);
        }
        var gShape = (cfg.points.length === 1 && cfg.showSinglePoint) ?
            _drawPointShape(cfg, container) :
            shape.draw(cfg, container);
        if (gShape) {
            gShape.setSilent('origin', cfg.origin);
            gShape.id = cfg.splitedIndex ? cfg.id + cfg.splitedIndex : cfg.id;
            gShape.name = this.name;
        }
        return gShape;
    },
    getMarkerStyle: function (type, markerCfg) {
        var shape = this.getShape(type);
        var markerStyle;
        if (shape.getMarkerStyle) {
            markerStyle = shape.getMarkerStyle(markerCfg);
        }
        else {
            markerStyle = _getMarkerAttrs(markerCfg);
            var symbol = symbol_1.LineSymbols[type];
            if (type === 'dot') {
                symbol = symbol_1.LineSymbols.line;
                markerStyle.lineDash = markerStyle.lineDash || DOT_LINEDASH;
            }
            if (type === 'dash') {
                symbol = symbol_1.LineSymbols.line;
                markerStyle.lineDash = markerStyle.lineDash || DASH_LINEDASH;
            }
            markerStyle.symbol = symbol;
        }
        var theme = this._theme;
        var shapeName = shape.name;
        if (theme && theme.line && theme.line[shapeName]) {
            markerStyle = _.mix({}, theme.line[shapeName].default, markerStyle);
        }
        return markerStyle;
    },
});
// 开始往 LineShapeFactory 注册具体的 shape
base_1.registerShape('line', 'line', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getPath(cfg, false);
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({}, attrs), { path: path }),
        });
    },
});
// 点线 ···
base_1.registerShape('line', 'dot', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getPath(cfg, false);
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({ lineDash: DOT_LINEDASH }, attrs), { path: path }),
        });
    },
});
// 断线 - - -
base_1.registerShape('line', 'dash', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getPath(cfg, false);
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({ lineDash: DASH_LINEDASH }, attrs), { path: path }),
        });
    },
});
// 平滑曲线
base_1.registerShape('line', 'smooth', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var coord = this.getCoord();
        // 曲线的限制
        cfg.constraint = [
            [coord.start.x, coord.end.y],
            [coord.end.x, coord.start.y],
        ];
        var path = _getPath(cfg, true);
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({}, attrs), { path: path }),
        });
    },
});
// step line,
base_1.registerShape('line', 'hv', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            return [{
                    x: nextPoint.x,
                    y: point.y,
                }];
        });
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({}, attrs), { path: path }),
        });
    },
});
base_1.registerShape('line', 'vh', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            return [{
                    x: point.x,
                    y: nextPoint.y,
                }];
        });
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({}, attrs), { path: path }),
        });
    },
});
base_1.registerShape('line', 'hvh', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            var middleX = (nextPoint.x + point.x) / 2;
            return [
                { x: middleX, y: point.y },
                { x: middleX, y: nextPoint.y },
            ];
        });
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({}, attrs), { path: path }),
        });
    },
});
base_1.registerShape('line', 'vhv', {
    draw: function (cfg, container) {
        var attrs = _getAttrs(cfg);
        var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
            var middleY = (point.y + nextPoint.y) / 2;
            return [
                { x: point.x, y: middleY },
                { x: nextPoint.x, y: middleY },
            ];
        });
        return container.addShape('path', {
            attrs: tslib_1.__assign(tslib_1.__assign({}, attrs), { path: path }),
        });
    },
});
exports.default = LineShapeFactory;
//# sourceMappingURL=line.js.map