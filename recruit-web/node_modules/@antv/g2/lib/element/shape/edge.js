"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @description Edge Element shapes
 * @author xinming002@gmail.com
 */
var _ = require("@antv/util");
var base_1 = require("./base");
var path_1 = require("../util/path");
var shape_1 = require("../util/shape");
var CORNER_PERCENT = 1 / 3;
// 获取图形属性
function _getAttrs(cfg) {
    var lineAttrs = cfg.style;
    shape_1.setStrokeStyle(lineAttrs, cfg);
    return lineAttrs;
}
// 获取Marker的图形属性
function _getMarkerAttrs(cfg) {
    var markerStyle = {
        symbol: 'circle',
        radius: 4.5,
    };
    shape_1.setStrokeStyle(markerStyle, cfg);
    return markerStyle;
}
// 获取Cubic Bezier路径
function _getCPath(from, to) {
    var points = [];
    points.push({
        x: from.x,
        y: from.y * (1 - 1 / 2) + to.y * 1 / 2,
    });
    points.push({
        y: from.y * (1 - 1 / 2) + to.y * 1 / 2,
        x: to.x,
    });
    points.push(to);
    var sub = ['C'];
    _.each(points, function (point) {
        sub.push(point.x, point.y);
    });
    return sub;
}
// 获取Quadratic Bezier路径
function _getQPath(to, center) {
    var points = [];
    points.push({
        x: center.x,
        y: center.y,
    });
    points.push(to);
    var sub = ['Q'];
    _.each(points, function (point) {
        sub.push(point.x, point.y);
    });
    return sub;
}
function _createSmoothPath(from, to) {
    var sub = _getCPath(from, to);
    var path = [
        ['M', from.x, from.y],
    ];
    path.push(sub);
    return path;
}
function _createArcPath(from, to, center) {
    var sub = _getQPath(to, center);
    var path = [
        ['M', from.x, from.y],
    ];
    path.push(sub);
    return path;
}
function _createArcWeightPath(points, center) {
    var arc1 = _getQPath(points[1], center);
    var arc2 = _getQPath(points[3], center);
    var path = [
        ['M', points[0].x, points[0].y],
    ];
    path.push(arc2);
    path.push(['L', points[3].x, points[3].y]);
    path.push(['L', points[2].x, points[2].y]);
    path.push(arc1);
    path.push(['L', points[1].x, points[1].y]);
    path.push(['L', points[0].x, points[0].y]);
    path.push(['Z']);
    return path;
}
function _createRectPath(from, to) {
    var points = [];
    points.push({
        y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
        x: from.x,
    });
    points.push({
        y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
        x: to.x,
    });
    points.push(to);
    var path = [
        ['M', from.x, from.y],
    ];
    _.each(points, function (point) {
        path.push(['L', point.x, point.y]);
    });
    return path;
}
var EdgeShapeFactory = base_1.registerShapeFactory('edge', {
    defaultShapeType: 'line',
    getDefaultPoints: function (pointInfo) {
        return shape_1.splitPoints(pointInfo);
    },
    getMarkerStyle: function (type, markerCfg) {
        var shape = this.getShape(type);
        var markerStyle;
        if (shape.getMarkerStyle) {
            markerStyle = shape.getMarkerStyle(markerCfg);
        }
        else {
            markerStyle = _getMarkerAttrs(markerCfg);
        }
        var theme = this._theme;
        var shapeName = shape.name;
        if (theme && theme.edge && theme.edge[shapeName]) {
            markerStyle = _.mix({}, theme.edge[shapeName].default, markerStyle);
        }
        return markerStyle;
    },
});
base_1.registerShape('edge', 'line', {
    draw: function (cfg, container) {
        var isInCircle = cfg.isInCircle;
        var points = this.parsePoints(cfg.points);
        var attrCfg = _getAttrs(cfg);
        var path = path_1.getLinePath(points, isInCircle);
        var line = container.addShape('path', {
            attrs: _.mix(attrCfg, {
                path: path,
            }),
        });
        return line;
    },
});
base_1.registerShape('edge', 'vhv', {
    draw: function (cfg, container) {
        var points = cfg.points;
        var attrCfg = _getAttrs(cfg);
        var path = _createRectPath(points[0], points[1]);
        path = this.parsePath(path);
        var line = container.addShape('path', {
            attrs: _.mix(attrCfg, {
                path: path,
            }),
        });
        return line;
    },
});
base_1.registerShape('edge', 'smooth', {
    draw: function (cfg, container) {
        var points = cfg.points;
        var attrCfg = _getAttrs(cfg);
        var path = _createSmoothPath(points[0], points[1]);
        path = this.parsePath(path);
        var line = container.addShape('path', {
            attrs: _.mix(attrCfg, {
                path: path,
            }),
        });
        return line;
    },
});
// 弧线包括:
// 1. 笛卡尔坐标系下的半圆弧线
// 2. 极坐标系下以圆心为控制点的二阶曲线
// 3. 笛卡尔坐标系下带权重的三阶曲线
// 4. 极坐标系下带权重的以圆心为控制点的二阶曲线
base_1.registerShape('edge', 'arc', {
    draw: function (cfg, container) {
        var points = cfg.points;
        var type = points.length > 2 ? 'weight' : 'normal';
        var attrCfg = _getAttrs(cfg);
        var line;
        var path;
        if (cfg.isInCircle) {
            var center = {
                x: 0,
                y: 1,
            };
            if (type === 'normal') {
                path = _createArcPath(points[0], points[1], center);
            }
            else {
                attrCfg.fill = attrCfg.stroke;
                path = _createArcWeightPath(points, center);
            }
            path = this.parsePath(path);
            line = container.addShape('path', {
                attrs: _.mix(attrCfg, {
                    path: path,
                }),
            });
        }
        else {
            if (type === 'normal') {
                points = this.parsePoints(points);
                line = container.addShape('arc', {
                    attrs: _.mix(attrCfg, {
                        x: (points[1].x + points[0].x) / 2,
                        y: points[0].y,
                        r: Math.abs((points[1].x - points[0].x)) / 2,
                        startAngle: Math.PI,
                        endAngle: Math.PI * 2,
                    }),
                });
            }
            else {
                path = [
                    ['M', points[0].x, points[0].y],
                    ['L', points[1].x, points[1].y],
                ];
                var c1 = _getCPath(points[1], points[3]);
                var c2 = _getCPath(points[2], points[0]);
                path.push(c1);
                path.push(['L', points[3].x, points[3].y]);
                path.push(['L', points[2].x, points[2].y]);
                path.push(c2);
                path.push(['Z']);
                path = this.parsePath(path);
                attrCfg.fill = attrCfg.stroke;
                line = container.addShape('path', {
                    attrs: _.mix(attrCfg, {
                        path: path,
                    }),
                });
            }
        }
        return line;
    },
});
exports.default = EdgeShapeFactory;
//# sourceMappingURL=edge.js.map