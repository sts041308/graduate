"use strict";
/**
 * @description Element 上 tooltip 的辅助类
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("@antv/util");
var FIELD_ORIGIN = '_origin';
function _snapEqual(v1, v2, scale) {
    var value1 = scale.translate(v1);
    var value2 = scale.translate(v2);
    if (scale.isCategory) {
        return value1 === value2;
    }
    return _.isNumberEqual(value1, value2);
}
function _getScaleName(scale) {
    return scale.alias || scale.field;
}
var TooltipController = /** @class */ (function () {
    function TooltipController(element) {
        this.element = null;
        this._xDistance = null;
        this.element = element;
    }
    /**
     * 根据画布坐标在 source 中查找匹配的数据
     * @param point 画布坐标
     * @param source 数据源(已排序)
     */
    TooltipController.prototype.findPoint = function (point, source) {
        if (source.length === 0)
            return null; // 数据为空
        var element = this.element;
        var elementType = element.get('type');
        var xScale = element.getXScale();
        var yScale = element.getYScale();
        var xField = xScale.field;
        var yField = yScale.field;
        var rst = null;
        if (elementType === 'point' || elementType === 'heatmap') {
            // 将 point 画布坐标转换为原始数据值
            var coord = element.get('coord');
            var invertPoint = coord.invert(point); // 转换成归一化的数据
            var xValue_1 = xScale.invert(invertPoint.x); // 转换为原始值
            var yValue_1 = yScale.invert(invertPoint.y); // 转换为原始值
            // 根据最小逼近原则查找 point 击中的数据
            var min_1 = Infinity;
            _.each(source, function (obj) {
                var originData = obj[FIELD_ORIGIN];
                var distance = Math.pow((originData[xField] - xValue_1), 2) +
                    Math.pow((originData[yField] - yValue_1), 2);
                if (distance < min_1) {
                    min_1 = distance;
                    rst = obj;
                }
            });
            return rst;
        }
        // 其他 Element 类型按照 x 字段数据进行查找
        var first = source[0];
        var last = source[source.length - 1];
        var xValue = this._getXValueByPoint(point);
        var firstXValue = first[FIELD_ORIGIN][xField];
        var firstYValue = first[FIELD_ORIGIN][yField];
        var lastXValue = last[FIELD_ORIGIN][xField];
        var isYArray = yScale.isLinear && _.isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况
        // 如果 x 的值是数组
        if (_.isArray(firstXValue)) {
            _.each(source, function (record) {
                var origin = record[FIELD_ORIGIN];
                // xValue 在 origin[xField] 的数值区间内
                if (xScale.translate(origin[xField][0]) <= xValue && xScale.translate(origin[xField][1]) >= xValue) {
                    if (isYArray) { // 层叠直方图场景，x 和 y 都是数组区间
                        if (!_.isArray(rst)) {
                            rst = [];
                        }
                        rst.push(record);
                    }
                    else {
                        rst = record;
                        return false;
                    }
                }
            });
            if (_.isArray(rst)) {
                rst = this._filterYValue(rst, point);
            }
        }
        else {
            var next_1;
            if (!xScale.isLinear && xScale.type !== 'timeCat') { // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找
                _.each(source, function (record, index) {
                    var origin = record[FIELD_ORIGIN];
                    if (_snapEqual(origin[xField], xValue, xScale)) {
                        if (isYArray) {
                            if (!_.isArray(rst)) {
                                rst = [];
                            }
                            rst.push(record);
                        }
                        else {
                            rst = record;
                            return false;
                        }
                    }
                    else if (xScale.translate(origin[xField]) <= xValue) {
                        last = record;
                        next_1 = source[index + 1];
                    }
                });
                if (_.isArray(rst)) {
                    rst = this._filterYValue(rst, point);
                }
            }
            else { // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好
                if (xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) { // 不在数据范围内
                    return null;
                }
                var firstIdx = 0;
                var lastIdx = source.length - 1;
                var middleIdx = void 0;
                while (firstIdx <= lastIdx) {
                    middleIdx = Math.floor((firstIdx + lastIdx) / 2);
                    var item = source[middleIdx][FIELD_ORIGIN][xField];
                    if (_snapEqual(item, xValue, xScale)) {
                        return source[middleIdx];
                    }
                    if (xScale.translate(item) <= xScale.translate(xValue)) {
                        firstIdx = middleIdx + 1;
                        last = source[middleIdx];
                        next_1 = source[middleIdx + 1];
                    }
                    else {
                        if (lastIdx === 0) {
                            last = source[0];
                        }
                        lastIdx = middleIdx - 1;
                    }
                }
            }
            if (last && next_1) { // 计算最逼近的
                if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) >
                    Math.abs(xScale.translate(next_1[FIELD_ORIGIN][xField]) - xValue)) {
                    last = next_1;
                }
            }
        }
        var distance = this._getXDistance(); // 每个分类间的平均间距
        if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {
            rst = last;
        }
        return rst;
    };
    /**
     * 根据数据获取对应的 tooltip items 信息
     * @param data 数据记录
     * @param titleField tooltip title 字段名
     */
    TooltipController.prototype.getTooltipItems = function (data, titleField) {
        var element = this.element;
        var origin = data[FIELD_ORIGIN];
        var tooltipTitle = this._getTooltipTitle(origin, titleField);
        var tooltipOptions = element.get('tooltipOptions');
        var defaultColor = element.get('theme').defaultColor;
        var size = this._getSize(data);
        var items = [];
        var name;
        var value;
        function addItem(itemName, itemValue) {
            if (!_.isNil(itemValue) && itemValue !== '') { // 值为 null的时候，忽视
                var item = {
                    title: tooltipTitle,
                    point: data,
                    name: itemName || tooltipTitle,
                    value: itemValue,
                    color: data.color || defaultColor,
                    marker: true,
                    size: size,
                };
                items.push(item);
            }
        }
        if (tooltipOptions) {
            var fields = tooltipOptions.fields, callback = tooltipOptions.callback;
            if (callback) { // 用户定义了回调函数
                var callbackParams = fields.map(function (field) {
                    return data[FIELD_ORIGIN][field];
                });
                var cfg = callback.apply(void 0, callbackParams);
                var itemCfg = tslib_1.__assign({ point: data, title: tooltipTitle, color: data.color || defaultColor, marker: true, // 默认展示 marker
                    size: size }, cfg);
                items.push(itemCfg);
            }
            else {
                var scales_1 = element.get('scales');
                _.each(fields, function (field) {
                    if (!_.isNil(origin[field])) { // 字段数据为null, undefined 时不显示
                        var scale = scales_1[field];
                        name = _getScaleName(scale);
                        value = scale.getText(origin[field]);
                        addItem(name, value);
                    }
                });
            }
        }
        else {
            var valueScale = this._getTooltipValueScale();
            if (!_.isNil(origin[valueScale.field])) { // 字段数据为null ,undefined时不显示
                value = this._getTooltipValue(origin, valueScale);
                name = this._getTooltipName(origin);
                addItem(name, value);
            }
        }
        return items;
    };
    TooltipController.prototype.clear = function () {
        this._xDistance = null;
    };
    // 返回画布坐标点对应的 x 字段数值
    TooltipController.prototype._getXValueByPoint = function (point) {
        var result = 0;
        var element = this.element;
        var coord = element.get('coord');
        var xScale = element.getXScale();
        var range = xScale.range;
        var rangeMax = range[range.length - 1];
        var rangeMin = range[0];
        var invertPoint = coord.invert(point);
        var xValue = invertPoint.x;
        if (element.isInCircle() && xValue > (1 + rangeMax) / 2) {
            xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理 see view.js#L88
        }
        result = xScale.invert(xValue);
        if (xScale.isCategory) { // 分类类型，要将字符串类型转换成数字
            result = xScale.translate(result);
        }
        return result;
    };
    TooltipController.prototype._filterYValue = function (arr, point) {
        var element = this.element;
        var coord = element.get('coord');
        var yScale = element.getYScale();
        var yField = yScale.field;
        var invertPoint = coord.invert(point);
        var yValue = yScale.invert(invertPoint.y);
        var rst = arr[arr.length - 1];
        _.each(arr, function (obj) {
            var origin = obj[FIELD_ORIGIN];
            if ((origin[yField][0] <= yValue) && (origin[yField][1] >= yValue)) {
                rst = obj;
                return false;
            }
        });
        return rst;
    };
    TooltipController.prototype._getXDistance = function () {
        var distance = this._xDistance;
        if (!distance) {
            var element = this.element;
            var xScale_1 = element.getXScale();
            if (xScale_1.isCategory) {
                distance = 1;
            }
            else {
                var values = xScale_1.values; // values 是无序的
                var min_2 = xScale_1.translate(values[0]);
                var max_1 = min_2;
                _.each(values, function (value) {
                    var numericValue = xScale_1.translate(value);
                    if (numericValue < min_2) {
                        min_2 = numericValue;
                    }
                    if (numericValue > max_1) {
                        max_1 = numericValue;
                    }
                });
                var length_1 = values.length;
                // 应该是除以 length - 1
                distance = (max_1 - min_2) / (length_1 - 1);
            }
            this._xDistance = distance; // 缓存，防止重复计算
        }
        return distance;
    };
    // 获取 title 字段对应的度量
    TooltipController.prototype._getTooltipTitleScale = function (titleField) {
        var element = this.element;
        var scales = element.get('scales');
        if (titleField) {
            return scales[titleField];
        }
        var positionAttr = element.getAttr('position');
        var fields = positionAttr.getFields();
        return scales[fields[0]];
    };
    // 获取原始数据的 tooltip title 字符串
    TooltipController.prototype._getTooltipTitle = function (originData, titleField) {
        var tooltipTitle = '';
        var element = this.element;
        var titleScale = this._getTooltipTitleScale(titleField);
        if (titleScale) {
            var value = originData[titleScale.field];
            tooltipTitle = titleScale.getText(value);
        }
        else if (element.get('type') === 'heatmap') { // 热力图在不存在 title 的时候特殊处理
            var xScale = element.getXScale();
            var yScale = element.getYScale();
            var xValue = xScale.getText(originData[xScale.field]);
            var yValue = yScale.getText(originData[yScale.field]);
            tooltipTitle = "( " + xValue + ", " + yValue + " )";
        }
        return tooltipTitle;
    };
    // 获取 tooltip value 值对应的度量
    TooltipController.prototype._getTooltipValueScale = function () {
        var element = this.element;
        var attrs = element.getAttrsForLegend();
        var scale;
        _.each(attrs, function (attr) {
            var tmpScale = attr.getScale(attr.type);
            if (tmpScale && tmpScale.isLinear) { // 如果指定字段是非 position 的，同时是连续的
                scale = tmpScale;
                return false;
            }
        });
        var xScale = element.getXScale();
        var yScale = element.getYScale();
        return scale || yScale || xScale;
    };
    // 根据原始数据以及对应的 value 度量获取 tooltip 对应的 value 值
    TooltipController.prototype._getTooltipValue = function (originData, valueScale) {
        var field = valueScale.field;
        var value = originData[field];
        if (_.isArray(value)) {
            var values = value.map(function (eachValue) {
                return valueScale.getText(eachValue);
            });
            return values.join('-');
        }
        return valueScale.getText(value);
    };
    // 根据原始数据获取 tooltip item 中 name 值
    TooltipController.prototype._getTooltipName = function (originData) {
        var nameScale;
        var element = this.element;
        var groupScales = element.getGroupScales();
        if (groupScales.length) { // 如果存在分组类型，取第一个分组类型
            _.each(groupScales, function (scale) {
                nameScale = scale;
                return false;
            });
        }
        if (nameScale) {
            var field = nameScale.field;
            return nameScale.getText(originData[field]);
        }
        var valueScale = this._getTooltipValueScale();
        return _getScaleName(valueScale);
    };
    // TODO: 需要改造
    TooltipController.prototype._getSize = function (obj) {
        var element = this.element;
        var coord = element.get('coord');
        var size = element.getSize(obj[FIELD_ORIGIN]);
        if (coord.isRect && size) {
            var dim = coord.isTransposed ? 'y' : 'x';
            if (_.isArray(obj[dim])) {
                var width = Math.abs(obj[dim][1] - obj[dim][0]);
                size = size < width ? null : size; // 直方图计算错误
            }
        }
        return size;
    };
    return TooltipController;
}());
exports.default = TooltipController;
//# sourceMappingURL=tooltip.js.map