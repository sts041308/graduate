"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var component_1 = require("@antv/component");
var g_1 = require("@antv/g");
var _ = require("@antv/util");
var IGNORE_ARR = ['line', 'point', 'path'];
var ORIGIN = '_origin';
function avg(arr) {
    var sum = 0;
    _.each(arr, function (value) {
        sum += value;
    });
    return sum / arr.length;
}
// 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon
function getCentroid(xs, ys) {
    if (_.isNumber(xs) && _.isNumber(ys)) { // 普通色块图，xs 和 ys 是数值
        return [xs, ys];
    }
    var i = -1;
    var x = 0;
    var y = 0;
    var former;
    var current = xs.length - 1;
    var diff;
    var k = 0;
    while (++i < xs.length) {
        former = current;
        current = i;
        k += diff = xs[former] * ys[current] - xs[current] * ys[former];
        x += (xs[former] + xs[current]) * diff;
        y += (ys[former] + ys[current]) * diff;
    }
    k *= 3;
    return [x / k, y / k];
}
var ElementLabels = /** @class */ (function (_super) {
    tslib_1.__extends(ElementLabels, _super);
    function ElementLabels(cfg) {
        var _this = _super.call(this, tslib_1.__assign({ labelOptions: null, coord: null, elementType: null, zIndex: 6 }, cfg)) || this;
        _this.set('defaultLabelCfg', _this.get('theme').label);
        return _this;
    }
    ElementLabels.prototype._renderUI = function () {
        _super.prototype._renderUI.call(this);
        var labelsGroup = this.addGroup({
            name: 'element-labels-group',
        });
        var lineGroup = this.addGroup({
            name: 'element-labels-line-group',
        });
        var labelsRenderer = new component_1.Label();
        labelsRenderer.set('coord', this.get('coord'));
        labelsRenderer.set('group', labelsGroup);
        labelsRenderer.set('lineGroup', lineGroup);
        this.set('labelsRenderer', labelsRenderer);
        this.set('labelsGroup', labelsGroup);
        this.set('lineGroup', lineGroup);
    };
    ElementLabels.prototype.destroy = function () {
        this.get('labelsRenderer').destroy(); // 清理文本
        _super.prototype.destroy.call(this);
    };
    ElementLabels.prototype.showLabels = function (points, originShapes) {
        var labelsRenderer = this.get('labelsRenderer');
        var items = this.getLabelsItems(points, originShapes);
        var shapes = [].concat(originShapes);
        var type = this.get('type');
        items = this.adjustItems(items, shapes);
        this.drawLines(items);
        labelsRenderer.set('items', items.filter(function (item, i) {
            if (!item) {
                shapes.splice(i, 1);
                return false;
            }
            return true;
        }));
        if (type) {
            labelsRenderer.set('shapes', shapes);
            labelsRenderer.set('type', type);
            labelsRenderer.set('points', points);
        }
        labelsRenderer.set('canvas', this.get('canvas'));
        labelsRenderer.draw();
    };
    ElementLabels.prototype.adjustItems = function (items, shapes) {
        _.each(items, function (item) {
            if (!item) {
                return;
            }
            if (item.offsetX) {
                item.x += item.offsetX;
            }
            if (item.offsetY) {
                item.y += item.offsetY;
            }
        });
        return items;
    };
    /**
     * drawing lines to labels
     * @param  {Array} items labels
     * @param  {Object} labelLine configuration for label lines
     */
    ElementLabels.prototype.drawLines = function (items) {
        var _this = this;
        _.each(items, function (point) {
            if (!point) {
                return;
            }
            if (point.offset > 0 && point.labelLine) {
                _this.lineToLabel(point);
            }
        });
    };
    // 定义连接线
    ElementLabels.prototype.lineToLabel = function (point) { };
    ElementLabels.prototype.setLabelPosition = function (label, point, index, position) { };
    ElementLabels.prototype.transLabelPoint = function (point) {
        var coord = this.get('coord');
        var tmpPoint = coord.applyMatrix(point.x, point.y, 1);
        point.x = tmpPoint[0];
        point.y = tmpPoint[1];
    };
    ElementLabels.prototype.getOffsetVector = function (point) {
        var offset = point.offset || 0;
        var coord = this.get('coord');
        var vector;
        if (coord.isTransposed) { // 如果x,y翻转，则偏移x
            vector = coord.applyMatrix(offset, 0);
        }
        else { // 否则，偏转y
            vector = coord.applyMatrix(0, offset);
        }
        return vector;
    };
    // 获取默认的偏移量
    ElementLabels.prototype.getDefaultOffset = function (point) {
        var offset = 0;
        var coord = this.get('coord');
        var vector = this.getOffsetVector(point);
        if (coord.isTransposed) { // 如果x,y翻转，则偏移x
            offset = vector[0];
        }
        else { // 否则，偏转y
            offset = vector[1];
        }
        return offset;
    };
    // 获取文本的偏移位置，x,y
    ElementLabels.prototype.getLabelOffset = function (point, index, total) {
        var offset = this.getDefaultOffset(point);
        var coord = this.get('coord');
        var transposed = coord.isTransposed;
        var yField = transposed ? 'x' : 'y';
        var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成
        var offsetPoint = {
            x: 0,
            y: 0,
        };
        if (index > 0 || total === 1) { // 判断是否小于0
            offsetPoint[yField] = offset * factor;
        }
        else {
            offsetPoint[yField] = offset * factor * -1;
        }
        return offsetPoint;
    };
    /**
     * @protected
     * 获取labels
     * @param {Array} points points
     * @param {Array} shapes shapes
     * @return {Array} label items
     */
    ElementLabels.prototype.getLabelsItems = function (points, shapes) {
        var _this = this;
        var items = [];
        var element = this.get('element');
        var coord = this.get('coord');
        var labelOptions = this._getlabelOptions(points, shapes);
        // 获取label相关的x，y的值，获取具体的x,y,防止存在数组
        _.each(points, function (point, i) {
            var origin = point[ORIGIN];
            var label = labelOptions[i];
            if (!label) {
                items.push(null);
                return;
            }
            if (!_.isArray(label.text)) {
                label.text = [label.text];
            }
            var total = label.length;
            _.each(label.text, function (sub, subIndex) {
                if (_.isNil(sub) || sub === '') {
                    items.push(null);
                    return;
                }
                var obj = _this.getLabelPoint(label, point, subIndex);
                obj = _.mix({}, label, obj);
                if (!obj.textAlign) {
                    obj.textAlign = _this.getLabelAlign(obj, subIndex, total);
                }
                if (element) {
                    obj.id = element.getShapeId(origin) + "-glabel-" + subIndex + "-" + obj.text;
                }
                obj.coord = coord;
                items.push(obj);
            });
        });
        return items;
    };
    /**
     * @protected
     * 获取文本的位置信息
     * @param {Array} labelOptions labels
     * @param {Object} point point
     * @param {Number} index index
     * @return {Object} point
     */
    ElementLabels.prototype.getLabelPoint = function (labelOptions, point, index) {
        var coord = this.get('coord');
        var total = labelOptions.text.length;
        function getDimValue(value, idx) {
            var v = value;
            if (_.isArray(v)) {
                if (labelOptions.text.length === 1) { // 如果仅一个label,多个y,取最后一个y
                    if (v.length <= 2) {
                        v = v[value.length - 1];
                    }
                    else {
                        v = avg(v);
                    }
                }
                else {
                    v = v[idx];
                }
            }
            return v;
        }
        var label = {
            text: labelOptions.text[index],
            x: 0,
            y: 0,
            start: { x: 0, y: 0 },
            color: '#fff',
        };
        // 多边形场景,多用于地图
        if (point && this.get('elementType') === 'polygon') {
            var centroid = getCentroid(point.x, point.y);
            label.x = centroid[0];
            label.y = centroid[1];
        }
        else {
            label.x = getDimValue(point.x, index);
            label.y = getDimValue(point.y, index);
        }
        // get nearest point of the shape as the label line start point
        if (point && point.nextPoints && (point.shape === 'funnel' || point.shape === 'pyramid')) {
            var maxX_1 = -Infinity;
            point.nextPoints.forEach(function (p) {
                var p1 = coord.convert(p);
                if (p1.x > maxX_1) {
                    maxX_1 = p1.x;
                }
            });
            label.x = (label.x + maxX_1) / 2;
        }
        // sharp edge of the pyramid
        if (point.shape === 'pyramid' && !point.nextPoints && point.points) {
            point.points.forEach(function (p) {
                var p1 = p;
                p1 = coord.convert(p1);
                if ((_.isArray(p1.x) && point.x.indexOf(p1.x) === -1) || (_.isNumber(p1.x) && point.x !== p1.x)) {
                    label.x = (label.x + p1.x) / 2;
                }
            });
        }
        if (labelOptions.position) {
            this.setLabelPosition(label, point, index, labelOptions.position);
        }
        var offsetPoint = this.getLabelOffset(labelOptions, index, total);
        if (labelOptions.offsetX) {
            offsetPoint.x += labelOptions.offsetX;
        }
        if (labelOptions.offsetY) {
            offsetPoint.y += labelOptions.offsetY;
        }
        this.transLabelPoint(label);
        label.start = { x: label.x, y: label.y };
        label.x += offsetPoint.x;
        label.y += offsetPoint.y;
        label.color = point.color;
        return label;
    };
    ElementLabels.prototype.getLabelAlign = function (point, index, total) {
        var align = 'center';
        var coord = this.get('coord');
        if (coord.isTransposed) {
            var offset = this.getDefaultOffset(point);
            if (offset < 0) {
                align = 'right';
            }
            else if (offset === 0) {
                align = 'center';
            }
            else {
                align = 'left';
            }
            if (total > 1 && index === 0) {
                if (align === 'right') {
                    align = 'left';
                }
                else if (align === 'left') {
                    align = 'right';
                }
            }
        }
        return align;
    };
    ElementLabels.prototype._getLabelValue = function (origin, originScales) {
        var scales = originScales;
        if (!_.isArray(scales)) {
            scales = [scales];
        }
        var text = [];
        _.each(scales, function (scale) {
            var value = origin[scale.field];
            if (_.isArray(value)) {
                var tmp_1 = [];
                _.each(value, function (subVal) {
                    tmp_1.push(scale.getText(subVal));
                });
                value = tmp_1;
            }
            else {
                value = scale.getText(value);
            }
            if (_.isNil(value) || value === '') {
                text.push(null);
            }
            else {
                text.push(value);
            }
        });
        return text;
    };
    // 获取每个label的配置
    ElementLabels.prototype._getlabelOptions = function (points, shapes) {
        var _this = this;
        var elementType = this.get('elementType');
        var theme = this.get('theme');
        var labelOptions = this.get('labelOptions');
        var scales = labelOptions.scales;
        var cfgs = [];
        _.each(points, function (point, i) {
            var cfg = {};
            var origin = point[ORIGIN];
            var originText = _this._getLabelValue(origin, scales);
            if (labelOptions.callback) {
                // callback 中应使用原始数据，而不是数据字符串
                var originValues = scales.map(function (scale) { return origin[scale.field]; });
                cfg = labelOptions.callback.apply(labelOptions, originValues);
            }
            if (_.isNil(cfg)) {
                cfgs.push(null);
                return;
            }
            if (_.isString(cfg.content)) {
                cfg.text = cfg.content;
                delete cfg.content;
            }
            else if (_.isFunction(cfg.content)) {
                cfg.text = cfg.content(origin, point, i);
                delete cfg.content;
            }
            else {
                cfg.text = originText[0]; // 默认展示声明的第一个字段对应的值
            }
            if (cfg.htmlTemplate) {
                cfg.useHtml = true;
                cfg.text = cfg.htmlTemplate(origin, point, i);
                delete cfg.htmlTemplate;
            }
            if (cfg.formatter) {
                cfg.text = cfg.formatter.call(null, cfg.text, point, i);
                delete cfg.formatter;
            }
            if (elementType === 'polygon' ||
                (cfg.offset < 0 && _.indexOf(IGNORE_ARR, elementType) === -1)) {
                cfg = _.deepMix({}, _this.get('defaultLabelCfg'), theme.innerLabels, cfg);
            }
            else {
                cfg = _.deepMix({}, _this.get('defaultLabelCfg'), theme.label, cfg);
            }
            // 将 shape 的原始数据存入
            cfg.origin = origin;
            // delete cfg.items;
            cfgs.push(cfg);
        });
        return cfgs;
    };
    return ElementLabels;
}(g_1.Group));
exports.default = ElementLabels;
//# sourceMappingURL=base.js.map