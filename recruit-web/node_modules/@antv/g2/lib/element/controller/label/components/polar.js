"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("@antv/util");
var base_1 = require("./base");
var PathUtil = require("../../../util/path");
var PolarElementLabels = /** @class */ (function (_super) {
    tslib_1.__extends(PolarElementLabels, _super);
    function PolarElementLabels() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * 获取文本的位置信息
     * @param {Array} label labels
     * @param {Object} point point
     * @param {Number} index index
     * @return {Object} point
     */
    PolarElementLabels.prototype.getLabelPoint = function (label, point, i) {
        var index = i;
        var text = label.text[index];
        var factor = 1;
        var arcPoint;
        if (this._isToMiddle(point)) {
            arcPoint = this._getMiddlePoint(point.points);
        }
        else {
            if (label.text.length === 1 && index === 0) {
                index = 1;
            }
            else if (index === 0) {
                factor = -1;
            }
            arcPoint = this.getArcPoint(point, index);
        }
        var offset = this.getDefaultOffset(label);
        offset = offset * factor;
        var middleAngle = this.getPointAngle(arcPoint);
        var isLabelEmit = label.labelEmit;
        var labelPoint = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
        if (!labelPoint) {
            labelPoint = { text: '' };
        }
        else {
            labelPoint.text = text;
            labelPoint.angle = middleAngle;
            labelPoint.color = point.color;
        }
        if (label.autoRotate || label.autoRotate === undefined) { // 自动旋转文本呢
            labelPoint.rotate = this.getLabelRotate(middleAngle, offset, isLabelEmit);
        }
        else {
            labelPoint.rotate = label.rotate;
        }
        labelPoint.start = {
            x: arcPoint.x,
            y: arcPoint.y,
        };
        return labelPoint;
    };
    PolarElementLabels.prototype.getCirclePoint = function (originAngle, offset, point, isLabelEmit) {
        var coord = this.get('coord');
        var center = coord.getCenter();
        var angle = originAngle;
        var r = PathUtil.getPointRadius(coord, point);
        if (r === 0) {
            return null;
        }
        if (coord.isTransposed && r > offset && !isLabelEmit) {
            var appendAngle = Math.asin(offset / (2 * r));
            angle = angle + appendAngle * 2;
        }
        else {
            r = r + offset;
        }
        return {
            x: center.x + r * Math.cos(angle),
            y: center.y + r * Math.sin(angle),
            angle: angle,
            r: r,
        };
    };
    PolarElementLabels.prototype.getArcPoint = function (point, i) {
        var index = i;
        var outerPoint; // 圆弧上的中点
        index = index || 0;
        if (_.isArray(point.x) || _.isArray(point.y)) {
            outerPoint = {
                x: _.isArray(point.x) ? point.x[index] : point.x,
                y: _.isArray(point.y) ? point.y[index] : point.y,
            };
        }
        else {
            outerPoint = point;
        }
        this.transLabelPoint(outerPoint);
        return outerPoint;
    };
    // 获取点所在的角度
    PolarElementLabels.prototype.getPointAngle = function (point) {
        var coord = this.get('coord');
        return PathUtil.getPointAngle(coord, point);
    };
    /**
     * @protected
     * 获取文本旋转的方向
     * @param {Number} angle angle
     * @return {Number} angle
     */
    PolarElementLabels.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {
        var rotate;
        rotate = angle * 180 / Math.PI;
        rotate += 90;
        if (isLabelEmit) {
            rotate -= 90;
        }
        if (rotate) {
            if (rotate > 90) {
                rotate = rotate - 180;
            }
            else if (rotate < -90) {
                rotate = rotate + 180;
            }
        }
        return rotate / 180 * Math.PI;
    };
    // override
    PolarElementLabels.prototype.getLabelAlign = function (point) {
        var coord = this.get('coord');
        var align;
        if (point.labelEmit) {
            if (point.angle <= Math.PI / 2 && point.angle > -Math.PI / 2) {
                align = 'left';
            }
            else {
                align = 'right';
            }
        }
        else if (!coord.isTransposed) {
            align = 'center';
        }
        else {
            var center = coord.getCenter();
            var offset = this.getDefaultOffset(point);
            if (Math.abs(point.x - center.x) < 1) {
                align = 'center';
            }
            else if (point.angle > Math.PI || point.angle <= 0) {
                if (offset > 0) {
                    align = 'left';
                }
                else {
                    align = 'right';
                }
            }
            else {
                if (offset > 0) {
                    align = 'right';
                }
                else {
                    align = 'left';
                }
            }
        }
        return align;
    };
    // 定义连接线
    PolarElementLabels.prototype.lineToLabel = function (point) { };
    // 获取中心的位置
    PolarElementLabels.prototype._getMiddlePoint = function (points) {
        var coord = this.get('coord');
        var count = points.length;
        var middlePoint = {
            x: 0,
            y: 0,
        };
        _.each(points, function (point) {
            middlePoint.x += point.x;
            middlePoint.y += point.y;
        });
        middlePoint.x /= count;
        middlePoint.y /= count;
        middlePoint = coord.convert(middlePoint);
        return middlePoint;
    };
    // 是否居中
    PolarElementLabels.prototype._isToMiddle = function (point) {
        return point.x.length > 2;
    };
    return PolarElementLabels;
}(base_1.default));
exports.default = PolarElementLabels;
//# sourceMappingURL=polar.js.map