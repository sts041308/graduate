"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("@antv/util");
var matrix_util_1 = require("@antv/matrix-util");
var g_1 = require("@antv/g");
function getAnimateParam(animateCfg, index, id) {
    return {
        delay: _.isFunction(animateCfg.delay) ? animateCfg.delay(index, id) : animateCfg.delay,
        easing: _.isFunction(animateCfg.easing) ? animateCfg.easing(index, id) : animateCfg.easing,
        duration: _.isFunction(animateCfg.duration) ? animateCfg.duration(index, id) : animateCfg.duration,
        callback: animateCfg.callback,
    };
}
exports.getAnimateParam = getAnimateParam;
function getCoordRange(coord) {
    var start = coord.start, end = coord.end;
    return {
        start: start,
        end: end,
        width: coord.getWidth(),
        height: coord.getWidth(),
    };
}
exports.getCoordRange = getCoordRange;
function getClip(coord) {
    var start = coord.start, end = coord.end, width = coord.width, height = coord.height;
    var margin = 200;
    var clip;
    if (coord.isPolar) {
        var startAngle = coord.startAngle, endAngle = coord.endAngle;
        var center = coord.getCenter();
        var radius = coord.getRadius();
        clip = new g_1.Shapes.Fan({
            attrs: {
                x: center.x,
                y: center.y,
                rs: 0,
                re: radius + margin,
                startAngle: startAngle,
                endAngle: startAngle,
            },
        });
        clip.endState = {
            endAngle: endAngle,
        };
    }
    else {
        clip = new g_1.Shapes.Rect({
            attrs: {
                x: start.x - margin,
                y: end.y - margin,
                width: coord.isTransposed ? width + margin * 2 : 0,
                height: coord.isTransposed ? 0 : height + margin * 2,
            },
        });
        if (coord.isTransposed) {
            clip.endState = {
                height: height + margin * 2,
            };
        }
        else {
            clip.endState = {
                width: width + margin * 2,
            };
        }
    }
    clip.set('isClip', true);
    return clip;
}
exports.getClip = getClip;
function getScaledMatrix(shape, v, direct) {
    var scaledMatrix;
    shape.apply(v);
    var x = v[0];
    var y = v[1];
    if (direct === 'x') {
        shape.transform([
            ['t', -x, -y],
            ['s', 0.01, 1],
            ['t', x, y],
        ]);
        var matrix = shape.getMatrix();
        scaledMatrix = matrix_util_1.mat3.transform(matrix, [
            ['t', -x, -y],
            ['s', 100, 1],
            ['t', x, y],
        ]);
    }
    else if (direct === 'y') {
        shape.transform([
            ['t', -x, -y],
            ['s', 1, 0.01],
            ['t', x, y],
        ]);
        var matrix = shape.getMatrix();
        scaledMatrix = matrix_util_1.mat3.transform(matrix, [
            ['t', -x, -y],
            ['s', 1, 100],
            ['t', x, y],
        ]);
    }
    else if (direct === 'xy') {
        shape.transform([
            ['t', -x, -y],
            ['s', 0.01, 0.01],
            ['t', x, y],
        ]);
        var matrix = shape.getMatrix();
        scaledMatrix = matrix_util_1.mat3.transform(matrix, [
            ['t', -x, -y],
            ['s', 100, 100],
            ['t', x, y],
        ]);
    }
    return scaledMatrix;
}
exports.getScaledMatrix = getScaledMatrix;
function doAnimation(shape, endState, animateCfg) {
    var id = shape.id;
    var index = shape.get('index');
    var _a = getAnimateParam(animateCfg, index, id), easing = _a.easing, delay = _a.delay, duration = _a.duration, callback = _a.callback;
    shape.animate(endState, duration, easing, callback, delay);
}
exports.doAnimation = doAnimation;
function doGroupScaleIn(container, animateCfg, coord, zeroY, type) {
    var _a = getCoordRange(coord), start = _a.start, end = _a.end, width = _a.width, height = _a.height;
    var x;
    var y;
    var clip = new g_1.Shapes.Rect({
        attrs: {
            x: start.x,
            y: end.y,
            width: width,
            height: height,
        },
    });
    if (type === 'y') {
        x = start.x + width / 2;
        y = zeroY.y < start.y ? zeroY.y : start.y;
    }
    else if (type === 'x') {
        x = zeroY.x > start.x ? zeroY.x : start.x;
        y = start.y + height / 2;
    }
    else if (type === 'xy') {
        if (coord.isPolar) {
            x = coord.getCenter().x;
            y = coord.getCenter().y;
        }
        else {
            x = (start.x + end.x) / 2;
            y = (start.y + end.y) / 2;
        }
    }
    var endMatrix = getScaledMatrix(clip, [x, y, 1], type);
    clip.set('isClip', true);
    clip.set('canvas', container.get('canvas'));
    container.attr('clip', clip);
    animateCfg.callback = function () {
        container.attr('clip', null);
        clip.remove();
    };
    doAnimation(clip, { matrix: endMatrix }, animateCfg);
}
exports.doGroupScaleIn = doGroupScaleIn;
//# sourceMappingURL=util.js.map