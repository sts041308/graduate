"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var matrix_util_1 = require("@antv/matrix-util");
var _ = require("@antv/util");
var animate_1 = require("./animate");
/*
 * 获取图组内所有的shapes
 */
function getShapes(container, viewId) {
    var shapes = [];
    if (container.get('animate') === false) {
        return [];
    }
    var children = container.get('children');
    _.each(children, function (child) {
        // 这里child定义为Group|Shape后，tslint会报错。根源解决需要在g -> element类增加isGroup/isShape/id属性。这里暂时忽略tslint
        // @ts-ignore
        if (child.isGroup) {
            // @ts-ignore
            shapes = shapes.concat(getShapes(child, viewId));
            // @ts-ignore
        }
        else if (child.isShape && child.id) {
            // @ts-ignore
            var id = child.id;
            id = id.split('-')[0];
            if (id === viewId) {
                shapes.push(child);
            }
        }
    });
    return shapes;
}
/**
 * collect shape info.
 * @param shapes
 */
function cache(shapes) {
    var rst = {};
    _.each(shapes, function (shape) {
        if (!shape.id || shape.get('isClip')) {
            return;
        }
        var id = shape.id;
        rst[id] = {
            id: id,
            type: shape.get('type'),
            attrs: _.clone(shape.attr()),
            // 原始属性
            name: shape.name,
            index: shape.get('index'),
            animateCfg: shape.get('animateOptions'),
            coord: shape.get('coord'),
        };
    });
    return rst;
}
function getAnimate(elementType, coord, animationType, animationName) {
    var result = {};
    if (animationName) {
        result = animate_1.default.Action[animationType][animationName];
    }
    else {
        result = animate_1.default.getAnimation(elementType, coord, animationType);
    }
    return result;
}
function getAnimateCfg(elementType, animationType, animateCfg) {
    // .animate(false) 或者 .animate({ appear: false });
    if (animateCfg === false || (_.isObject(animateCfg) && animateCfg[animationType] === false)) {
        return null;
    }
    var defaultCfg = animate_1.default.getAnimateCfg(elementType, animationType);
    if (animateCfg && animateCfg[animationType]) {
        return _.deepMix({}, defaultCfg, animateCfg[animationType]);
    }
    return defaultCfg;
}
/**
 * canvas draw之前将动画配置添加到动画队列中。
 * @return canvasDrawn(boolean) 是否添加绘制成功
 */
function addAnimate(shapeCache, shapes, canvas) {
    var animate;
    var animateCfg;
    var canvasDrawn = false;
    // Step: leave -> update -> enter
    var updateShapes = []; // 存储的是 shapes
    var newShapes = []; // 存储的是 shapes
    _.each(shapes, function (shape) {
        var result = shapeCache[shape.id];
        if (!result) {
            newShapes.push(shape);
        }
        else {
            shape.setSilent('cacheShape', result);
            updateShapes.push(shape);
            delete shapeCache[shape.id];
        }
    });
    _.each(shapeCache, function (deletedShape) {
        var name = deletedShape.name, coord = deletedShape.coord, id = deletedShape.id, attrs = deletedShape.attrs, index = deletedShape.index, type = deletedShape.type;
        animateCfg = getAnimateCfg(name, 'leave', deletedShape.animateCfg);
        if (!animateCfg) {
            return true;
        } // 用户关闭动画
        animate = getAnimate(name, coord, 'leave', animateCfg.animation);
        if (_.isFunction(animate)) {
            var tempShape = canvas.addShape(type, {
                attrs: attrs,
                index: index,
            });
            tempShape.id = id;
            tempShape.name = name;
            if (coord && name !== 'label') {
                var tempShapeMatrix = tempShape.getMatrix();
                var finalMatrix = matrix_util_1.mat3.multiply([], tempShapeMatrix, coord.matrix);
                tempShape.setMatrix(finalMatrix);
            }
            canvasDrawn = true;
            animate(tempShape, animateCfg, coord);
        }
    });
    _.each(updateShapes, function (updateShape) {
        var name = updateShape.name;
        animateCfg = getAnimateCfg(name, 'update', updateShape.get('animateOptions'));
        if (!animateCfg) {
            return true;
        } // 用户关闭动画
        var coord = updateShape.get('coord');
        var cacheAttrs = updateShape.get('cacheShape').attrs;
        // 判断如果属性相同的话就不进行变换
        if (!_.isEqual(cacheAttrs, updateShape.attr())) {
            animate = getAnimate(name, coord, 'update', animateCfg.animation);
            if (_.isFunction(animate)) {
                animate(updateShape, animateCfg, coord);
            }
            else {
                var endState = _.clone(updateShape.attr());
                updateShape.attr(cacheAttrs);
                updateShape.animate(endState, animateCfg.duration, animateCfg.easing, function () {
                    updateShape.setSilent('cacheShape', null);
                });
            }
            canvasDrawn = true;
        }
    });
    _.each(newShapes, function (newShape) {
        var name = newShape.name;
        var coord = newShape.get('coord');
        animateCfg = getAnimateCfg(name, 'enter', newShape.get('animateOptions'));
        if (!animateCfg) {
            return true;
        } // 用户关闭动画
        animate = getAnimate(name, coord, 'enter', animateCfg.animation);
        if (_.isFunction(animate)) {
            animate(newShape, animateCfg, coord);
            canvasDrawn = true;
        }
    });
    return canvasDrawn;
}
/**
 * 动画模块唯一对外暴露接口
 * @param view
 * @param isUpdate
 */
function execAnimation(view, isUpdate) {
    var newIsUpdate = isUpdate; // eslint: no-param-reassign
    var panelGroup = view.get('panelGroup');
    var backgroundGroup = view.get('backgroundGroup');
    var viewId = view.get('id');
    var canvas = view.get('canvas');
    var caches = canvas.get(viewId + "caches") || [];
    if (caches.length === 0) {
        newIsUpdate = false;
    }
    var shapes = getShapes(panelGroup, viewId);
    var axisShapes = getShapes(backgroundGroup, viewId);
    var cacheShapes = shapes.concat(axisShapes);
    canvas.setSilent(viewId + "caches", cache(cacheShapes));
    var drawn;
    if (newIsUpdate) {
        // 执行更新动画
        drawn = addAnimate(caches, cacheShapes, canvas);
    }
    else {
        // 初入场动画
        // drawn = addAnimate(caches, shapes, canvas, newIsUpdate);
        var animateCfg_1;
        var animate_2;
        var elements = view.get('elements');
        var coord_1 = view.get('coord');
        _.each(elements, function (element) {
            var type = element.get('type');
            var elementAnimateOption = element.get('animateOptions');
            if (elementAnimateOption !== false) {
                // 用户为关闭动画
                animateCfg_1 = getAnimateCfg(type, 'appear', elementAnimateOption);
                if (!animateCfg_1) {
                    return true;
                } // 用户关闭了初始动画
                animate_2 = getAnimate(type, coord_1, 'appear', animateCfg_1.animation);
                if (_.isFunction(animate_2)) {
                    if (animate_2.animationName.indexOf('group') === 0) {
                        // 执行全局动画
                        var yScale = element.getYScale();
                        var zeroY = coord_1.convertPoint({
                            x: 0,
                            y: yScale.scale(element.getYMinValue()),
                        });
                        var container = element.get('container');
                        animate_2 && animate_2(container, animateCfg_1, coord_1, zeroY);
                    }
                    else {
                        var shapeArr = getShapes(element.get('container'), viewId);
                        _.each(shapeArr, function (shape) {
                            if (shape.name === type) {
                                // element shapes 上的动画
                                animate_2(shape, animateCfg_1, coord_1);
                            }
                            else if (shape.name === 'label') {
                                animateCfg_1 = getAnimateCfg('label', 'appear', null);
                                animate_2 = getAnimate(shape.name, coord_1, 'appear', animateCfg_1.animation);
                                if (_.isFunction(animate_2)) {
                                    animate_2(shape, animateCfg_1, coord_1);
                                }
                            }
                        });
                    }
                }
            }
        });
        drawn = true;
    }
    if (!drawn) {
        canvas.draw();
    }
}
exports.default = {
    execAnimation: execAnimation,
};
//# sourceMappingURL=index.js.map