"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = require("@antv/component");
var matrix_util_1 = require("@antv/matrix-util");
var _ = require("@antv/util");
function formatTicks(ticks) {
    var tmp = [];
    if (ticks.length) {
        tmp = ticks.slice(0);
        var first = tmp[0];
        var last = tmp[tmp.length - 1];
        if (first.value !== 0) {
            tmp.unshift({
                value: 0,
            });
        }
        if (last.value !== 1) {
            tmp.push({
                value: 1,
            });
        }
    }
    return tmp;
}
function fillAxisTicks(ticks, isLinear, gridCentering) {
    var result = [];
    if (!ticks.length) {
        return result;
    }
    if (ticks.length >= 2 && isLinear && gridCentering) {
        result.push({
            text: '',
            tickValue: '',
            value: 0,
        });
    }
    if (ticks[0].value !== 0) {
        result.push({
            text: '',
            tickValue: '',
            value: 0,
        });
    }
    result = result.concat(ticks);
    if (result[result.length - 1].value !== 1) {
        result.push({
            text: '',
            tickValue: '',
            value: 1,
        });
    }
    return result;
}
function getDefaultValueFromPosition(position, v) {
    if (v === void 0) { v = 0; }
    var val = v;
    if (position === 'middle') {
        val = 0.5;
    }
    if (position.indexOf('%') !== -1) {
        val = parseInt(position, 10) / 100;
    }
    return val;
}
var AxisController = /** @class */ (function () {
    function AxisController(cfg) {
        this.title = null;
        this.visible = true;
        this.canvas = null;
        this.container = null;
        this.coord = null;
        this.options = null;
        this.axes = [];
        this.theme = null;
        _.mix(this, cfg);
    }
    AxisController.prototype.createAxis = function (xScale, yScales, viewId) {
        var _this = this;
        var coord = this.coord;
        var coordType = coord.type;
        // theta坐标系默认不绘制坐标轴
        if (coordType !== 'theta' && !(coordType === 'polar' && coord.isTransposed)) {
            var xAxis_1;
            if (xScale && !this._isHide(xScale.field)) {
                xAxis_1 = this._drawAxis(coord, xScale, yScales[0], 'x', viewId); // 绘制 x 轴
            }
            if (!_.isEmpty(yScales) && coordType !== 'helix') {
                _.each(yScales, function (yScale, index) {
                    if (!_this._isHide(yScale.field)) {
                        _this._drawAxis(coord, yScale, xScale, 'y', viewId, xAxis_1, index);
                    }
                });
            }
        }
    };
    AxisController.prototype.changeVisible = function (visible) {
        var axes = this.axes;
        _.each(axes, function (axis) {
            axis.set('visible', visible);
        });
    };
    AxisController.prototype.clear = function () {
        var axes = this.axes;
        _.each(axes, function (axis) {
            axis.clear();
        });
        this.axes = [];
    };
    // 根据字段名获取对应的坐标轴配置
    AxisController.prototype._getAxisOptionByField = function (field, defaultValue) {
        if (defaultValue === void 0) { defaultValue = {}; }
        return _.get(this.options, "fields." + field, defaultValue);
    };
    // 对应的坐标轴是否隐藏
    AxisController.prototype._isHide = function (field) {
        return this._getAxisOptionByField(field) === false;
    };
    AxisController.prototype._getMiddleValue = function (curValue, ticks, index, isLinear) {
        if (curValue === 0 && !isLinear) {
            return 0;
        }
        if (curValue === 1) {
            return 1;
        }
        var nextValue = ticks[index + 1].value;
        if (!isLinear && nextValue === 1) {
            return 1;
        }
        return (curValue + nextValue) / 2;
    };
    AxisController.prototype._getLineRange = function (coord, scale, dimType, index) {
        var start;
        var end;
        var isVertical;
        var field = scale.field;
        var position = this._getAxisOptionByField(field).position || ''; // 获取用户自己配置的 position
        // TODO middle & percentage for position
        if (dimType === 'x') { // x轴的坐标轴,底部的横坐标
            var y = (position === 'top') ? 1 : 0;
            y = getDefaultValueFromPosition(position, y);
            start = { x: 0, y: y };
            end = { x: 1, y: y };
            isVertical = false;
        }
        else { // y轴坐标轴
            if (index) { // 多轴的情况
                var x = (position === 'left') ? 0 : 1;
                x = getDefaultValueFromPosition(position, x);
                start = { x: x, y: 0 };
                end = { x: x, y: 1 };
            }
            else { // 单个y轴，或者第一个y轴
                var x = (position === 'right') ? 1 : 0;
                x = getDefaultValueFromPosition(position, x);
                start = { x: x, y: 0 };
                end = { x: x, y: 1 };
            }
            isVertical = true;
        }
        start = coord.convert(start);
        end = coord.convert(end);
        return {
            start: start,
            end: end,
            isVertical: isVertical,
        };
    };
    AxisController.prototype._getLineCfg = function (coord, scale, dimType, index) {
        var factor;
        var range = this._getLineRange(coord, scale, dimType, index);
        var start = range.start, end = range.end;
        var center = coord.center, isTransposed = coord.isTransposed;
        var isVertical = isTransposed ? !range.isVertical : range.isVertical; // 标识该坐标轴是否是纵坐标
        if ((isVertical && (start.x > center.x)) || (!isVertical && (start.y > center.y))) {
            factor = 1;
        }
        else {
            factor = -1;
        }
        return {
            isVertical: isVertical,
            factor: factor,
            start: start,
            end: end,
        };
    };
    // 获取圆弧坐标轴配置项信息
    AxisController.prototype._getCircleCfg = function (coord) {
        var rangeX = coord.x, rangeY = coord.y, isTransposed = coord.isTransposed, center = coord.circleCenter, innerRadius = coord.innerRadius;
        var isReflectY = rangeY.start > rangeY.end;
        var start;
        if (isTransposed) {
            start = { x: isReflectY ? 0 : 1, y: 0 };
        }
        else {
            start = { x: 0, y: isReflectY ? 0 : 1 };
        }
        start = coord.convert(start);
        var startVector = [start.x - center.x, start.y - center.y];
        var normalVector = [1, 0];
        var startAngle;
        if (start.y > center.y) {
            startAngle = matrix_util_1.vec2.angle(startVector, normalVector);
        }
        else {
            startAngle = matrix_util_1.vec2.angle(startVector, normalVector) * -1;
        }
        var endAngle = startAngle + (rangeX.end - rangeX.start);
        return {
            startAngle: startAngle,
            endAngle: endAngle,
            center: center,
            radius: Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2)),
            inner: innerRadius || 0,
        };
    };
    AxisController.prototype._getRadiusCfg = function (coord) {
        var startAngle = coord.x.start;
        var factor = startAngle < 0 ? -1 : 1;
        var start;
        var end;
        if (coord.isTransposed) {
            start = { x: 0, y: 0 };
            end = { x: 1, y: 0 };
        }
        else {
            start = { x: 0, y: 0 };
            end = { x: 0, y: 1 };
        }
        return {
            factor: factor,
            start: coord.convert(start),
            end: coord.convert(end),
        };
    };
    AxisController.prototype._getHelixCfg = function (coord) {
        var helixCfg = {};
        var a = coord.a, startAngle = coord.startAngle, endAngle = coord.endAngle, center = coord.center, y = coord.y;
        var index = 100;
        var crp = [];
        for (var i = 0; i <= index; i++) {
            var point = coord.convert({ x: i / 100, y: 0 });
            crp.push(point.x);
            crp.push(point.y);
        }
        var axisStart = coord.convert({ x: 0, y: 0 });
        return {
            a: a,
            startAngle: startAngle,
            endAngle: endAngle,
            crp: crp,
            axisStart: axisStart,
            center: center,
            inner: y.start,
        };
    };
    // 确定坐标轴的位置
    AxisController.prototype._getAxisPosition = function (coord, dimType, index, field) {
        if (this._getAxisOptionByField(field).position) { // 用户自己定义了 position
            return this._getAxisOptionByField(field).position;
        }
        var position = '';
        var coordType = coord.type;
        if (coord.isRect) {
            if (dimType === 'x') {
                position = 'bottom';
            }
            else if (dimType === 'y') {
                if (index) {
                    position = 'right';
                }
                else {
                    position = 'left';
                }
            }
        }
        else if (coordType === 'helix') {
            position = 'helix';
        }
        else if (dimType === 'x') {
            position = coord.isTransposed ? 'radius' : 'circle';
        }
        else {
            position = coord.isTransposed ? 'circle' : 'radius';
        }
        return position;
    };
    // 获取坐标轴构成的配置信息
    AxisController.prototype._getAxisDefaultCfg = function (coord, scale, type, position) {
        var theme = this.theme;
        var field = scale.field;
        var cfg = {
            coord: coord,
            theme: theme.axis[position],
        };
        cfg = _.deepMix({}, theme.axis[position], cfg, this._getAxisOptionByField(field));
        if (cfg.showTitle) { // 展示坐标轴标题
            var title = _.get(cfg, 'title', {});
            title.text = title.text || scale.alias || field;
            _.deepMix(cfg, { title: title });
        }
        cfg.ticks = scale.getTicks();
        if (coord.isPolar && !scale.isCategory) {
            if (type === 'x' && Math.abs(coord.endAngle - coord.startAngle) === Math.PI * 2) {
                cfg.ticks.pop();
            }
        }
        return cfg;
    };
    // 确定坐标轴的配置信息
    AxisController.prototype._getAxisCfg = function (coord, scale, verticalScale, dimType, index, viewId) {
        var _this = this;
        if (index === void 0) { index = ''; }
        var position = this._getAxisPosition(coord, dimType, index, scale.field);
        var cfg = this._getAxisDefaultCfg(coord, scale, dimType, position);
        if (cfg.grid && verticalScale) { // 生成 gridPoints
            var gridPoints_1 = [];
            var verticalTicks_1 = formatTicks(verticalScale.getTicks());
            // 没有垂直的坐标点时不绘制栅格
            if (verticalTicks_1.length) {
                var ticks_1 = fillAxisTicks(cfg.ticks, scale.isLinear, cfg.gridAlign === 'center');
                _.each(ticks_1, function (tick, idx) {
                    var subPoints = [];
                    var value = tick.value;
                    if (cfg.gridAlign === 'center') {
                        value = _this._getMiddleValue(value, ticks_1, idx, scale.isLinear);
                    }
                    if (!_.isNil(value)) {
                        var rangeX_1 = coord.x;
                        var rangeY_1 = coord.y;
                        _.each(verticalTicks_1, function (verticalTick) {
                            var x = dimType === 'x' ? value : verticalTick.value;
                            var y = dimType === 'x' ? verticalTick.value : value;
                            var point = coord.convert({ x: x, y: y });
                            if (coord.isPolar) {
                                var center = coord.circleCenter;
                                if (rangeY_1.start > rangeY_1.end) {
                                    y = 1 - y;
                                }
                                point.flag = rangeX_1.start > rangeX_1.end ? 0 : 1;
                                point.radius = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
                            }
                            subPoints.push(point);
                        });
                        gridPoints_1.push({
                            id: viewId + "-" + dimType + index + "-grid-" + tick.tickValue,
                            points: subPoints,
                        });
                    }
                });
            }
            cfg.gridPoints = gridPoints_1;
        }
        return cfg;
    };
    AxisController.prototype._drawAxis = function (coord, scale, verticalScale, dimType, viewId, xAxis, index) {
        var container = this.container;
        var canvas = this.canvas;
        var C; // 坐标轴类
        var appendCfg; // 每个坐标轴 start end 等绘制边界的信息
        if (coord.type === 'cartesian') {
            C = component_1.Axis.Line;
            appendCfg = this._getLineCfg(coord, scale, dimType, index);
        }
        else if (coord.type === 'helix' && dimType === 'x') {
            C = component_1.Axis.Helix;
            appendCfg = this._getHelixCfg(coord);
        }
        else if (dimType === 'x') {
            C = component_1.Axis.Circle;
            appendCfg = this._getCircleCfg(coord);
        }
        else {
            C = component_1.Axis.Line;
            appendCfg = this._getRadiusCfg(coord);
        }
        var cfg = this._getAxisCfg(coord, scale, verticalScale, dimType, index, viewId);
        cfg = _.mix({}, cfg, appendCfg);
        if (dimType === 'y' && xAxis && xAxis.get('type') === 'circle') {
            cfg.circle = xAxis;
        }
        cfg.id = !_.isNil(index) ? viewId + "-" + dimType + index : viewId + "-" + dimType;
        _.mix(cfg, {
            canvas: canvas,
            group: container.addGroup(),
        });
        var axis = new C(cfg);
        axis.render();
        this.axes.push(axis);
        return axis;
    };
    return AxisController;
}());
exports.default = AxisController;
//# sourceMappingURL=axis.js.map