"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * @description coord 的控制器
 */
var _ = require("@antv/util");
var dependents_1 = require("../../dependents");
var CoordController = /** @class */ (function () {
    function CoordController(option) {
        if (option === void 0) { option = {}; }
        this.type = 'rect';
        this.actions = [];
        this.cfg = {};
        this.options = {};
        _.mix(this, option);
        this.options = option; // ugly！！！通过浅拷贝 view.get('options').coord 来动态更改该属性值，见 view.ts#L917
    }
    CoordController.prototype.reset = function (option) {
        this.type = option.type || 'rect';
        this.actions = option.actions || [];
        this.cfg = option.cfg;
        // 更新 view.get('options').coord，见view.ts#L917
        this.options.type = this.type;
        this.options.actions = this.actions;
        this.options.cfg = this.cfg;
        return this;
    };
    /**
     * 创建坐标系对象
     * @param  {Object} start 坐标系起始点
     * @param  {Object} end   坐标系结束点
     * @return {Function} 坐标系的构造函数
     */
    CoordController.prototype.createCoord = function (start, end) {
        var type = this.type;
        var cfg = this.cfg;
        var C; // 构造函数
        var coord;
        var coordCfg = tslib_1.__assign({ start: start,
            end: end }, cfg);
        if (type === 'theta') { // definition of theta coord
            C = dependents_1.getCoordinate('polar');
            if (!this._hasAction('transpose')) {
                this.transpose(); // 极坐标，同时transpose
            }
            coord = new C(coordCfg);
            coord.type = type;
        }
        else {
            C = dependents_1.getCoordinate(type);
            coord = new C(coordCfg);
        }
        this._execActions(coord);
        return coord;
    };
    /**
     * 围绕坐标系中心点旋转对应的角度
     * @param angle 旋转角度
     */
    CoordController.prototype.rotate = function (angle) {
        var _angle = angle * Math.PI / 180;
        this.actions.push(['rotate', _angle]);
        return this;
    };
    /**
     * 将坐标系沿 x 方向或者沿 y 轴方向进行镜像映射
     * @param dim 镜像方向，可选值 'x' 和 'y'，默认为 'x'
     */
    CoordController.prototype.reflect = function (dim) {
        if (dim === void 0) { dim = 'y'; }
        this.actions.push(['reflect', dim]);
        return this;
    };
    /**
     * 根据坐标系中心点进行相应的缩放
     * @param sx x 轴缩放值
     * @param sy y 轴缩放值
     */
    CoordController.prototype.scale = function (sx, sy) {
        this.actions.push(['scale', sx, sy]);
        return this;
    };
    /**
     * x，y 轴交换
     */
    CoordController.prototype.transpose = function () {
        this.actions.push(['transpose']);
        return this;
    };
    CoordController.prototype._execActions = function (coord) {
        _.each(this.actions, function (action) {
            var m = action[0];
            coord[m](action[1], action[2]);
        });
    };
    CoordController.prototype._hasAction = function (actionName) {
        var actions = this.actions;
        var rst = false;
        _.each(actions, function (action) {
            if (actionName === action[0]) {
                rst = true;
                return false;
            }
        });
        return rst;
    };
    return CoordController;
}());
exports.default = CoordController;
//# sourceMappingURL=coordinate.js.map