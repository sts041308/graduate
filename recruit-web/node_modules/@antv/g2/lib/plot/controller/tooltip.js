"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = require("@antv/component");
var matrixUtil = require("@antv/matrix-util");
var _ = require("@antv/util");
var base_1 = require("../../element/shape/base");
var Vector2 = matrixUtil.vec2;
var TYPE_SHOW_MARKERS = ['line', 'area', 'path']; // 默认展示 tooltip marker 的几何图形
var TYPE_SHOW_CROSSHAIRS = ['line', 'area']; // 默认展示十字瞄准线的几何图形
// TODO FIXME this is HARD CODING
var IGNORE_TOOLTIP_ITEM_PROPERTIES = ['marker', 'showMarker'];
var _indexOfArray = function (items, item) {
    var rst = -1;
    _.each(items, function (sub, index) {
        var isEqual = true;
        for (var key in item) {
            if (item.hasOwnProperty(key) && IGNORE_TOOLTIP_ITEM_PROPERTIES.indexOf(key) === -1) {
                if (!_.isObject(item[key]) && item[key] !== sub[key]) {
                    isEqual = false;
                    break;
                }
            }
        }
        if (isEqual) {
            rst = index;
            return false;
        }
    });
    return rst;
};
// 判断是否有样式
var _hasClass = function (dom, className) {
    var cls = dom.className;
    return cls && cls.indexOf(className) !== -1;
};
var _isParent = function (dom, cls) {
    var parent = dom.parentNode;
    var rst = false;
    while (parent && parent !== document.body) {
        if (_hasClass(parent, cls)) {
            rst = true;
            break;
        }
        parent = parent.parentNode;
    }
    return rst;
};
// 去除重复的值, 去除不同图形相同数据，只展示一份即可
var _uniqItems = function (items) {
    var tmp = [];
    _.each(items, function (item) {
        var index = _indexOfArray(tmp, item);
        if (index === -1) {
            tmp.push(item);
        }
    });
    return tmp;
};
var TooltipController = /** @class */ (function () {
    function TooltipController(cfg) {
        var _this = this;
        this.timeStamp = 0;
        this.onMouseMove = function (ev) {
            var group = _this.view.get('panelGroup');
            var lastTimeStamp = _this.timeStamp;
            var timeStamp = +new Date();
            var point = {
                x: ev.x - (group.get('x') || 0),
                y: ev.y - (group.get('y') || 0),
            };
            if (timeStamp - lastTimeStamp > 16) {
                _this.showTooltip(point, _this.view, ev.target);
                _this.timeStamp = timeStamp;
            }
        };
        this.onMouseOut = function (ev) {
            // const tooltip = this.tooltip;
            // if (!tooltip.get('visible') || !tooltip.get('follow')) {
            //   return;
            // }
            if (ev && !ev.event) {
                // 如果鼠标 hover 到 tooltipContainer 内容框上不需要 hideTooltip
                return;
            }
            _this.hideTooltip();
        };
        _.assign(this, cfg);
    }
    TooltipController.prototype.renderTooltip = function () {
        var _this = this;
        if (this.tooltip) {
            // tooltip 对象已经创建
            return;
        }
        var view = this.view;
        var theme = this.theme;
        var canvas = this._getCanvas();
        var defaultCfg = this._getDefaultTooltipOptions();
        var options = this.options;
        options = _.deepMix({
            panelGroup: view.get('panelGroup'),
            panelRange: view.get('panelRange'),
            capture: false,
            canvas: canvas,
            frontgroundGroup: view.get('frontgroundGroup'),
            theme: theme.tooltip,
            backgroundGroup: view.get('backgroundGroup'),
        }, defaultCfg, options);
        if (options.crosshairs && options.crosshairs.type === 'rect') {
            options.zIndex = 0; // toolip 背景框不可遮盖住 geom，防止用户配置了 crosshairs
        }
        options.visible = false;
        var tooltip;
        if (options.useHtml) {
            tooltip = new component_1.Tooltip.Html(options);
            var triggerEvent_1 = this._getTriggerEvent();
            if (!tooltip.get('enterable') && triggerEvent_1 === 'panel:mousemove') {
                var tooltipContainer = tooltip.get('container');
                if (tooltipContainer) {
                    tooltipContainer.onmousemove = function (e) {
                        // 避免 tooltip 频繁闪烁
                        var eventObj = _this._normalizeEvent(e);
                        view.emit(triggerEvent_1, eventObj);
                    };
                }
            }
        }
        else {
            tooltip = new component_1.Tooltip.Canvas(options);
        }
        this.tooltip = tooltip;
        // 需要保存当前 tooltip 的配置项，否则当用户关闭 tooltip 再手动调用 view.showTooltip() 时会报错
        this.options = options;
        this._bindEvent();
    };
    TooltipController.prototype._normalizeEvent = function (event) {
        var view = this.view;
        var canvas = this._getCanvas();
        var point = canvas.getPointByClient(event.clientX, event.clientY);
        var pixelRatio = canvas.get('pixelRatio');
        point.x = point.x / pixelRatio;
        point.y = point.y / pixelRatio;
        point.view = view;
        return point;
    };
    TooltipController.prototype.hideTooltip = function () {
        var tooltip = this.tooltip;
        if (tooltip.get('visible')) {
            // 优化，只有 tooltip 处于 visible: true 状态时才隐藏，否则会造成 canvas 的不断重绘
            var view = this.view;
            var canvas = this._getCanvas();
            this.prePoint = null;
            tooltip.hide();
            view.emit('tooltip:hide', {
                tooltip: tooltip,
            });
            view.setActive(function () {
                return false;
            });
            canvas.draw();
        }
    };
    TooltipController.prototype.showTooltip = function (point, view, target) {
        var _this = this;
        if (!point) {
            return;
        }
        if (!this.tooltip) {
            this.renderTooltip(); // 如果一开始 tooltip 关闭，用户重新调用的时候需要先生成 tooltip
        }
        var options = this.options;
        var markersItems = [];
        var items = [];
        var elements = view.getElements();
        var coord = view.get('coord');
        _.each(elements, function (element) {
            var type = element.get('type');
            if (element.get('visible') && element.get('tooltipOptions') !== false) {
                var dataArray = element.get('dataArray');
                if (element.isShareTooltip() || _.contains(['area', 'line', 'path'], type)) {
                    // area、line、path 四种几何标记以及共享 tooltip 的场景使用数据查找策略
                    _.each(dataArray, function (data) {
                        var tmpPoint = element.findPoint(point, data);
                        if (tmpPoint) {
                            var subItems = element.getTooltipItems(tmpPoint, options.title);
                            _.each(subItems, function (v) {
                                // tslint:disable-next-line: no-shadowed-variable
                                var point = v.point;
                                if (!_.isNil(point) && !_.isNil(point.x) && !_.isNil(point.y)) {
                                    // hotfix: make sure there is no null value
                                    var x = _.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
                                    var y = _.isArray(point.y) ? point.y[point.y.length - 1] : point.y;
                                    point = coord.applyMatrix(x, y, 1);
                                    v.x = point[0];
                                    v.y = point[1];
                                    v.showMarker = true;
                                    var itemMarker = _this._getItemMarker(element, v.color);
                                    v.marker = itemMarker;
                                    if (_.indexOf(TYPE_SHOW_MARKERS, type) !== -1) {
                                        markersItems.push(v);
                                    }
                                }
                            });
                            items = items.concat(subItems);
                        }
                    });
                }
                else {
                    var shapeContainer = element.get('shapeContainer');
                    var canvas = shapeContainer.get('canvas');
                    var pixelRatio = canvas.get('pixelRatio');
                    var shape = shapeContainer.getShape(point.x * pixelRatio, point.y * pixelRatio);
                    if (shape && shape.get('visible') && shape.get('origin')) {
                        items = element.getTooltipItems(shape.get('origin'), options.title);
                    }
                }
            }
        });
        _.each(items, function (item) {
            // tslint:disable-next-line: no-shadowed-variable
            var point = item.point;
            var x = _.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
            var y = _.isArray(point.y) ? point.y[point.y.length - 1] : point.y;
            point = coord.applyMatrix(x, y, 1);
            item.x = point[0];
            item.y = point[1];
        });
        if (items.length) {
            var first_1 = items[0];
            // bugfix: multiple tooltip items with different titles
            if (!items.every(function (item) { return item.title === first_1.title; })) {
                var nearestItem_1 = first_1;
                var nearestDistance_1 = Infinity;
                items.forEach(function (item) {
                    var distance = Vector2.distance([point.x, point.y], [item.x, item.y]);
                    if (distance < nearestDistance_1) {
                        nearestDistance_1 = distance;
                        nearestItem_1 = item;
                    }
                });
                items = items.filter(function (item) { return item.title === nearestItem_1.title; });
                markersItems = markersItems.filter(function (item) { return item.title === nearestItem_1.title; });
            }
            if (options.shared === false && items.length > 1) {
                var snapItem_1 = items[0];
                var min_1 = Math.abs(point.y - snapItem_1.y);
                _.each(items, function (aItem) {
                    if (Math.abs(point.y - aItem.y) <= min_1) {
                        snapItem_1 = aItem;
                        min_1 = Math.abs(point.y - aItem.y);
                    }
                });
                if (snapItem_1 && !_.isNil(snapItem_1.x) && !_.isNil(snapItem_1.y)) {
                    markersItems = [snapItem_1];
                }
                items = [snapItem_1];
            }
            this._setTooltip(point, items, markersItems, target);
            // 使查找到的数据对应的 shape 处于 active 状态
            // 应该在每次出现 tooltip 的时候就 active 对应的 shapes
            view.setActive(function (obj) {
                var result = false;
                _.each(items, function (item) {
                    var origin = item.point._origin;
                    if (origin === obj) {
                        result = true;
                        return false;
                    }
                });
                return result;
            }, false);
        }
        else {
            this.hideTooltip();
        }
    };
    TooltipController.prototype.clear = function () {
        var tooltip = this.tooltip;
        if (tooltip) {
            tooltip.destroy();
        }
        this.tooltip = null;
        this.prePoint = null;
        this._offEvent();
    };
    TooltipController.prototype._getCanvas = function () {
        return this.view.get('canvas');
    };
    TooltipController.prototype._getTriggerEvent = function () {
        var triggerOn = _.get(this.options, 'triggerOn');
        var eventName;
        if (!triggerOn || triggerOn === 'mousemove') {
            eventName = 'panel:mousemove';
        }
        else if (triggerOn === 'click') {
            eventName = 'panel:click';
        }
        else if (triggerOn === 'none') {
            eventName = null;
        }
        return eventName;
    };
    TooltipController.prototype._getDefaultTooltipOptions = function () {
        var view = this.view;
        var options = this.options;
        var theme = this.theme;
        var defaultCfg = _.mix({}, theme.tooltip);
        var elements = _.filter(view.getElements(), function (element) { return element.get('visible'); });
        var shapes = _.uniq(_.map(elements, function (element) { return element.get('type'); }));
        var isTransposed = view.get('coord') ? view.get('coord').isTransposed : false;
        var crosshairsCfg;
        if (view.get('coord') && view.get('coord').type === 'cartesian') {
            if (shapes[0] === 'interval') {
                if (options.shape !== false) {
                    var crosshairs = _.mix({}, theme.tooltipCrosshairsRect);
                    crosshairs.isTransposed = isTransposed;
                    crosshairsCfg = {
                        zIndex: 0,
                        crosshairs: crosshairs,
                    };
                }
            }
            else if (_.indexOf(TYPE_SHOW_CROSSHAIRS, shapes[0]) > -1) {
                var crosshairs = _.mix({}, theme.tooltipCrosshairsLine);
                crosshairs.isTransposed = isTransposed;
                crosshairsCfg = {
                    crosshairs: crosshairs,
                };
            }
        }
        return _.mix(defaultCfg, crosshairsCfg);
    };
    TooltipController.prototype._bindEvent = function () {
        var view = this.view;
        var triggerEvent = this._getTriggerEvent();
        if (triggerEvent) {
            view.on(triggerEvent, this.onMouseMove);
            view.on('panel:mouseleave', this.onMouseOut);
        }
    };
    TooltipController.prototype._offEvent = function () {
        var view = this.view;
        var triggerEvent = this._getTriggerEvent();
        if (triggerEvent) {
            view.off(triggerEvent, this.onMouseMove);
            view.off('panel:mouseleave', this.onMouseOut);
        }
    };
    TooltipController.prototype._setTooltip = function (point, _items, markersItems, target) {
        var tooltip = this.tooltip;
        var prePoint = this.prePoint;
        if (!prePoint || (prePoint.x !== point.x || prePoint.y !== point.y)) {
            var items = _uniqItems(_items);
            this.prePoint = point;
            var view = this.view;
            var theme = this.theme;
            var x = _.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
            var y = _.isArray(point.y) ? point.y[point.y.length - 1] : point.y;
            if (!tooltip.get('visible')) {
                view.emit('tooltip:show', {
                    x: x,
                    y: y,
                    tooltip: tooltip,
                });
            }
            var first = items[0];
            var title = first.title || first.name;
            if (tooltip.isContentChange(title, items)) {
                view.emit('tooltip:change', {
                    tooltip: tooltip,
                    x: x,
                    y: y,
                    items: items,
                });
                // bugfix: when set the title in the tooltip:change event does not take effect.
                title = items[0].title || items[0].name;
                tooltip.setContent(title, items);
                if (!_.isEmpty(markersItems)) {
                    if (this.options.showTooltipMarkers === false) {
                        // 不展示 tooltip marker
                        // @ts-ignore
                        tooltip.set('markerItems', markersItems); // 用于 tooltip 辅助线的定位
                    }
                    else {
                        tooltip.setMarkers(markersItems, theme.tooltipMarker);
                    }
                }
                else {
                    tooltip.clearMarkers();
                    // clearMarkers 只会将 markerItems 从 markerGroup 中移除
                    // 所以我们还要将 markerItems 从 tooltip 中移除
                    // 这么做是为了防止上一次设置 marker 时的 markerItems 影响此次 tooltip 辅助线的定位
                    // @ts-ignore
                    tooltip.set('markerItems', []);
                }
            }
            tooltip.setPosition(x + (view.get('panelGroup').get('x') || 0), y + (view.get('panelGroup').get('y') || 0), target);
            tooltip.show();
        }
    };
    TooltipController.prototype._getItemMarker = function (element, color) {
        var shapeType = element.get('shapeType') || 'point';
        var shape = element.getDefaultValue('shape') || 'circle';
        var shapeObject = base_1.getShapeFactory(shapeType);
        var cfg = { color: color };
        var marker = shapeObject.getMarkerStyle(shape, cfg);
        return marker;
    };
    return TooltipController;
}());
exports.default = TooltipController;
//# sourceMappingURL=tooltip.js.map