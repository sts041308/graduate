import { __extends } from "tslib";
import * as Util from '@antv/util';
import Shape from '../core/shape';
import * as Inside from './util/inside';
import BBox from '../core/bbox';
var Ellipse = /** @class */ (function (_super) {
    __extends(Ellipse, _super);
    function Ellipse() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.canFill = true;
        _this.canStroke = true;
        _this.type = 'ellipse';
        return _this;
    }
    Ellipse.prototype.getDefaultAttrs = function () {
        return {
            x: 0,
            y: 0,
            rx: 1,
            ry: 1,
            lineWidth: 1,
        };
    };
    Ellipse.prototype.isPointInPath = function (x, y) {
        var attrs = this.attrs;
        var fill = this.hasFill();
        var stroke = this.hasStroke();
        var cx = attrs.x;
        var cy = attrs.y;
        var rx = attrs.rx;
        var ry = attrs.ry;
        var lineWidth = this.getHitLineWidth();
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var p = [x, y, 1];
        var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        Util.mat3.scale(m, m, [scaleX, scaleY]);
        Util.mat3.translate(m, m, [cx, cy]);
        var inm = Util.mat3.invert([], m);
        Util.vec3.transformMat3(p, p, inm);
        if (fill && stroke) {
            return (Inside.circle(0, 0, r, p[0], p[1]) || Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]));
        }
        if (fill) {
            return Inside.circle(0, 0, r, p[0], p[1]);
        }
        if (stroke) {
            return Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]);
        }
        return false;
    };
    Ellipse.prototype.calculateBox = function () {
        var attrs = this.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var rx = attrs.rx;
        var ry = attrs.ry;
        var lineWidth = this.getHitLineWidth();
        var halfXWidth = rx + lineWidth / 2;
        var halfYWidth = ry + lineWidth / 2;
        return BBox.fromRange(cx - halfXWidth, cy - halfYWidth, cx + halfXWidth, cy + halfYWidth);
    };
    Ellipse.prototype.createPath = function (context) {
        var self = this;
        var attrs = this.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var rx = attrs.rx;
        var ry = attrs.ry;
        context = context || self.get('context');
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        Util.mat3.scale(m, m, [scaleX, scaleY]);
        Util.mat3.translate(m, m, [cx, cy]);
        context.beginPath();
        context.save();
        context.transform(m[0], m[1], m[3], m[4], m[6], m[7]);
        context.arc(0, 0, r, 0, Math.PI * 2);
        context.restore();
        context.closePath();
    };
    return Ellipse;
}(Shape));
export default Ellipse;
//# sourceMappingURL=ellipse.js.map