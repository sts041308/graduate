import { __extends } from "tslib";
import * as Util from '@antv/util';
import * as Format from '../../util/format';
import Shape from '../../core/shape';
import PathSegment from '../util/path-segment';
import * as Inside from '../util/inside';
import BBox from '../../core/bbox';
import symbolsFactory from './symbols';
var Marker = /** @class */ (function (_super) {
    __extends(Marker, _super);
    function Marker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'marker';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Marker.prototype.getDefaultAttrs = function () {
        return {
            path: null,
            x: 0,
            y: 0,
            lineWidth: 1,
        };
    };
    Marker.prototype.isPointInPath = function (x, y) {
        var attrs = this.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.radius;
        var lineWidth = this.getHitLineWidth();
        return Inside.circle(cx, cy, r + lineWidth / 2, x, y);
    };
    Marker.prototype.calculateBox = function () {
        var attrs = this.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.radius;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2 + r;
        return BBox.fromRange(cx - halfWidth, cy - halfWidth, cx + halfWidth, cy + halfWidth);
    };
    Marker.prototype._getPath = function () {
        var attrs = this.attrs;
        var x = attrs.x;
        var y = attrs.y;
        var r = attrs.radius;
        var symbol = attrs.symbol || 'circle';
        var method;
        if (Util.isFunction(symbol)) {
            method = symbol;
        }
        else {
            method = symbolsFactory.get(symbol);
        }
        if (!method) {
            // 容错，防止绘制出错
            console.warn(method + " symbol is not exist.");
            return null;
        }
        return method(x, y, r);
    };
    Marker.prototype.createPath = function (context) {
        var segments = this.cfg.segments;
        if (segments && !this.cfg.hasUpdate) {
            context.beginPath();
            for (var i = 0; i < segments.length; i++) {
                segments[i].draw(context);
            }
            return;
        }
        var path = Format.parsePath(this._getPath());
        context.beginPath();
        var preSegment;
        segments = [];
        for (var i = 0; i < path.length; i++) {
            var item = path[i];
            preSegment = new PathSegment(item, preSegment, i === path.length - 1);
            segments.push(preSegment);
            preSegment.draw(context);
        }
        this.cfg.segments = segments;
        this.cfg.hasUpdate = false;
    };
    // 作为其静态属性
    Marker.symbolsFactory = symbolsFactory;
    return Marker;
}(Shape));
export default Marker;
//# sourceMappingURL=index.js.map