import * as Util from '@antv/util';
import * as renderUtil from './util';
var SHAPE_ATTRS = [
    'fillStyle',
    'font',
    'globalAlpha',
    'lineCap',
    'lineWidth',
    'lineJoin',
    'miterLimit',
    'shadowBlur',
    'shadowColor',
    'shadowOffsetX',
    'shadowOffsetY',
    'strokeStyle',
    'textAlign',
    'textBaseline',
    'lineDash',
    'lineDashOffset',
];
var Painter = /** @class */ (function () {
    function Painter(dom, context) {
        // DOM 容器不存在时，说明为非浏览器环境，此时使用上层传入的 context
        if (!dom) {
            this.type = 'canvas';
            // 从 context 中获取 canvas dom
            this.canvas = context.canvas;
            this.context = context;
            return this;
        }
        var canvasId = Util.uniqueId('canvas_');
        // @ts-ignore
        var canvasDom = Util.createDom('<canvas id="' + canvasId + '"></canvas>');
        dom.appendChild(canvasDom);
        this.type = 'canvas';
        this.canvas = canvasDom;
        this.context = canvasDom.getContext('2d');
        return this;
    }
    Painter.prototype.beforeDraw = function () {
        var el = this.canvas;
        this.context && this.context.clearRect(0, 0, el.width, el.height);
    };
    Painter.prototype.draw = function (model) {
        var self = this;
        function drawInner() {
            self.animateHandler = Util.requestAnimationFrame(function () {
                self.animateHandler = undefined;
                if (self.toDraw) {
                    drawInner();
                }
            });
            self.beforeDraw();
            try {
                self._drawGroup(model);
            }
            catch (ev) {
                // 绘制时异常，中断重绘
                console.warn('error in draw canvas, detail as:');
                console.warn(ev);
            }
            finally {
                self.toDraw = false;
            }
        }
        if (self.animateHandler) {
            self.toDraw = true;
        }
        else {
            drawInner();
        }
    };
    Painter.prototype.drawSync = function (model) {
        this.beforeDraw();
        this._drawGroup(model);
    };
    Painter.prototype._drawGroup = function (group) {
        if (group.removed || group.destroyed || !group.cfg.visible) {
            return;
        }
        var self = this;
        var children = group.cfg.children;
        var child = null;
        this.setContext(group);
        for (var i = 0; i < children.length; i++) {
            child = children[i];
            if (children[i].isGroup) {
                self._drawGroup(child);
            }
            else {
                self._drawShape(child);
            }
        }
        this.restoreContext(group);
    };
    Painter.prototype._drawShape = function (shape) {
        if (shape.removed || shape.destroyed || !shape.cfg.visible) {
            return;
        }
        this.setContext(shape);
        shape.drawInner(this.context);
        this.restoreContext(shape);
        shape.cfg.attrs = shape.attrs;
        shape.cfg.hasUpdate = false;
    };
    Painter.prototype.setContext = function (shape) {
        var context = this.context;
        var clip = shape.attrs.clip;
        context.save();
        if (clip) {
            // context.save();
            clip.resetTransform(context);
            clip.createPath(context);
            context.clip();
            // context.restore();
        }
        this.resetContext(shape);
        shape.resetTransform(context);
    };
    Painter.prototype.restoreContext = function (element) {
        this.context.restore();
    };
    Painter.prototype.resetContext = function (shape) {
        var context = this.context;
        var elAttrs = shape.attrs;
        // var canvas = this.get('canvas');
        if (!shape.isGroup) {
            for (var k in elAttrs) {
                if (SHAPE_ATTRS.indexOf(k) > -1) {
                    // 非canvas属性不附加
                    var v = elAttrs[k];
                    if (k === 'fillStyle') {
                        v = renderUtil.parseStyle(v, shape, context);
                    }
                    if (k === 'strokeStyle') {
                        v = renderUtil.parseStyle(v, shape, context);
                    }
                    if (k === 'lineDash' && context.setLineDash) {
                        if (Util.isArray(v)) {
                            context.setLineDash(v);
                        }
                        else if (Util.isString(v)) {
                            // @ts-ignore
                            context.setLineDash(v.split(' '));
                        }
                    }
                    else {
                        context[k] = v;
                    }
                }
            }
        }
    };
    return Painter;
}());
export default Painter;
//# sourceMappingURL=painter.js.map