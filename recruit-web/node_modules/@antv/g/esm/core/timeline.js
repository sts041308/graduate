import * as Util from '@antv/util';
import * as d3Timer from 'd3-timer';
import * as d3Ease from 'd3-ease';
import { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算
import * as PathUtil from '../util/path';
function _update(self, animator, ratio) {
    var cProps = {}; // 此刻属性
    var toAttrs = animator.toAttrs;
    var fromAttrs = animator.fromAttrs;
    var toMatrix = animator.toMatrix;
    if (self.destroyed) {
        return;
    }
    var interf; //  差值函数
    for (var k in toAttrs) {
        if (!Util.isEqual(fromAttrs[k], toAttrs[k])) {
            if (k === 'path') {
                var toPath = toAttrs[k];
                var fromPath = fromAttrs[k];
                if (toPath.length > fromPath.length) {
                    toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态
                    fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态
                    fromPath = PathUtil.fillPathByDiff(fromPath, toPath);
                    fromPath = PathUtil.formatPath(fromPath, toPath);
                    animator.fromAttrs.path = fromPath;
                    animator.toAttrs.path = toPath;
                }
                else if (!animator.pathFormatted) {
                    toPath = PathUtil.parsePathString(toAttrs[k]);
                    fromPath = PathUtil.parsePathString(fromAttrs[k]);
                    fromPath = PathUtil.formatPath(fromPath, toPath);
                    animator.fromAttrs.path = fromPath;
                    animator.toAttrs.path = toPath;
                    animator.pathFormatted = true;
                }
                cProps[k] = [];
                for (var i = 0; i < toPath.length; i++) {
                    var toPathPoint = toPath[i];
                    var fromPathPoint = fromPath[i];
                    var cPathPoint = [];
                    for (var j = 0; j < toPathPoint.length; j++) {
                        if (Util.isNumber(toPathPoint[j]) && fromPathPoint && Util.isNumber(fromPathPoint[j])) {
                            interf = interpolate(fromPathPoint[j], toPathPoint[j]);
                            cPathPoint.push(interf(ratio));
                        }
                        else {
                            cPathPoint.push(toPathPoint[j]);
                        }
                    }
                    cProps[k].push(cPathPoint);
                }
            }
            else {
                interf = interpolate(fromAttrs[k], toAttrs[k]);
                cProps[k] = interf(ratio);
            }
        }
    }
    if (toMatrix) {
        var mf = interpolateArray(animator.fromMatrix, toMatrix);
        var cM = mf(ratio);
        self.setMatrix(cM);
    }
    self.attr(cProps);
}
function update(shape, animator, elapsed) {
    var startTime = animator.startTime;
    // 如果还没有开始执行或暂停，先不更新
    if (elapsed < startTime + animator.delay || animator.isPaused) {
        return false;
    }
    var ratio;
    var duration = animator.duration;
    var easing = animator.easing;
    // 已执行时间
    elapsed = elapsed - startTime - animator.delay;
    if (animator.toAttrs.repeat) {
        ratio = (elapsed % duration) / duration;
        ratio = d3Ease[easing](ratio);
    }
    else {
        ratio = elapsed / duration;
        if (ratio < 1) {
            ratio = d3Ease[easing](ratio);
        }
        else {
            if (animator.onFrame) {
                shape.attr(animator.onFrame(1));
            }
            else {
                shape.attr(animator.toAttrs);
            }
            if (animator.toMatrix) {
                shape.setMatrix(animator.toMatrix);
            }
            return true;
        }
    }
    if (animator.onFrame) {
        var attrs = animator.onFrame(ratio);
        shape.attr(attrs);
    }
    else {
        _update(shape, animator, ratio);
    }
    return false;
}
var Timeline = /** @class */ (function () {
    function Timeline(canvas) {
        this.animators = [];
        this.current = 0;
        this.timer = null;
        this.canvas = canvas;
    }
    Timeline.prototype.initTimer = function () {
        var _this = this;
        var self = this;
        var isFinished = false;
        var shape, animators, animator;
        self.timer = d3Timer.timer(function (elapsed) {
            self.current = elapsed;
            if (_this.animators.length > 0) {
                for (var i = _this.animators.length - 1; i >= 0; i--) {
                    shape = _this.animators[i];
                    if (shape.destroyed) {
                        // 如果已经被销毁，直接移出队列
                        self.removeAnimator(i);
                        continue;
                    }
                    if (!shape.get('pause').isPaused) {
                        animators = shape.get('animators');
                        for (var j = animators.length - 1; j >= 0; j--) {
                            animator = animators[j];
                            isFinished = update(shape, animator, elapsed);
                            if (isFinished) {
                                animators.splice(j, 1);
                                isFinished = false;
                                if (animator.callback) {
                                    animator.callback();
                                }
                            }
                        }
                    }
                    if (animators.length === 0) {
                        self.removeAnimator(i);
                    }
                }
                _this.canvas.draw();
            }
        });
    };
    Timeline.prototype.addAnimator = function (shape) {
        this.animators.push(shape);
    };
    Timeline.prototype.removeAnimator = function (index) {
        this.animators.splice(index, 1);
    };
    Timeline.prototype.isAnimating = function () {
        return !!this.animators.length;
    };
    Timeline.prototype.stop = function () {
        if (this.timer) {
            this.timer.stop();
        }
    };
    Timeline.prototype.stopAllAnimations = function () {
        this.animators.forEach(function (animator) {
            animator.stopAnimate();
        });
        this.animators = [];
        this.canvas.draw();
    };
    Timeline.prototype.getTime = function () {
        return this.current;
    };
    return Timeline;
}());
export default Timeline;
//# sourceMappingURL=timeline.js.map