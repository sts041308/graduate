import { __extends } from "tslib";
import * as Util from '@antv/util';
import Element from './element';
import BBox from './bbox';
import * as Shapes from '../shapes/index';
var SHAPE_MAP = {}; // 缓存图形类型
var INDEX = '_INDEX';
function getComparer(compare) {
    return function (left, right) {
        var result = compare(left, right);
        return result === 0 ? left[INDEX] - right[INDEX] : result;
    };
}
function find(children, x, y) {
    var rst;
    for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (child.cfg.visible && child.cfg.capture && !child.destroyed && !child.removed) {
            if (child.isGroup) {
                rst = child.getShape(x, y);
            }
            else if (child.isHit(x, y)) {
                rst = child;
            }
        }
        if (rst) {
            break;
        }
    }
    return rst;
}
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group(cfg) {
        if (cfg === void 0) { cfg = {}; }
        var _this = _super.call(this, cfg) || this;
        _this.isGroup = true;
        _this.type = 'group';
        _this.canFill = true;
        _this.canStroke = true;
        _this.set('children', []);
        _this.set('tobeRemoved', []);
        _this._beforeRenderUI();
        _this._renderUI();
        _this._bindUI();
        return _this;
    }
    Group.prototype._beforeRenderUI = function () { };
    Group.prototype._renderUI = function () { };
    Group.prototype._bindUI = function () { };
    Group.prototype.addShape = function (type, cfg) {
        var canvas = this.get('canvas');
        cfg = cfg || {};
        var shapeType = SHAPE_MAP[type];
        if (!shapeType) {
            shapeType = Util.upperFirst(type);
            SHAPE_MAP[type] = shapeType;
        }
        if (cfg.attrs && canvas) {
            var attrs = cfg.attrs;
            if (type === 'text') {
                // 临时解决
                var topFontFamily = canvas.get('fontFamily');
                if (topFontFamily) {
                    attrs.fontFamily = attrs.fontFamily ? attrs.fontFamily : topFontFamily;
                }
            }
        }
        cfg.canvas = canvas;
        cfg.type = type;
        var rst = new Shapes[shapeType](cfg);
        this.add(rst);
        return rst;
    };
    /** 添加图组
     * @param  {Function|Object|undefined} param 图组类
     * @param  {Object} cfg 配置项
     * @return {Object} rst 图组
     */
    Group.prototype.addGroup = function (param, cfg) {
        var canvas = this.get('canvas');
        var rst;
        cfg = Util.mix({}, cfg);
        if (Util.isFunction(param)) {
            if (cfg) {
                cfg.canvas = canvas;
                cfg.parent = this;
                rst = new param(cfg);
            }
            else {
                rst = new param({
                    canvas: canvas,
                    parent: this,
                });
            }
            this.add(rst);
        }
        else if (Util.isObject(param)) {
            // @ts-ignore
            param.canvas = canvas;
            rst = new Group(param);
            this.add(rst);
        }
        else if (param === undefined) {
            rst = new Group();
            this.add(rst);
        }
        else {
            return false;
        }
        return rst;
    };
    /** 绘制背景
     * @param  {Array} padding 内边距
     * @param  {Attrs} attrs 图形属性
     * @param  {Shape} backShape 背景图形
     * @return {Object} 背景层对象
     */
    Group.prototype.renderBack = function (padding, attrs) {
        var backShape = this.get('backShape');
        var innerBox = this.getBBox();
        // const parent = this.get('parent'); // getParent
        Util.mix(attrs, {
            x: innerBox.x - padding[3],
            y: innerBox.y - padding[0],
            width: innerBox.width + padding[1] + padding[3],
            height: innerBox.height + padding[0] + padding[2],
        });
        if (backShape) {
            backShape.attr(attrs);
        }
        else {
            backShape = this.addShape('rect', {
                zIndex: -1,
                attrs: attrs,
            });
        }
        this.set('backShape', backShape);
        this.sort();
        return backShape;
    };
    Group.prototype.removeChild = function (item, destroy) {
        if (arguments.length >= 2) {
            if (this.contain(item)) {
                item.remove(destroy);
            }
        }
        else {
            if (arguments.length === 1) {
                if (Util.isBoolean(item)) {
                    destroy = item;
                }
                else {
                    if (this.contain(item)) {
                        item.remove(true);
                    }
                    return this;
                }
            }
            if (arguments.length === 0) {
                destroy = true;
            }
            _super.prototype.remove.call(this, destroy);
        }
        return this;
    };
    /**
     * 向组中添加shape或者group
     * @param {Object} items 图形或者分组
     * @return {Object} group 本尊
     */
    Group.prototype.add = function (items) {
        var self = this;
        var children = self.get('children');
        if (Util.isArray(items)) {
            Util.each(items, function (item) {
                var parent = item.get('parent');
                if (parent) {
                    parent.removeChild(item, false);
                }
                self._setCfgProperty(item);
            });
            self.cfg.children = children.concat(items);
        }
        else {
            var item = items;
            var parent_1 = item.get('parent');
            if (parent_1) {
                parent_1.removeChild(item, false);
            }
            self._setCfgProperty(item);
            children.push(item);
        }
        return self;
    };
    Group.prototype._setCfgProperty = function (item) {
        var cfg = this.cfg;
        item.set('parent', this);
        item.set('canvas', cfg.canvas);
        if (cfg.timeline) {
            item.set('timeline', cfg.timeline);
        }
    };
    Group.prototype.contain = function (item) {
        var children = this.get('children');
        return children.indexOf(item) > -1;
    };
    Group.prototype.getChildByIndex = function (index) {
        var children = this.get('children');
        return children[index];
    };
    Group.prototype.getFirst = function () {
        return this.getChildByIndex(0);
    };
    Group.prototype.getLast = function () {
        var lastIndex = this.get('children').length - 1;
        return this.getChildByIndex(lastIndex);
    };
    Group.prototype.getBBox = function () {
        var self = this;
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var children = self.get('children');
        if (children.length > 0) {
            Util.each(children, function (child) {
                if (child.get('visible')) {
                    /*if (child.isGroup && child.get('children').length === 0) {
                      return;
                    }*/
                    var box = child.getBBox();
                    if (!box) {
                        return true;
                    }
                    var tl = box.tl;
                    var tr = box.tr;
                    var bl = box.bl;
                    var br = box.br;
                    var leftTop = [tl.x, tl.y, 1];
                    var leftBottom = [bl.x, bl.y, 1];
                    var rightTop = [tr.x, tr.y, 1];
                    var rightBottom = [br.x, br.y, 1];
                    child.apply(leftTop);
                    child.apply(leftBottom);
                    child.apply(rightTop);
                    child.apply(rightBottom);
                    var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
                    var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
                    var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
                    var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
                    if (boxMinX < minX) {
                        minX = boxMinX;
                    }
                    if (boxMaxX > maxX) {
                        maxX = boxMaxX;
                    }
                    if (boxMinY < minY) {
                        minY = boxMinY;
                    }
                    if (boxMaxY > maxY) {
                        maxY = boxMaxY;
                    }
                }
            });
        }
        else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        return new BBox(minX, minY, maxX - minX, maxY - minY);
    };
    Group.prototype.getCount = function () {
        return this.get('children').length;
    };
    Group.prototype.sort = function () {
        var children = this.get('children');
        // 稳定排序
        Util.each(children, function (child, index) {
            child[INDEX] = index;
            return child;
        });
        children.sort(getComparer(function (obj1, obj2) {
            return obj1.get('zIndex') - obj2.get('zIndex');
        }));
        return this;
    };
    Group.prototype.findById = function (id) {
        return this.find(function (item) {
            return item.get('id') === id;
        });
    };
    /**
     * 根据查找函数查找分组或者图形
     * @param  {Function} fn 匹配函数
     * @return {Canvas.Base} 分组或者图形
     */
    Group.prototype.find = function (fn) {
        if (Util.isString(fn)) {
            return this.findById(fn);
        }
        var children = this.get('children');
        var rst = null;
        Util.each(children, function (item) {
            if (fn(item)) {
                rst = item;
            }
            else if (item.find) {
                rst = item.find(fn);
            }
            if (rst) {
                return false;
            }
        });
        return rst;
    };
    /**
     * @param  {Function} fn filter mathod
     * @return {Array} all the matching shapes and groups
     */
    Group.prototype.findAll = function (fn) {
        var children = this.get('children');
        var rst = [];
        var childRst = [];
        Util.each(children, function (item) {
            if (fn(item)) {
                rst.push(item);
            }
            if (item.findAllBy) {
                childRst = item.findAllBy(fn);
                rst = rst.concat(childRst);
            }
        });
        return rst;
    };
    /**
     * @Deprecated
     * @param  {Function} fn filter method
     * @return {Object} found shape or group
     */
    Group.prototype.findBy = function (fn) {
        var children = this.get('children');
        var rst = null;
        Util.each(children, function (item) {
            if (fn(item)) {
                rst = item;
            }
            else if (item.findBy) {
                rst = item.findBy(fn);
            }
            if (rst) {
                return false;
            }
        });
        return rst;
    };
    /**
     * @Deprecated
     * @param  {Function} fn filter mathod
     * @return {Array} all the matching shapes and groups
     */
    Group.prototype.findAllBy = function (fn) {
        var children = this.get('children');
        var rst = [];
        var childRst = [];
        Util.each(children, function (item) {
            if (fn(item)) {
                rst.push(item);
            }
            if (item.findAllBy) {
                childRst = item.findAllBy(fn);
                rst = rst.concat(childRst);
            }
        });
        return rst;
    };
    Group.prototype.getShape = function (x, y, e) {
        var self = this;
        var clip = self.attrs.clip;
        var children = self.cfg.children;
        var rst;
        if (clip) {
            var v = [x, y, 1];
            clip.invert(v, self.get('canvas')); // 已经在外面转换
            if (clip.isPointInPath(v[0], v[1])) {
                rst = find(children, x, y);
            }
        }
        else {
            rst = find(children, x, y);
        }
        return rst;
    };
    Group.prototype.clearTotalMatrix = function () {
        var m = this.get('totalMatrix');
        if (m) {
            this.setSilent('totalMatrix', null);
            var children = this.cfg.children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                child.clearTotalMatrix();
            }
        }
    };
    Group.prototype.clear = function (delayRemove) {
        if (this.destroyed) {
            return;
        }
        var children = this.cfg.children;
        for (var i = children.length - 1; i >= 0; i--) {
            children[i].remove(true, delayRemove);
        }
        this.cfg.children = [];
        return this;
    };
    Group.prototype.destroy = function () {
        if (this.destroyed) {
            return;
        }
        this.clear();
        _super.prototype.destroy.call(this);
    };
    Group.prototype.clone = function () {
        var self = this;
        var children = self.cfg.children;
        var clone = new Group();
        Util.each(children, function (child) {
            clone.add(child.clone());
        });
        return clone;
    };
    return Group;
}(Element));
export default Group;
//# sourceMappingURL=group.js.map