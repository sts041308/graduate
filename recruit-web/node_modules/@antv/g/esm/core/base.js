import { __assign, __extends, __spreadArrays } from "tslib";
import EventEmitter from '@antv/event-emitter';
import * as Util from '@antv/util';
import Event from '../event';
var PROPOGATE_EVENTS = [
    'click',
    'mousedown',
    'mouseup',
    'dblclick',
    'contextmenu',
    // 'mouseenter', // 原生 dom 事件，这对就是不冒泡的
    // 'mouseleave',
    'mouseover',
    'mouseout',
    'mousemove',
    'wheel',
    // touch
    'touchstart',
    'touchend',
    'touchmove',
    // 包装出来的方法
    'dragstart',
    'drag',
    'dragend',
    'dragenter',
    'dragleave',
    'drop',
];
var Base = /** @class */ (function (_super) {
    __extends(Base, _super);
    function Base(cfg) {
        if (cfg === void 0) { cfg = {}; }
        var _this = _super.call(this) || this;
        _this.destroyed = false;
        _this.removed = false;
        _this.cfg = __assign(__assign({ canvas: null, capture: true, context: null, parent: null, visible: true, zIndex: 0 }, cfg), _this.getDefaultCfg());
        return _this;
    }
    /**
     * 覆盖父类的 emit，实现事件的冒泡机制
     * @param evt
     * @param e g 层包装之后的 Event 实例
     * @param args 其余数据，仅做透传。
     */
    Base.prototype.emit = function (evt, e) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        // 调用 ee 的事件 emit
        _super.prototype.emit.apply(this, __spreadArrays([evt, e], args));
        // 阻止冒泡
        if (e instanceof Event && e.propagationStopped) {
            return;
        }
        if (PROPOGATE_EVENTS.indexOf(evt) >= 0) {
            var parent_1 = this.cfg.parent;
            if (parent_1 && !parent_1.removed && !parent_1.destroyed) {
                parent_1.emit.apply(parent_1, __spreadArrays([evt, e], args));
            }
        }
    };
    Base.prototype.set = function (name, value) {
        if (name === 'zIndex' && this._beforeSetZIndex) {
            this._beforeSetZIndex(value);
        }
        if (name === 'loading' && this._beforeSetLoading) {
            this._beforeSetLoading(value);
        }
        this.cfg[name] = value;
        return this;
    };
    // deprecated
    Base.prototype.setSilent = function (name, value) {
        this.cfg[name] = value;
    };
    Base.prototype.get = function (name) {
        return this.cfg[name];
    };
    Base.prototype.show = function () {
        this.cfg.visible = true;
        return this;
    };
    Base.prototype.hide = function () {
        this.cfg.visible = false;
        return this;
    };
    Base.prototype.remove = function (destroy, delayRemove) {
        var cfg = this.cfg;
        var parent = cfg.parent;
        var el = cfg.el;
        // 因为 this.destroy 的时候，是清空 cfg，那么取到的 children 为 undefined，导致报错
        // 场景：动画异步启动之后，再调用 group.destroy()，就会导致下一帧动画报错（Util.pull）
        if (parent && !parent.destroyed) {
            Util.pull(parent.get('children'), this);
        }
        if (el) {
            if (delayRemove) {
                parent && parent.cfg.tobeRemoved.push(el);
            }
            else {
                el.parentNode.removeChild(el);
            }
        }
        if (destroy || destroy === undefined) {
            this.destroy();
        }
        return this;
    };
    Base.prototype.destroy = function () {
        if (this.destroyed) {
            return;
        }
        this.off(); // 移除所有的事件
        this.cfg = {};
        this.destroyed = true;
    };
    Base.prototype.getParent = function () {
        return this.cfg.parent;
    };
    Base.prototype.getDefaultCfg = function () {
        return {};
    };
    Base.prototype.toFront = function () {
        var cfg = this.cfg;
        var parent = cfg.parent;
        if (!parent) {
            return;
        }
        var children = parent.cfg.children;
        var el = cfg.el;
        var index = children.indexOf(this);
        children.splice(index, 1);
        children.push(this);
        if (el) {
            el.parentNode.removeChild(el);
            cfg.el = null;
        }
    };
    Base.prototype.toBack = function () {
        var cfg = this.cfg;
        var parent = cfg.parent;
        if (!parent) {
            return;
        }
        var children = parent.cfg.children;
        var el = cfg.el;
        var index = children.indexOf(this);
        children.splice(index, 1);
        children.unshift(this);
        if (el) {
            var parentNode = el.parentNode;
            parentNode.removeChild(el);
            parentNode.insertBefore(el, parentNode.firstChild);
        }
    };
    Base.prototype._beforeSetZIndex = function (zIndex) {
        var parent = this.cfg.parent;
        this.cfg.zIndex = zIndex;
        if (!Util.isNil(parent)) {
            parent.sort();
        }
        var el = this.cfg.el;
        if (el) {
            var children = parent.cfg.children;
            var index = children.indexOf(this);
            var parentNode = el.parentNode;
            parentNode.removeChild(el);
            if (index === children.length - 1) {
                parentNode.appendChild(el);
            }
            else {
                parentNode.insertBefore(el, parentNode.childNodes[index]);
            }
        }
        return zIndex;
    };
    Base.prototype._beforeSetLoading = function (loading) { };
    Base.prototype.setZIndex = function (zIndex) {
        this.cfg.zIndex = zIndex;
        return this._beforeSetZIndex(zIndex);
    };
    Base.prototype.clone = function () {
        return Util.clone(this);
    };
    Base.prototype.getBBox = function () { };
    return Base;
}(EventEmitter));
export default Base;
//# sourceMappingURL=base.js.map