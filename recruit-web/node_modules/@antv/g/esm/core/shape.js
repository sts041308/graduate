import { __extends } from "tslib";
import * as Util from '@antv/util';
import Element from './element';
import * as Inside from '../shapes/util/inside';
var ARRAY_ATTRS = {
    matrix: 'matrix',
    path: 'path',
    points: 'points',
    lineDash: 'lineDash',
};
function _cloneArrayAttr(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        if (Util.isArray(arr[i])) {
            result.push([].concat(arr[i]));
        }
        else {
            result.push(arr[i]);
        }
    }
    return result;
}
var Shape = /** @class */ (function (_super) {
    __extends(Shape, _super);
    function Shape() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isShape = true;
        return _this;
    }
    Shape.prototype.createPath = function (context) { };
    Shape.prototype.afterPath = function (context) { };
    Shape.prototype.isPointInPath = function (x, y) {
        return false;
    };
    Shape.prototype.drawInner = function (context) {
        var attrs = this.attrs;
        this.createPath(context);
        var originOpacity = context.globalAlpha;
        if (this.hasFill()) {
            var fillOpacity = attrs.fillOpacity;
            if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {
                context.globalAlpha = fillOpacity;
                context.fill();
                context.globalAlpha = originOpacity;
            }
            else {
                context.fill();
            }
        }
        if (this.hasStroke()) {
            var lineWidth = this.attrs.lineWidth;
            if (lineWidth > 0) {
                var strokeOpacity = attrs.strokeOpacity;
                if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {
                    context.globalAlpha = strokeOpacity;
                }
                context.stroke();
            }
        }
        this.afterPath(context);
    };
    /**
     * 击中图形时是否进行包围盒判断
     * @return {Boolean} [description]
     */
    Shape.prototype.isHitBox = function () {
        return true;
    };
    /**
     * 节点是否能够被击中
     * @param {Number} x x坐标
     * @param {Number} y y坐标
     * @return {Boolean} 是否在图形中
     */
    Shape.prototype.isHit = function (x, y) {
        var self = this;
        var v = [x, y, 1];
        self.invert(v); // canvas
        if (self.isHitBox()) {
            var box = self.getBBox();
            if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {
                return false;
            }
        }
        var clip = self.attrs.clip;
        if (clip) {
            clip.invert(v, self.get('canvas'));
            if (clip.isPointInPath(v[0], v[1])) {
                return self.isPointInPath(v[0], v[1]);
            }
        }
        else {
            return self.isPointInPath(v[0], v[1]);
        }
        return false;
    };
    /**
     * @protected
     * 计算包围盒
     * @return {Object} 包围盒
     */
    Shape.prototype.calculateBox = function () {
        return null;
    };
    // 获取拾取时线的宽度，需要考虑附加的线的宽度
    Shape.prototype.getHitLineWidth = function () {
        var attrs = this.attrs;
        // if (!attrs.stroke) {
        //   return 0;
        // }
        var lineAppendWidth = attrs.lineAppendWidth || 0;
        var lineWidth = attrs.lineWidth || 0;
        return lineWidth + lineAppendWidth;
    };
    // 清除当前的矩阵
    Shape.prototype.clearTotalMatrix = function () {
        this.cfg.totalMatrix = null;
        this.cfg.region = null;
    };
    Shape.prototype.clearBBox = function () {
        this.cfg.box = null;
        this.cfg.region = null;
    };
    Shape.prototype.getBBox = function () {
        var box = this.get('box');
        // 延迟计算
        if (!box) {
            box = this.calculateBox();
            if (box) {
                this.set('box', box);
            }
        }
        return box;
    };
    Shape.prototype.clone = function () {
        var self = this;
        var clone = null;
        var _attrs = self.attrs;
        var attrs = {};
        Util.each(_attrs, function (i, k) {
            if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {
                attrs[k] = _cloneArrayAttr(_attrs[k]);
            }
            else {
                attrs[k] = _attrs[k];
            }
        });
        clone = new Shape({
            attrs: attrs,
        });
        // zIndex也是绘图属性，但是在cfg中，特殊处理
        clone.cfg.zIndex = self.cfg.zIndex;
        return clone;
    };
    return Shape;
}(Element));
export default Shape;
//# sourceMappingURL=shape.js.map