"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Util = require("@antv/util");
var shape_1 = require("../core/shape");
var Inside = require("./util/inside");
var is_point_in_path_by_ctx_1 = require("./util/is-point-in-path-by-ctx");
var bbox_1 = require("../core/bbox");
var Polygon = /** @class */ (function (_super) {
    tslib_1.__extends(Polygon, _super);
    function Polygon() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.canFill = true;
        _this.canStroke = true;
        _this.type = 'polygon';
        return _this;
    }
    Polygon.prototype.getDefaultAttrs = function () {
        return {
            points: null,
            lineWidth: 1,
        };
    };
    Polygon.prototype.isPointInPath = function (x, y) {
        var self = this;
        var fill = self.hasFill();
        var stroke = self.hasStroke();
        function _isPointInStroke() {
            var attrs = self.attrs;
            var points = attrs.points;
            if (points.length < 2) {
                return false;
            }
            var lineWidth = self.getHitLineWidth();
            var outPoints = points.slice(0);
            if (points.length >= 3) {
                outPoints.push(points[0]);
            }
            return Inside.polyline(outPoints, lineWidth, x, y);
        }
        if (fill && stroke) {
            return is_point_in_path_by_ctx_1.default(x, y, self) || _isPointInStroke();
        }
        if (fill) {
            return is_point_in_path_by_ctx_1.default(x, y, self);
        }
        if (stroke) {
            return _isPointInStroke();
        }
        return false;
    };
    Polygon.prototype.calculateBox = function () {
        var self = this;
        var attrs = self.attrs;
        var points = attrs.points;
        var lineWidth = this.getHitLineWidth();
        if (!points || points.length === 0) {
            return null;
        }
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        Util.each(points, function (point) {
            var x = point[0];
            var y = point[1];
            if (x < minX) {
                minX = x;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (y > maxY) {
                maxY = y;
            }
        });
        var halfWidth = lineWidth / 2;
        return bbox_1.default.fromRange(minX - halfWidth, minY - halfWidth, maxX + halfWidth, maxY + halfWidth);
    };
    Polygon.prototype.createPath = function (context) {
        var self = this;
        var attrs = self.attrs;
        var points = attrs.points;
        if (points.length < 2) {
            return;
        }
        context = context || self.get('context');
        context.beginPath();
        Util.each(points, function (point, index) {
            if (index === 0) {
                context.moveTo(point[0], point[1]);
            }
            else {
                context.lineTo(point[0], point[1]);
            }
        });
        context.closePath();
    };
    return Polygon;
}(shape_1.default));
exports.default = Polygon;
//# sourceMappingURL=polygon.js.map