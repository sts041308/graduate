"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Util = require("@antv/util");
var shape_1 = require("../core/shape");
var Arrow = require("./util/arrow");
var LineMath = require("./math/line");
var Inside = require("./util/inside");
var bbox_1 = require("../core/bbox");
var Polyline = /** @class */ (function (_super) {
    tslib_1.__extends(Polyline, _super);
    function Polyline() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.canStroke = true;
        _this.type = 'polyline';
        _this.tCache = null; // 缓存各点的t  todo
        return _this;
    }
    Polyline.prototype.getDefaultAttrs = function () {
        return {
            points: null,
            lineWidth: 1,
            startArrow: false,
            endArrow: false,
            tCache: null,
        };
    };
    Polyline.prototype.isPointInPath = function (x, y) {
        var self = this;
        var attrs = self.attrs;
        if (self.hasStroke()) {
            var points = attrs.points;
            if (points.length < 2) {
                return false;
            }
            var lineWidth = attrs.lineWidth;
            return Inside.polyline(points, lineWidth, x, y);
        }
        return false;
    };
    Polyline.prototype.calculateBox = function () {
        var self = this;
        var attrs = self.attrs;
        var lineWidth = this.getHitLineWidth();
        var points = attrs.points;
        if (!points || points.length === 0) {
            return null;
        }
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        Util.each(points, function (point) {
            var x = point[0];
            var y = point[1];
            if (x < minX) {
                minX = x;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (y > maxY) {
                maxY = y;
            }
        });
        var halfWidth = lineWidth / 2;
        return bbox_1.default.fromRange(minX - halfWidth, minY - halfWidth, maxX + halfWidth, maxY + halfWidth);
    };
    Polyline.prototype._setTcache = function () {
        var self = this;
        var attrs = self.attrs;
        var points = attrs.points;
        var totalLength = 0;
        var tempLength = 0;
        var tCache = [];
        var segmentT;
        var segmentL;
        if (!points || points.length === 0) {
            return;
        }
        Util.each(points, function (p, i) {
            if (points[i + 1]) {
                totalLength += LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);
            }
        });
        if (totalLength <= 0) {
            return;
        }
        Util.each(points, function (p, i) {
            if (points[i + 1]) {
                segmentT = [];
                segmentT[0] = tempLength / totalLength;
                segmentL = LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);
                tempLength += segmentL;
                segmentT[1] = tempLength / totalLength;
                tCache.push(segmentT);
            }
        });
        this.tCache = tCache;
    };
    Polyline.prototype.createPath = function (context) {
        var self = this;
        var attrs = self.attrs;
        var points = attrs.points;
        var l;
        var i;
        if (points.length < 2) {
            return;
        }
        context = context || self.get('context');
        context.beginPath();
        context.moveTo(points[0][0], points[0][1]);
        for (i = 1, l = points.length - 1; i < l; i++) {
            context.lineTo(points[i][0], points[i][1]);
        }
        context.lineTo(points[l][0], points[l][1]);
    };
    Polyline.prototype.getStartTangent = function () {
        var points = this.attrs.points;
        var result = [];
        result.push([points[1][0], points[1][1]]);
        result.push([points[0][0], points[0][1]]);
        return result;
    };
    Polyline.prototype.getEndTangent = function () {
        var points = this.attrs.points;
        var l = points.length - 1;
        var result = [];
        result.push([points[l - 1][0], points[l - 1][1]]);
        result.push([points[l][0], points[l][1]]);
        return result;
    };
    Polyline.prototype.afterPath = function (context) {
        var self = this;
        var attrs = self.attrs;
        var points = attrs.points;
        var l = points.length - 1;
        context = context || self.get('context');
        if (attrs.startArrow) {
            Arrow.addStartArrow(context, attrs, points[1][0], points[1][1], points[0][0], points[0][1]);
        }
        if (attrs.endArrow) {
            Arrow.addEndArrow(context, attrs, points[l - 1][0], points[l - 1][1], points[l][0], points[l][1]);
        }
    };
    Polyline.prototype.getPoint = function (t) {
        var attrs = this.attrs;
        var points = attrs.points;
        var tCache = this.tCache;
        var subt;
        var index;
        if (!tCache) {
            this._setTcache();
            tCache = this.tCache;
        }
        Util.each(tCache, function (v, i) {
            if (t >= v[0] && t <= v[1]) {
                subt = (t - v[0]) / (v[1] - v[0]);
                index = i;
            }
        });
        return {
            x: LineMath.at(points[index][0], points[index + 1][0], subt),
            y: LineMath.at(points[index][1], points[index + 1][1], subt),
        };
    };
    return Polyline;
}(shape_1.default));
exports.default = Polyline;
//# sourceMappingURL=polyline.js.map