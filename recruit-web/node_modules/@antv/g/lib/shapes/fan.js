"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Util = require("@antv/util");
var arcUtil = require("./math/arc");
var shape_1 = require("../core/shape");
var Inside = require("./util/inside");
var bbox_1 = require("../core/bbox");
var arc_1 = require("./math/arc");
var Fan = /** @class */ (function (_super) {
    tslib_1.__extends(Fan, _super);
    function Fan() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.canFill = true;
        _this.canStroke = true;
        _this.type = 'fan';
        return _this;
    }
    Fan.prototype.getDefaultAttrs = function () {
        return {
            x: 0,
            y: 0,
            rs: 0,
            re: 0,
            startAngle: 0,
            endAngle: 0,
            clockwise: false,
            lineWidth: 1,
        };
    };
    Fan.prototype.isPointInPath = function (x, y) {
        var self = this;
        var fill = self.hasFill();
        var stroke = self.hasStroke();
        var attrs = self.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var rs = attrs.rs;
        var re = attrs.re;
        var startAngle = attrs.startAngle;
        var endAngle = attrs.endAngle;
        var clockwise = attrs.clockwise;
        var v1 = [1, 0];
        var subv = [x - cx, y - cy];
        var angle = Util.vec2.angleTo(v1, subv);
        function _isPointInFill() {
            var angle1 = arcUtil.nearAngle(angle, startAngle, endAngle, clockwise);
            if (Util.isNumberEqual(angle, angle1)) {
                var ls = Util.vec2.squaredLength(subv);
                if (rs * rs <= ls && ls <= re * re) {
                    return true;
                }
            }
            return false;
        }
        function _isPointInStroke() {
            var lineWidth = self.getHitLineWidth();
            var ssp = {
                x: Math.cos(startAngle) * rs + cx,
                y: Math.sin(startAngle) * rs + cy,
            };
            var sep = {
                x: Math.cos(startAngle) * re + cx,
                y: Math.sin(startAngle) * re + cy,
            };
            var esp = {
                x: Math.cos(endAngle) * rs + cx,
                y: Math.sin(endAngle) * rs + cy,
            };
            var eep = {
                x: Math.cos(endAngle) * re + cx,
                y: Math.sin(endAngle) * re + cy,
            };
            if (Inside.line(ssp.x, ssp.y, sep.x, sep.y, lineWidth, x, y)) {
                return true;
            }
            if (Inside.line(esp.x, esp.y, eep.x, eep.y, lineWidth, x, y)) {
                return true;
            }
            if (Inside.arcline(cx, cy, rs, startAngle, endAngle, clockwise, lineWidth, x, y)) {
                return true;
            }
            if (Inside.arcline(cx, cy, re, startAngle, endAngle, clockwise, lineWidth, x, y)) {
                return true;
            }
            return false;
        }
        if (fill && stroke) {
            return _isPointInFill() || _isPointInStroke();
        }
        if (fill) {
            return _isPointInFill();
        }
        if (stroke) {
            return _isPointInStroke();
        }
        return false;
    };
    Fan.prototype.calculateBox = function () {
        var self = this;
        var attrs = self.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var rs = attrs.rs;
        var re = attrs.re;
        var startAngle = attrs.startAngle;
        var endAngle = attrs.endAngle;
        var clockwise = attrs.clockwise;
        var lineWidth = this.getHitLineWidth();
        var boxs = arc_1.box(cx, cy, rs, startAngle, endAngle, clockwise);
        var boxe = arc_1.box(cx, cy, re, startAngle, endAngle, clockwise);
        var minX = Math.min(boxs.minX, boxe.minX);
        var minY = Math.min(boxs.minY, boxe.minY);
        var maxX = Math.max(boxs.maxX, boxe.maxX);
        var maxY = Math.max(boxs.maxY, boxe.maxY);
        var halfWidth = lineWidth / 2;
        return bbox_1.default.fromRange(minX - halfWidth, minY - halfWidth, maxX + halfWidth, maxY + halfWidth);
    };
    Fan.prototype.createPath = function (context) {
        var self = this;
        var attrs = self.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var rs = attrs.rs;
        var re = attrs.re;
        var startAngle = attrs.startAngle;
        var endAngle = attrs.endAngle;
        var clockwise = attrs.clockwise;
        var ssp = {
            x: Math.cos(startAngle) * rs + cx,
            y: Math.sin(startAngle) * rs + cy,
        };
        var sep = {
            x: Math.cos(startAngle) * re + cx,
            y: Math.sin(startAngle) * re + cy,
        };
        var esp = {
            x: Math.cos(endAngle) * rs + cx,
            y: Math.sin(endAngle) * rs + cy,
        };
        context = context || self.get('context');
        context.beginPath();
        context.moveTo(ssp.x, ssp.y);
        context.lineTo(sep.x, sep.y);
        context.arc(cx, cy, re, startAngle, endAngle, clockwise);
        context.lineTo(esp.x, esp.y);
        context.arc(cx, cy, rs, endAngle, startAngle, !clockwise);
        context.closePath();
    };
    return Fan;
}(shape_1.default));
exports.default = Fan;
//# sourceMappingURL=fan.js.map