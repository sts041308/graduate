"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Util = require("@antv/util");
var Format = require("../../util/format");
var shape_1 = require("../../core/shape");
var path_segment_1 = require("../util/path-segment");
var Inside = require("../util/inside");
var bbox_1 = require("../../core/bbox");
var symbols_1 = require("./symbols");
var Marker = /** @class */ (function (_super) {
    tslib_1.__extends(Marker, _super);
    function Marker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'marker';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Marker.prototype.getDefaultAttrs = function () {
        return {
            path: null,
            x: 0,
            y: 0,
            lineWidth: 1,
        };
    };
    Marker.prototype.isPointInPath = function (x, y) {
        var attrs = this.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.radius;
        var lineWidth = this.getHitLineWidth();
        return Inside.circle(cx, cy, r + lineWidth / 2, x, y);
    };
    Marker.prototype.calculateBox = function () {
        var attrs = this.attrs;
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.radius;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2 + r;
        return bbox_1.default.fromRange(cx - halfWidth, cy - halfWidth, cx + halfWidth, cy + halfWidth);
    };
    Marker.prototype._getPath = function () {
        var attrs = this.attrs;
        var x = attrs.x;
        var y = attrs.y;
        var r = attrs.radius;
        var symbol = attrs.symbol || 'circle';
        var method;
        if (Util.isFunction(symbol)) {
            method = symbol;
        }
        else {
            method = symbols_1.default.get(symbol);
        }
        if (!method) {
            // 容错，防止绘制出错
            console.warn(method + " symbol is not exist.");
            return null;
        }
        return method(x, y, r);
    };
    Marker.prototype.createPath = function (context) {
        var segments = this.cfg.segments;
        if (segments && !this.cfg.hasUpdate) {
            context.beginPath();
            for (var i = 0; i < segments.length; i++) {
                segments[i].draw(context);
            }
            return;
        }
        var path = Format.parsePath(this._getPath());
        context.beginPath();
        var preSegment;
        segments = [];
        for (var i = 0; i < path.length; i++) {
            var item = path[i];
            preSegment = new path_segment_1.default(item, preSegment, i === path.length - 1);
            segments.push(preSegment);
            preSegment.draw(context);
        }
        this.cfg.segments = segments;
        this.cfg.hasUpdate = false;
    };
    // 作为其静态属性
    Marker.symbolsFactory = symbols_1.default;
    return Marker;
}(shape_1.default));
exports.default = Marker;
//# sourceMappingURL=index.js.map