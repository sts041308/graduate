"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Util = require("@antv/util");
var shape_1 = require("../core/shape");
var path_segment_1 = require("./util/path-segment");
var Format = require("../util/format");
var Arrow = require("./util/arrow");
var PathUtil = require("../util/path");
var CubicMath = require("./math/cubic");
var is_point_in_path_by_ctx_1 = require("./util/is-point-in-path-by-ctx");
var bbox_1 = require("../core/bbox");
var Path = /** @class */ (function (_super) {
    tslib_1.__extends(Path, _super);
    function Path() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.canFill = true;
        _this.canStroke = true;
        _this.type = 'path';
        return _this;
    }
    Path.prototype.getDefaultAttrs = function () {
        return {
            path: null,
            lineWidth: 1,
            startArrow: false,
            endArrow: false,
        };
    };
    Path.prototype.isPointInPath = function (x, y) {
        var self = this;
        var segments = self.get('segments');
        var fill = self.hasFill();
        var stroke = self.hasStroke();
        function _isPointInStroke() {
            if (!Util.isEmpty(segments)) {
                var lineWidth = self.getHitLineWidth();
                for (var i = 0, l = segments.length; i < l; i++) {
                    if (segments[i].isInside(x, y, lineWidth)) {
                        return true;
                    }
                }
                return false;
            }
        }
        if (fill && stroke) {
            return is_point_in_path_by_ctx_1.default(x, y, self) || _isPointInStroke();
        }
        if (fill) {
            return is_point_in_path_by_ctx_1.default(x, y, self);
        }
        if (stroke) {
            return _isPointInStroke();
        }
        return false;
    };
    Path.prototype._afterSetAttrPath = function (path) {
        var self = this;
        if (Util.isNil(path)) {
            self.setSilent('segments', null);
            self.setSilent('box', undefined);
            return;
        }
        var pathArray = Format.parsePath(path);
        var preSegment;
        var segments = [];
        if (!Util.isArray(pathArray) || pathArray.length === 0 || (pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm')) {
            return;
        }
        var count = pathArray.length;
        for (var i = 0; i < pathArray.length; i++) {
            var item = pathArray[i];
            preSegment = new path_segment_1.default(item, preSegment, i === count - 1);
            segments.push(preSegment);
        }
        self.setSilent('segments', segments);
        self.setSilent('tCache', null);
        self.setSilent('box', null);
    };
    Path.prototype.calculateBox = function () {
        var self = this;
        var segments = self.get('segments');
        if (!segments) {
            return null;
        }
        var lineWidth = this.getHitLineWidth();
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        Util.each(segments, function (segment) {
            segment.getBBox(lineWidth);
            var box = segment.box;
            if (box) {
                if (box.x < minX) {
                    minX = box.x;
                }
                var boxMaxX = box.maxX;
                if (boxMaxX > maxX) {
                    maxX = boxMaxX;
                }
                if (box.y < minY) {
                    minY = box.y;
                }
                var boxMaxY = box.maxY;
                if (boxMaxY > maxY) {
                    maxY = boxMaxY;
                }
            }
        });
        if (minX === Infinity || minY === Infinity) {
            return new bbox_1.default(0, 0, 0, 0);
        }
        return new bbox_1.default(minX, minY, maxX - minX, maxY - minY);
    };
    Path.prototype._setTcache = function () {
        var totalLength = 0;
        var tempLength = 0;
        var tCache = [];
        var segmentT;
        var segmentL;
        var segmentN;
        var l;
        var curve = this.cfg.curve;
        if (!curve) {
            return;
        }
        Util.each(curve, function (segment, i) {
            segmentN = curve[i + 1];
            l = segment.length;
            if (segmentN) {
                totalLength += CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
            }
        });
        Util.each(curve, function (segment, i) {
            segmentN = curve[i + 1];
            l = segment.length;
            if (segmentN) {
                segmentT = [];
                segmentT[0] = tempLength / totalLength;
                segmentL = CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
                tempLength += segmentL;
                segmentT[1] = tempLength / totalLength;
                tCache.push(segmentT);
            }
        });
        this.cfg.tCache = tCache;
    };
    Path.prototype._calculateCurve = function () {
        var self = this;
        var attrs = self.attrs;
        var path = attrs.path;
        this.cfg.curve = PathUtil.pathTocurve(path);
    };
    Path.prototype.getStartTangent = function () {
        var segments = this.get('segments');
        var startPoint, endPoint, tangent, result;
        if (segments.length > 1) {
            startPoint = segments[0].endPoint;
            endPoint = segments[1].endPoint;
            tangent = segments[1].startTangent;
            result = [];
            if (Util.isFunction(tangent)) {
                var v = tangent();
                result.push([startPoint.x - v[0], startPoint.y - v[1]]);
                result.push([startPoint.x, startPoint.y]);
            }
            else {
                result.push([endPoint.x, endPoint.y]);
                result.push([startPoint.x, startPoint.y]);
            }
        }
        return result;
    };
    Path.prototype.getEndTangent = function () {
        var segments = this.get('segments');
        var segmentsLen = segments.length;
        var startPoint, endPoint, tangent, result;
        if (segmentsLen > 1) {
            startPoint = segments[segmentsLen - 2].endPoint;
            endPoint = segments[segmentsLen - 1].endPoint;
            tangent = segments[segmentsLen - 1].endTangent;
            result = [];
            if (Util.isFunction(tangent)) {
                var v = tangent();
                result.push([endPoint.x - v[0], endPoint.y - v[1]]);
                result.push([endPoint.x, endPoint.y]);
            }
            else {
                result.push([startPoint.x, startPoint.y]);
                result.push([endPoint.x, endPoint.y]);
            }
        }
        return result;
    };
    Path.prototype.getPoint = function (t) {
        var tCache = this.cfg.tCache;
        var subt;
        var index;
        if (!tCache) {
            this._calculateCurve();
            this._setTcache();
            tCache = this.cfg.tCache;
        }
        var curve = this.cfg.curve;
        if (!tCache) {
            if (curve) {
                return {
                    x: curve[0][1],
                    y: curve[0][2],
                };
            }
            return null;
        }
        Util.each(tCache, function (v, i) {
            if (t >= v[0] && t <= v[1]) {
                subt = (t - v[0]) / (v[1] - v[0]);
                index = i;
            }
        });
        var seg = curve[index];
        if (Util.isNil(seg) || Util.isNil(index)) {
            return null;
        }
        var l = seg.length;
        var nextSeg = curve[index + 1];
        return {
            x: CubicMath.at(seg[l - 2], nextSeg[1], nextSeg[3], nextSeg[5], 1 - subt),
            y: CubicMath.at(seg[l - 1], nextSeg[2], nextSeg[4], nextSeg[6], 1 - subt),
        };
    };
    Path.prototype.createPath = function (context) {
        var self = this;
        var segments = self.get('segments');
        if (!Util.isArray(segments)) {
            return;
        }
        context = context || self.get('context');
        context.beginPath();
        var segmentsLen = segments.length;
        for (var i = 0; i < segmentsLen; i++) {
            segments[i].draw(context);
        }
    };
    Path.prototype.afterPath = function (context) {
        var self = this;
        var attrs = self.attrs;
        var segments = self.get('segments');
        var path = attrs.path;
        context = context || self.get('context');
        if (!Util.isArray(segments)) {
            return;
        }
        if (segments.length === 1) {
            return;
        }
        if (!attrs.startArrow && !attrs.endArrow) {
            return;
        }
        if (path[path.length - 1] === 'z' || path[path.length - 1] === 'Z' || attrs.fill) {
            // 闭合路径不绘制箭头
            return;
        }
        var startPoints = self.getStartTangent();
        Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);
        var endPoints = self.getEndTangent();
        Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);
    };
    return Path;
}(shape_1.default));
exports.default = Path;
//# sourceMappingURL=path.js.map