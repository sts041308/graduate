"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Util = require("@antv/util");
var base_1 = require("./base");
// 是否未改变
function isUnchanged(m) {
    return m[0] === 1 && m[1] === 0 && m[3] === 0 && m[4] === 1 && m[6] === 0 && m[7] === 0;
}
// 是否仅仅是scale
function isScale(m) {
    return m[1] === 0 && m[3] === 0 && m[6] === 0 && m[7] === 0;
}
function multiple(m1, m2) {
    if (!isUnchanged(m2)) {
        if (isScale(m2)) {
            m1[0] *= m2[0];
            m1[4] *= m2[4];
        }
        else {
            Util.mat3.multiply(m1, m1, m2);
        }
    }
}
var Attribute = /** @class */ (function (_super) {
    tslib_1.__extends(Attribute, _super);
    // defaultAttrs: ElementAttrs = {};
    function Attribute(cfg) {
        if (cfg === void 0) { cfg = {}; }
        var _this = _super.call(this, cfg) || this;
        _this.canFill = false;
        _this.canStroke = false;
        _this.attrs = {};
        _this.attrs = {
            opacity: 1,
            fillOpacity: 1,
            strokeOpacity: 1,
            matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1],
        };
        _this.attr(tslib_1.__assign(tslib_1.__assign({}, _this.getDefaultAttrs()), _this.cfg.attrs));
        _this.cfg.attrs = {};
        return _this;
    }
    Attribute.prototype.getDefaultAttrs = function () {
        return {};
    };
    /**
     * 设置或者设置属性，有以下 4 种情形：
     *   - name 不存在, 则返回属性集合
     *   - name 为字符串，value 为空，获取属性值
     *   - name 为字符串，value 不为空，设置属性值，返回 this
     *   - name 为键值对，value 为空，设置属性值
     *
     * @param  {String | Object} name  属性名
     * @param  {*} value 属性值
     * @return {*} 属性值
     */
    Attribute.prototype.attr = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var name = args[0], value = args[1];
        if (!name)
            return this.attrs;
        if (Util.isObject(name)) {
            for (var k in name) {
                this._setAttr(k, name[k]);
            }
            this.clearBBox();
            this.cfg.hasUpdate = true;
            return this;
        }
        if (args.length === 2) {
            this._setAttr(name, value);
            this.clearBBox();
            this.cfg.hasUpdate = true;
            return this;
        }
        return this.attrs[name];
    };
    Attribute.prototype._afterSetAttrPath = function (value) { };
    Attribute.prototype._setAttr = function (name, value) {
        var attrs = this.attrs;
        attrs[name] = value;
        if (name === 'fill' || name === 'stroke') {
            attrs[name + 'Style'] = value;
            return;
        }
        if (name === 'opacity') {
            attrs.globalAlpha = value;
            return;
        }
        if (name === 'clip' && value) {
            this._setClip(value);
            return;
        }
        if (name === 'path') {
            this._afterSetAttrPath(value);
            return;
        }
        if (name === 'transform') {
            this.transform(value);
            return;
        }
        if (name === 'rotate') {
            this.rotateAtStart(value);
        }
    };
    Attribute.prototype.clearBBox = function () {
        this.setSilent('box', null);
    };
    Attribute.prototype.hasFill = function () {
        return this.canFill && this.attrs.fillStyle;
    };
    Attribute.prototype.hasStroke = function () {
        return this.canStroke && this.attrs.strokeStyle;
    };
    Attribute.prototype._setClip = function (item) {
        item.cfg.renderer = this.cfg.renderer;
        item.cfg.canvas = this.cfg.canvas;
        item.cfg.parent = this.cfg.parent;
        item.hasFill = function () {
            return true;
        };
    };
    // transform
    Attribute.prototype.initTransform = function () { };
    Attribute.prototype.resetMatrix = function () {
        this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);
    };
    Attribute.prototype.translate = function (tx, ty) {
        var matrix = this.attrs.matrix;
        Util.mat3.translate(matrix, matrix, [tx, ty]);
        this.clearTotalMatrix();
        this.attr('matrix', matrix);
        return this;
    };
    Attribute.prototype.rotate = function (radian) {
        var matrix = this.attrs.matrix;
        Util.mat3.rotate(matrix, matrix, radian);
        this.clearTotalMatrix();
        this.attr('matrix', matrix);
        return this;
    };
    Attribute.prototype.scale = function (s1, s2) {
        var matrix = this.attrs.matrix;
        Util.mat3.scale(matrix, matrix, [s1, s2]);
        this.clearTotalMatrix();
        this.attr('matrix', matrix);
        return this;
    };
    Attribute.prototype.rotateAtStart = function (rotate) {
        var x = this.attrs.x || 0;
        var y = this.attrs.y || 0;
        if (Math.abs(rotate) > Math.PI * 2) {
            rotate = (rotate / 180) * Math.PI;
        }
        return this.transform([['t', -x, -y], ['r', rotate], ['t', x, y]]);
    };
    Attribute.prototype.move = function (x, y) {
        var cx = this.get('x') || 0; // 当前的x
        var cy = this.get('y') || 0; // 当前的y
        this.translate(x - cx, y - cy);
        this.set('x', x);
        this.set('y', y);
        return this;
    };
    Attribute.prototype.transform = function (ts) {
        var _this = this;
        var matrix = this.attrs.matrix;
        Util.each(ts, function (t) {
            switch (t[0]) {
                case 't':
                    _this.translate(t[1], t[2]);
                    break;
                case 's':
                    _this.scale(t[1], t[2]);
                    break;
                case 'r':
                    _this.rotate(t[1]);
                    break;
                case 'm':
                    _this.attr('matrix', Util.mat3.multiply([], matrix, t[1]));
                    _this.clearTotalMatrix();
                    break;
                default:
                    break;
            }
        });
        return this;
    };
    Attribute.prototype.setTransform = function (ts) {
        this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        return this.transform(ts);
    };
    Attribute.prototype.getMatrix = function () {
        return this.attr('matrix');
    };
    Attribute.prototype.setMatrix = function (m) {
        this.attr('matrix', m);
        this.clearTotalMatrix();
        return this;
    };
    Attribute.prototype.apply = function (v, root) {
        var m;
        if (root) {
            m = this._getMatrixByRoot(root);
        }
        else {
            m = this.attr('matrix');
        }
        Util.vec3.transformMat3(v, v, m);
        return this;
    };
    // 获取到达指定根节点的矩阵
    Attribute.prototype._getMatrixByRoot = function (root) {
        root = root || this;
        var parent = this;
        var parents = [];
        while (parent !== root) {
            parents.unshift(parent);
            parent = parent.get('parent');
        }
        parents.unshift(parent);
        var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        Util.each(parents, function (child) {
            Util.mat3.multiply(m, child.attr('matrix'), m);
        });
        return m;
    };
    /**
     * 应用到当前元素上的总的矩阵
     * @return {Matrix} 矩阵
     */
    Attribute.prototype.getTotalMatrix = function () {
        var m = this.cfg.totalMatrix;
        if (!m) {
            m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            var parent_1 = this.cfg.parent;
            if (parent_1) {
                var pm = parent_1.getTotalMatrix();
                multiple(m, pm);
            }
            multiple(m, this.attr('matrix'));
            this.cfg.totalMatrix = m;
        }
        return m;
    };
    // 清除当前的矩阵
    Attribute.prototype.clearTotalMatrix = function () {
        // this.cfg.totalMatrix = null;
    };
    Attribute.prototype.invert = function (v) {
        var m = this.getTotalMatrix();
        // 单精屏幕下大多数矩阵没变化
        if (isScale(m)) {
            v[0] /= m[0];
            v[1] /= m[4];
        }
        else {
            var inm = Util.mat3.invert([], m);
            if (inm) {
                Util.vec3.transformMat3(v, v, inm);
            }
        }
        return this;
    };
    Attribute.prototype.resetTransform = function (context) {
        var mo = this.attr('matrix');
        // 不改变时
        if (!isUnchanged(mo)) {
            context.transform(mo[0], mo[1], mo[3], mo[4], mo[6], mo[7]);
        }
    };
    return Attribute;
}(base_1.default));
exports.default = Attribute;
//# sourceMappingURL=attribute.js.map